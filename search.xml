<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三种类型设计模式的特点</title>
      <link href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/"/>
      <url>/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/</url>
      
        <content type="html"><![CDATA[<h2 id="一-创建型模式的特点和分类"><a href="#一-创建型模式的特点和分类" class="headerlink" title="一.创建型模式的特点和分类"></a>一.创建型模式的特点和分类</h2><p>创建型模式的主要关注点是如何创建对象？，它的主要特点是将对象的创建与使用分离。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像去商场购物，不需要知道商品是怎么生产出来的，因为他们由专门的厂商生产。</p><p>创建型模式分为以下几种</p><p>●单例模式：某各类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。<br>●原型模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。<br>●工厂方法：定义一个用于创建产品的接口，由子类决定生产什么产品。<br>●抽象工厂：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。<br>●建造者模式：将一个复杂对象分解成多个相对简单部分，然后根据不同需要分别创建他们，最后构建成该复杂对象。</p><p>以上5种创建型模式，除了工厂方法模式属于类创建型模式，其他全部属于对象创建型模式，我们将在之后的教程中详细的介绍他们的特点木结构与应用。</p><h2 id="二-结构型模式概述"><a href="#二-结构型模式概述" class="headerlink" title="二.结构型模式概述"></a>二.结构型模式概述</h2><p>结构型模式描述如何将类或者对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足合成复用原则，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种</p><p>●代理模式：为某对象提供一种代理以控制该对象的访问，即客户端通过代理间接的访问该对象，从而限制，增强或者修改该对象的一些特性。<br>●适配器模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>●桥接模式：将抽象与实现分离，使他们可以独立变化。他是用组合关系来代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合性。<br>●装饰着模式：动态的给对象增加一些职责，即增加额外的功能。<br>●外观模式：将多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。<br>●享元模式：运用共享技术来有效的支持大量细粒度对象的复用<br>●组合模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致访问性</p><p>以上7种结构型模式，除了适配器模式分为类结构模式和对象结构型模式两种，其他的全部属于对象结构型模式。</p><h2 id="三-行为型模式概述"><a href="#三-行为型模式概述" class="headerlink" title="三.行为型模式概述"></a>三.行为型模式概述</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式包含11种设计模式</p><p>●模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。<br>●策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。<br>●命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。<br>●职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。<br>●状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。<br>●观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。<br>●中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。<br>●迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>●访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br>●备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。<br>●解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为模式，其他的全部属于对象行为型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 10.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件架构的基本原则</title>
      <link href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一-软件架构的两个要点"><a href="#一-软件架构的两个要点" class="headerlink" title="一.软件架构的两个要点"></a>一.软件架构的两个要点</h2><h3 id="1-代码复用"><a href="#1-代码复用" class="headerlink" title="1.代码复用"></a>1.代码复用</h3><p>无论是开发哪种软件产品，成本和时间都是最重要的。较少的开发时间意味着可以比竞争对手更早进入市场。较低的开发成本意味着能够留出更多的营销资金，覆盖更广泛的潜在客户。</p><p>代码复用是减少开发成本最常用的方式之一，其目的非常明显，即：与其反复从头开发，不如在新对象中重用已有的代码。</p><p>使用设计模式是增加软件组件灵活性并使其易于复用的方式之一。但是，这可能也会让组件变得更加复杂。</p><p>一般情况下，复用可以分为三个层次。在最底层，可以复用类、类库、容器，也许还有一些类的“团体（例如容器和迭代器）”。</p><p>框架位于最高层。它们能帮助你精简自己的设计，可以明确解决问题所需的抽象概念，然后用类来表示这些概念并定义其关系。例如，JUnit  是一个小型框架，也是框架的“Hello, world”，其中定义了 Test、TestCase 和 TestSuite  这几个类及其关系。框架通常比单个类的颗粒度要大。你可以通过在某处构建子类来与框架建立联系。这些子类信奉“别给我们打电话，我们会给你打电话的。”</p><p>还有一个中间层次。这是我觉得设计模式所处的位置。设计模式比框架更小且更抽象。它们实际上是对一组类的关系及其互动方式的描述。当你从类转向模式，并最终到达框架的过程中，复用程度会不断增加。</p><p>中间层次的优点在于模式提供的复用方式要比框架的风险小。创建框架是一项投入重大且风险很高的工作，模式则能让你独立于具体代码来复用设计思想和理念。</p><h3 id="2-扩展性"><a href="#2-扩展性" class="headerlink" title="2.扩展性"></a>2.扩展性</h3><p>需求变化是程序员生命中唯一不变的事情。比如以下几种场景：</p><p>●你在 Windows 平台上发布了一款游戏，现在人们想要 Mac OS 的版本。<br>●你创建了一个使用方形按钮的 GUI 框架，但几个月后开始流行原型按钮。<br>●你设计了一款优秀的电子商务网站，但仅仅几个月后，客户就要求新增电话订单的功能。</p><p>首先，在完成了第一版的程序后，我们就应该做好了从头开始优化重写代码的准备，因为现在你已经能在很多方面更好的理解问题了，同时在专业水平上也有所提高，所以之前的代码现在看上去可能会显得很糟糕。</p><p>其次，可能是在你掌控之外的某些事情发生了变化，这也是导致许多开发团队转变最初想法的原因。比如，每位在网络应用中使用 Flash 的开发者都必须重新开发或移植代码，因为不断地有浏览器停止对 Flash 格式地支持。</p><p>最后，可能是需求的改变，之前你的客户对当前版本的程序感到满意，但是现在希望对程序进行 11 个“小小”的改动，使其可完成原始计划阶段中完全没有提到的功能，新增或改变功能。</p><p>当然这也有好的一面，如果有人要求你对程序进行修改，至少说明还有人关心它。因此在设计程序架构时，有经验的开发者都会尽量选择支持未来任何可能变更的方式。</p><h2 id="二-正确使用设计模式"><a href="#二-正确使用设计模式" class="headerlink" title="二.正确使用设计模式"></a>二.正确使用设计模式</h2><p>设计模式不是为每个人准备的，而是基于业务来选择设计模式，需要时就能想到它。要明白一点，技术永远为业务服务，技术只是满足业务需要的一个工具。我们需要掌握每种设计模式的应用场景、特征、优缺点，以及每种设计模式的关联关系，这样就能够很好地满足日常业务的需要。</p><p>设计模式不是为了特定场景而生的，而是为了让人可以更好和更快地开发。</p><p>设计模式只是实现了七大设计原则的具体方式，套用太多设计模式只会陷入模式套路陷阱，最后代码写的凌乱不堪。</p><p>不能为了使用设计模式而去做架构，而是有了做架构的需求后，发现它符合某一类设计模式的结构，在将两者结合。</p><p>想要游刃有余地使用设计模式，需要打下牢固的程序设计语言基础、夯实自己的编程思想、积累大量的时间经验、提高开发能力。目的都是让程序低耦合，高复用，高内聚，易扩展，易维护。</p><h3 id="1-需求驱动"><a href="#1-需求驱动" class="headerlink" title="1.需求驱动"></a>1.需求驱动</h3><p>不仅仅是功能性需求，需求驱动还包括性能和运行时的需求，如软件的可维护性和可复用性等方面。设计模式是针对软件设计的，而软件设计是针对需求的，一定不要为了使用设计模式而使用设计模式，否则可能会使设计变得复杂，使软件难以调试和维护。</p><h3 id="2-分析已经存在的项目"><a href="#2-分析已经存在的项目" class="headerlink" title="2.分析已经存在的项目"></a>2.分析已经存在的项目</h3><p>对现有的应用实例进行分析是一个很好的学习途径，应当注意学习已有的项目，而不仅是学习设计模式如何实现，更重要的是注意在什么场合使用设计模式。</p><h3 id="3-掌握当前开发平台"><a href="#3-掌握当前开发平台" class="headerlink" title="3.掌握当前开发平台"></a>3.掌握当前开发平台</h3><p>设计模式大部分都是针对面向对象的软件设计，因此在理论上适合任何面向对象的语言，但随着技术的发展和编程环境的改善，设计模式的实现方式会有很大的差别。在一些平台下，某些设计模式是自然实现的。</p><h3 id="4-开发中领悟"><a href="#4-开发中领悟" class="headerlink" title="4.开发中领悟"></a>4.开发中领悟</h3><p>软件开发是一项实践工作，最直接的方法就是编程。没有从来不下棋却熟悉定式的围棋高手，也没有不会编程就能成为架构设计师的先例。掌握设计模式是水到渠成的事情，除了理论只是和实践积累，可能会“渐悟”或者“顿悟”。</p><h3 id="5-避免过度设计"><a href="#5-避免过度设计" class="headerlink" title="5.避免过度设计"></a>5.避免过度设计</h3><p>设计模式解决的是设计不足的问题，但同时也要避免设计过度。一定要牢记简洁原则，要知道设计模式是为了使设计简单，而不是更复杂。如果引入设计模式使得设计变得复杂，只能说我们把简单问题复杂化了，问题本身不需要设计模式。</p><p>这里需要把握的是需求变化的程度，一定要区分需求的稳定部分和可变部分。一个软件必然有稳定部分，这个部分就是核心业务逻辑。如果核心业务逻辑发生变化，软件就没有存在的必要，核心业务逻辑是我们需要固化的。对于可变的部分，需要判断可能发生变化的程度来确定设计策略和设计风险。要知道，设计过度与设计不足同样对项目有害。</p><p>设计模式从来都不是单个设计模式独立使用的。在实际应用中，通常多个设计模式混合使用，你中有我，我中有你。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/V0j4Pw.png" alt="image-20250111101142847"></p><h2 id="三-开闭原则"><a href="#三-开闭原则" class="headerlink" title="三.开闭原则"></a>三.开闭原则</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>软件实体应当对扩展开放，对修改关闭。</p><p>何为软件实体？</p><p>●项目中划分出的模块<br>●类与接口<br>●方法</p><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h3><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。</p><p>●软件测试：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>●提高代码复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>●提高软件可维护性：遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p><h3 id="3-实现方法"><a href="#3-实现方法" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>Windows 的桌面主题设计</p><p>Windows  的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific  Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/59CQQd.png" alt="image-20250111101254524"></p><h2 id="四-里氏替换原则"><a href="#四-里氏替换原则" class="headerlink" title="四.里氏替换原则"></a>四.里氏替换原则</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h3><p>继承必须确保超类所拥有的性质在子类中仍然成立</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h3><p>●里氏替换原则是实现开闭原则的重要方式之一<br>●它克服了继承中重写父类造成的可复用性变差的缺点<br>●它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性<br>●加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险</p><h3 id="3-实现方法-1"><a href="#3-实现方法-1" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>●子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法<br>●子类中可以增加自己特有的方法<br>●当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松<br>●当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</p><p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><p>里氏替换原则在“几维鸟不是鸟”实例中的应用。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行  300  千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。</p><p>正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/KyYuVb.png" alt="image-20250111101416400"></p><h2 id="五-依赖倒置原则"><a href="#五-依赖倒置原则" class="headerlink" title="五.依赖倒置原则"></a>五.依赖倒置原则</h2><h3 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h3><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</p><p>核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h3 id="2-作用-2"><a href="#2-作用-2" class="headerlink" title="2.作用"></a>2.作用</h3><p>●依赖倒置原则可以降低类间的耦合性。<br>●依赖倒置原则可以提高系统的稳定性。<br>●依赖倒置原则可以减少并行开发引起的风险。<br>●依赖倒置原则可以提高代码的可读性和可维护性。</p><h3 id="3-实现方法-2"><a href="#3-实现方法-2" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><p>●每个类尽量提供接口或抽象类，或者两者都具备。<br>●变量的声明类型尽量是接口或者是抽象类。<br>●任何类都不应该从具体类派生<br>●使用继承时尽量遵循里氏替换原则</p><p>依赖倒置原则在“顾客购物程序”中的应用。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/iWxVDM.png" alt="image-20250111101509052"></p><h2 id="六-单一职责原则"><a href="#六-单一职责原则" class="headerlink" title="六.单一职责原则"></a>六.单一职责原则</h2><h3 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h3><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><p>●一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>●当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><p>●降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>●提高类的可读性。复杂性降低，自然其可读性会提高。<br>●提高系统的可维护性。可读性提高，那自然更容易维护了。<br>●变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p><h3 id="3-实现方法-3"><a href="#3-实现方法-3" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><p>大学学生工作管理程序</p><p>分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/AA4pQv.png" alt="image-20250111101625019"></p><p>单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><h2 id="七-接口隔离原则"><a href="#七-接口隔离原则" class="headerlink" title="七.接口隔离原则"></a>七.接口隔离原则</h2><h3 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h3><p>单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><p>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><p>●单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>●单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><h3 id="2-优点-1"><a href="#2-优点-1" class="headerlink" title="2.优点"></a>2.优点</h3><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><p>1将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><h3 id="3-实现方法-4"><a href="#3-实现方法-4" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><p>●接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>●为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>●了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>●提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><p>学生成绩管理程序</p><p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/sw42jO.png" alt="image-20250111101728882"></p><h2 id="八-迪米特法则"><a href="#八-迪米特法则" class="headerlink" title="八.迪米特法则"></a>八.迪米特法则</h2><h3 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h3><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h3 id="2-优点-2"><a href="#2-优点-2" class="headerlink" title="2.优点"></a>2.优点</h3><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><p>1降低了类之间的耦合度，提高了模块的相对独立性。<br>2由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</p><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h3 id="3-实现方法-5"><a href="#3-实现方法-5" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><p>1从依赖者的角度来说，只依赖应该依赖的对象。<br>2从被依赖者的角度说，只暴露应该暴露的方法。</p><p>所以，在运用迪米特法则时要注意以下 6 点。</p><p>1在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>2在类的结构设计上，尽量降低类成员的访问权限。<br>3在类的设计上，优先考虑将一个类设置成不变类。<br>4在对其他类的引用上，将引用其他对象的次数降到最低。<br>5不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>6谨慎使用序列化（Serializable）功能。</p><p>明星与经纪人的关系实例</p><p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/jXMTWS.png" alt="image-20250111101813153"></p><h2 id="九-合成复用原则"><a href="#九-合成复用原则" class="headerlink" title="九.合成复用原则"></a>九.合成复用原则</h2><h3 id="1-定义-6"><a href="#1-定义-6" class="headerlink" title="1.定义"></a>1.定义</h3><p>它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><h3 id="2-优点-3"><a href="#2-优点-3" class="headerlink" title="2.优点"></a>2.优点</h3><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><p>1继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>2子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>3它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><p>1它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>2新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>3复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p><h3 id="3-实现方法-6"><a href="#3-实现方法-6" class="headerlink" title="3.实现方法"></a>3.实现方法</h3><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p><p>汽车分类管理程序</p><p>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继承关系实现的汽车分类的类图。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/11/3Tv269.png" alt="image-20250111101920231"></p><h2 id="十-总结"><a href="#十-总结" class="headerlink" title="十.总结"></a>十.总结</h2><p>7 种设计原则，它们分别为开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、迪米特法则和合成复用原则。</p><p>这 7  种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p><table><thead><tr><th>设计原则</th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table><p>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p><p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p>]]></content>
      
      
      <categories>
          
          <category> 10.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-软件设计概述"><a href="#一-软件设计概述" class="headerlink" title="一.软件设计概述"></a>一.软件设计概述</h2><h3 id="1-软件设计的概念"><a href="#1-软件设计的概念" class="headerlink" title="1.软件设计的概念"></a>1.软件设计的概念</h3><p>软件设计模式（或者说是设计模式），是一套被反复使用，多数人知晓的，经过系统整理的代码设计经验的总结。</p><p>它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。</p><p>它是解决特定问题的一系列套路，是代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><p>其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h3 id="2-学习设计模式的意义"><a href="#2-学习设计模式的意义" class="headerlink" title="2.学习设计模式的意义"></a>2.学习设计模式的意义</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p><p>●可以提高程序员的思维能力、编程能力和设计能力。<br>●使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。<br>●使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</p><p>软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p><h3 id="3-软件设计模式的基本要素"><a href="#3-软件设计模式的基本要素" class="headerlink" title="3.软件设计模式的基本要素"></a>3.软件设计模式的基本要素</h3><p>●名称：可以根据模式的问题、特点、解决方案、功能和效果来命名。<br>●问题：描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。<br>●方案：包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。<br>●效果：模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。</p><h2 id="二-设计模式的分类与功能"><a href="#二-设计模式的分类与功能" class="headerlink" title="二.设计模式的分类与功能"></a>二.设计模式的分类与功能</h2><h3 id="1-根据目的来分"><a href="#1-根据目的来分" class="headerlink" title="1.根据目的来分"></a>1.根据目的来分</h3><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p><p>●创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。<br>●结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。<br>●行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p><h3 id="2-根据作用范围来分"><a href="#2-根据作用范围来分" class="headerlink" title="2.根据作用范围来分"></a>2.根据作用范围来分</h3><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</p><p>●类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。<br>●对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</p><table><thead><tr><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类）适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例 原型 抽象工厂 建造者</td><td>代理 (对象）适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><h3 id="3-设计模式的功能"><a href="#3-设计模式的功能" class="headerlink" title="3.设计模式的功能"></a>3.设计模式的功能</h3><p>1单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。<br>2原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。<br>3工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。<br>4抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。<br>5建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。<br>6代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。<br>7适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>8桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br>9装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。<br>10外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。<br>11享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。<br>12组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。<br>13模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。<br>14策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。<br>15命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。<br>16职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。<br>17状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。<br>18观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。<br>19中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。<br>20迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>21访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br>22备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。<br>23解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><h2 id="三-UML统一建模语言"><a href="#三-UML统一建模语言" class="headerlink" title="三.UML统一建模语言"></a>三.UML统一建模语言</h2><p>UML（Unified Modeling Language，统一建模语言）是用来设计软件蓝图的可视化建模语言，是一种为面向对象系统的产品进行说明、可视化和编制文档的标准语言，独立于任何一种具体的程序设计语言。</p><p>它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1.应用场景"></a>1.应用场景</h3><p>UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。</p><p>UML  具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。</p><p>UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。</p><h3 id="2-基本构件"><a href="#2-基本构件" class="headerlink" title="2.基本构件"></a>2.基本构件</h3><p>UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML  提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML  中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/eZJ7iS.png" alt="image-20250110100100361"></p><p>下面对具体构件进行说明。</p><h3 id="3-事物"><a href="#3-事物" class="headerlink" title="3.事物"></a>3.事物</h3><p>事物是抽象化的最终结果，分为结构事物、行为事物、分组事物和注释事物。</p><h4 id="1）结构事物"><a href="#1）结构事物" class="headerlink" title="1）结构事物"></a>1）结构事物</h4><p>结构事物是模型中的静态部分，用以呈现概念或实体的表现元素。</p><table><thead><tr><th>事物</th><th>解释</th><th>图例</th></tr></thead><tbody><tr><td>类（Class）</td><td>具有相同属性、方法、关系和语义的对象集合</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/5MwGkV.png" alt="image-20250110100246818"></td></tr><tr><td>接口（Interface）</td><td>指一个类或构件的一个服务的操作集合，它仅仅定义了一组操作的规范，并没有给出这组操作的具体实现</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/4sc7Pd.png" alt="image-20250110100256947"></td></tr><tr><td>用例（User Case）</td><td>指对一组动作序列的描述，系统执行这些动作将产生一个对特定的参与者（Actor）有价值且可观察的结果</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/qLqBJj.png" alt="image-20250110100305144"></td></tr><tr><td>协作（Collaboration）</td><td>定义元素之间的相互作用</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/pbBGJG.png" alt="image-20250110100316892"></td></tr><tr><td>组件（Component）</td><td>描述物理系统的一部分</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/fy2zMg.png" alt="image-20250110100325762"></td></tr><tr><td>活动类（Active Class）</td><td>指对象有一个或多个进程或线程。活动类和类很相象，只是它的对象代表的元素的行为和其他元素是同时存在的</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/PGps49.png" alt="image-20250110100332125"></td></tr><tr><td>节点（Node）</td><td>定义为运行时存在的物理元素</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/b3nJGX.png" alt="image-20250110100339903"></td></tr></tbody></table><h4 id="2）行为事物"><a href="#2）行为事物" class="headerlink" title="2）行为事物"></a>2）行为事物</h4><p>行为事物指 UML 模型中的动态部分。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>交互（Interaction）</td><td>包括一组元素之间的消息交换</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/NE2SXn.png" alt="image-20250110100422524"></td></tr><tr><td>状态机（State Machine）</td><td>由一系列对象的状态组成</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/NhrDW2.png" alt="image-20250110100429239"></td></tr></tbody></table><h4 id="3）分组事物"><a href="#3）分组事物" class="headerlink" title="3）分组事物"></a>3）分组事物</h4><p>目前只有一种分组事物，即包。包纯碎是概念上的，只存在于开发阶段，结构事物、行为事物甚至分组事物都有可能放在一个包中。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>包（Package）</td><td>UML中唯一的组织机制</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/6VdLXL.png" alt="image-20250110100543052"></td></tr></tbody></table><h4 id="4）注释事物"><a href="#4）注释事物" class="headerlink" title="4）注释事物"></a>4）注释事物</h4><p>注释事物是解释 UML 模型元素的部分。</p><table><thead><tr><th>事物</th><th>解释</th><th>用例</th></tr></thead><tbody><tr><td>注释（Note）</td><td>用于解析说明 UML 元素</td><td><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/CnxRyT.png" alt="image-20250110100636801"></td></tr></tbody></table><h3 id="4-图"><a href="#4-图" class="headerlink" title="4.图"></a>4.图</h3><p>UML2.0 一共有 13 种图（UML1.5 定义了 9 种，UML2.0 增加了 4 种），分别是类图、对象图、构件图、部署图、活动图、状态图、用例图、时序图、协作图 9 种，以及包图、组合结构图、时间图、交互概览图 4 种。</p><table><thead><tr><th>图名称</th><th>解释</th></tr></thead><tbody><tr><td>类图（Class Diagrams）</td><td>用于定义系统中的类</td></tr><tr><td>对象图（Object Diagrams）</td><td>类图的一个实例，描述了系统在具体时间点上所包含的对象及各个对象之间的关系</td></tr><tr><td>构件图（Component Diagrams）</td><td>一种特殊的 UML 图，描述系统的静态实现视图</td></tr><tr><td>部署图（Deployment Diagrams）</td><td>定义系统中软硬件的物理体系结构</td></tr><tr><td>活动图（Activity Diagrams）</td><td>用来描述满足用例要求所要进行的活动及活动间的约束关系</td></tr><tr><td>状态图（State Chart Diagrams）</td><td>用来描述类的对象的所有可能的状态和时间发生时，状态的转移条件</td></tr><tr><td>用例图（Usecase Diagrams）</td><td>用来描述用户的需求，从用户的角度描述系统的功能，并指出各功能的执行者，强调谁在使用系统、系统为执行者完成哪些功能</td></tr><tr><td>时序图（Sequence Diagrams）</td><td>描述对象之间的交互顺序，着重体现对象间消息传递的时间顺序，强调对象之间消息的发送顺序，同时显示对象之间的交互过程</td></tr><tr><td>协作图（Collaboration Diagrams）</td><td>描述对象之间的合作关系，更侧重向用户对象说明哪些对象有消息的传递</td></tr><tr><td>包图（Package Diagrams）</td><td>对构成系统的模型元素进行分组整理的图</td></tr><tr><td>组合结构图（Composite Structure Diagrams）</td><td>表示类或者构建内部结构的图</td></tr><tr><td>时间图（Timing Diagrams）</td><td>用来显示随时间变化，一个或多个元素的值或状态的更改，也显示时间控制事件之间的交互及管理它们的时间和期限约束</td></tr><tr><td>交互概览图（Interaction Overview Diagrams）</td><td>用活动图来表示多个交互之间的控制关系的图</td></tr></tbody></table><h2 id="四-UML类图及类图之间的关系"><a href="#四-UML类图及类图之间的关系" class="headerlink" title="四.UML类图及类图之间的关系"></a>四.UML类图及类图之间的关系</h2><p>类图是一种模型类型，确切地说，是一种静态模型类型。类图表示类、接口和它们之间的协作关系，用于系统设计阶段。</p><h3 id="1-类、接口、类图"><a href="#1-类、接口、类图" class="headerlink" title="1.类、接口、类图"></a>1.类、接口、类图</h3><h4 id="1）类"><a href="#1）类" class="headerlink" title="1）类"></a>1）类</h4><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p><p>(1) 类名（Name）是一个字符串，例如，Student。</p><p>(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]属性名:类型[=默认值]</span><br></pre></td></tr></table></figure><p>例如：-name:String</p><p>注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</p><p>(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]名称(参数列表)[:返回类型]</span><br></pre></td></tr></table></figure><p>例如：+display():void。</p><p>如下所示是学生类的 UML 表示。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/4qvgCs.png" alt="image-20250110101200709"></p><p>类图中，需注意以下几点：</p><p>●抽象类或抽象方法用斜体表示<br>●如果是接口，则在类名上方加 &lt;&gt;<br>●字段和方法返回值的数据类型非必需<br>●静态类或静态方法加下划线</p><h4 id="2）接口"><a href="#2）接口" class="headerlink" title="2）接口"></a>2）接口</h4><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p><p>如下所示是图形类接口的 UML 表示。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/afMzK9.png" alt="image-20250110101241881"></p><h4 id="3-类图"><a href="#3-类图" class="headerlink" title="3)类图"></a>3)类图</h4><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p><p>类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/Bg2BOK.png" alt="image-20250110101311717"></p><p>计算长方形与圆形的周长与面积</p><h3 id="2-类之间的关系"><a href="#2-类之间的关系" class="headerlink" title="2.类之间的关系"></a>2.类之间的关系</h3><p>UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><h4 id="1）依赖关系"><a href="#1）依赖关系" class="headerlink" title="1）依赖关系"></a>1）依赖关系</h4><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。如下是人与手机的关系图，人通过手机的语音传送方法打电话。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/aGe8BU.png" alt="image-20250110101359955"></p><p>![image-20250110101404441](/Users/a58/Library/Application Support/typora-user-images/image-20250110101404441.png)</p><p>依赖关系的实例</p><h4 id="2）关联关系"><a href="#2）关联关系" class="headerlink" title="2）关联关系"></a>2）关联关系</h4><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。如下是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/W6LJol.png" alt="image-20250110101444602"></p><h4 id="3）聚合关系"><a href="#3）聚合关系" class="headerlink" title="3）聚合关系"></a>3）聚合关系</h4><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。如下是大学和教师的关系图。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/oN4hsL.png" alt="image-20250110101505142"></p><h4 id="4）组合关系"><a href="#4）组合关系" class="headerlink" title="4）组合关系"></a>4）组合关系</h4><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。如下是头和嘴的关系图。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/PSlzMf.png" alt="image-20250110101530214"></p><h4 id="5）泛化关系"><a href="#5）泛化关系" class="headerlink" title="5）泛化关系"></a>5）泛化关系</h4><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下所示。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/HNzd1A.png" alt="image-20250110101555792"></p><h4 id="6）实现关系"><a href="#6）实现关系" class="headerlink" title="6）实现关系"></a>6）实现关系</h4><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下所示。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/Iyjttv.png" alt="image-20250110101618909"></p><h3 id="3-类关系记忆技巧"><a href="#3-类关系记忆技巧" class="headerlink" title="3.类关系记忆技巧"></a>3.类关系记忆技巧</h3><table><thead><tr><th>分类</th><th>箭头特征</th><th>记忆技巧</th></tr></thead><tbody><tr><td>箭头方向</td><td>从子类指向父类</td><td>定义子类需要通过 extends 关键字指定父类 子类一定是知道父类定义的，但父类并不知道子类的定义 只有知道对方信息时才能指向对方 箭头的方向是从子类指向父类</td></tr><tr><td>继承/实现</td><td>用线条连接两个类； 空心三角箭头表示继承或实现</td><td>实现表示继承，是is-a的关系，表示扩展，不虚，很结实 虚线表示实现，虚线代表“虚”无实体</td></tr><tr><td>关联/依赖</td><td>用线条连接两个类； 普通箭头表示关联或依赖</td><td>虚线表示依赖关系：临时用一下，若即若离，虚无缥缈，若有若无 表示一种使用关系，一个类需要借助另一个类来实现功能 一般一个类将另一个类作为参数使用，或作为返回值 实线表示关联关系：关系稳定，实打实的关系 表示一个类对象和另一个类对象有关联 通常一个类中有另一个类对象作为属性</td></tr><tr><td>组合/聚合</td><td>用菱形表示：像一个盛东西的器皿（如盘子）</td><td>聚合：空心菱形，代表空器皿里可以放很多相同的东西，聚集在一起（箭头方向所指的类） 整体和局部的关系，两者有独立的生命周期，是 has-a 的关系 弱关系，消极的词：弱-空 组合：实心菱形，代表器皿里已经有实体结构的存在，生死与共 整体与局部的关系，和聚合关系对比，关系更加强烈，两者具有相同的生命周期，contains-a 的关系 强关系，积极的词；强-满</td></tr></tbody></table><p>UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。</p><p>下图是对动物衍生关系描述的类图。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/10/LZJmUc.png" alt="image-20250110101720306"></p>]]></content>
      
      
      <categories>
          
          <category> 10.设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-避免缓存穿透的利器之BloomFilter</title>
      <link href="/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/"/>
      <url>/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/</url>
      
        <content type="html"><![CDATA[<h2 id="Bloom-Filter-概念"><a href="#Bloom-Filter-概念" class="headerlink" title="Bloom Filter 概念"></a>Bloom Filter 概念</h2><p>布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><h2 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/RALcK1.png" alt="img"></p><p>缓存穿透</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/rAKFHB.png" alt="img"></p><p>每次查询都会直接打到DB</p><p>简而言之，言而简之就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3</p><p>那就用id：1 为例子他在上图中经过三次hash之后，把三次原本值0的地方改为1</p><p>下次数据进来查询的时候如果id的值是1，那么我就把1拿去三次hash 发现三次hash的值，跟上面的三个位置完全一样，那就能证明过滤器中有1的</p><p>反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来防止缓存击穿</p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><p>这玩意这么好使那有啥缺点么？有的，我们接着往下看</p><h2 id="Bloom-Filter的缺点"><a href="#Bloom-Filter的缺点" class="headerlink" title="Bloom Filter的缺点"></a>Bloom Filter的缺点</h2><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p><ul><li>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</li><li>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="https://link.juejin.cn/?target=http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&modificationDate=1526538500000&api=v2">Counting Bloom Filter</a></li></ul><h2 id="Bloom-Filter-实现"><a href="#Bloom-Filter-实现" class="headerlink" title="Bloom Filter 实现"></a>Bloom Filter 实现</h2><p>布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。</p><p>在使用bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，</p><p>在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</p><p>对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p><h3 id="1-Bit数组大小选择"><a href="#1-Bit数组大小选择" class="headerlink" title="(1)Bit数组大小选择"></a>(1)Bit数组大小选择</h3><p>  根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/f7zRFH.png" alt="img"></p><h3 id="2-哈希函数选择"><a href="#2-哈希函数选择" class="headerlink" title="(2)哈希函数选择"></a>(2)哈希函数选择</h3><p> 由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/RveN2u.png" alt="img"></p><p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p><p>哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="https://link.juejin.cn/?target=http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a>，<a href="https://link.juejin.cn/?target=https://en.wikipedia.org/wiki/Bloom_filter">Bloom_filter-wikipedia</a></p><p>要使用BloomFilter，需要引入guava包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;            </span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;           </span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;            </span><br><span class="line">    &lt;version&gt;<span class="number">23.0</span>&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;   </span><br></pre></td></tr></table></figure><p>测试分两步：</p><p>1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器</p><p>2、另外找一万个数，去检验漏网之鱼的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试布隆过滤器(可用于redis缓存穿透)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 敖丙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total);</span><br><span class="line"><span class="comment">//    private static BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化1000000条数据到过滤器中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            bf.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配已在过滤器中的值，是否有匹配不上的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bf.mightContain(i)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;有坏人逃脱了~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配不在过滤器中的10000个值，有多少匹配出来</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total; i &lt; total + <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bf.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;误伤的数量：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/hkfvvN.png" alt="img"></p><p>运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><p>看下BloomFilter的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>) expectedInsertions);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, expectedInsertions, <span class="number">0.03</span>); <span class="comment">// FYI, for 3%, we always get 5 hash functions</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><p>funnel：数据类型(一般是调用Funnels工具类中的)</p><p>expectedInsertions：期望插入的值的个数</p><p>fpp 错误率(默认值为0.03)</p><p>strategy 哈希算法(我也不懂啥意思)Bloom Filter的应用</p><p>在最后一个create方法中，设置一个断点：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/qBXOP8.png" alt="img"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/zIcWjb.png" alt="img"></p><p>上面的numBits，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要4<em>8</em>1000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的numHashFunctions，表示需要5个函数去存这些数字</p><p>使用第三个create方法，我们设置下错误率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bf = BloomFilter.create(Funnels.integerFunnel(), total, <span class="number">0.0003</span>);</span><br></pre></td></tr></table></figure><p>再运行看看：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/0x8kAw.png" alt="img"></p><p>此时误伤的数量为4，错误率为0.04%左右。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/UdbqPO.png" alt="img"></p><p>当错误率设为0.0003时，所需要的位数为16883499，1600万位，需要12个函数</p><p>和上面对比可以看出，错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大</p><p>常见的几个应用场景：</p><ul><li>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</li><li>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li><li>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>布隆过滤器主要是在回答道缓存穿透的时候引出来的，文章里面还是写的比较复杂了，很多都是网上我看到就复制下来了，大家只要知道他的原理，还有就是知道他的场景能在面试中回答出他的作用就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性hash</title>
      <link href="/2025/01/03/5.%E7%BC%93%E5%AD%98/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2025/01/03/5.%E7%BC%93%E5%AD%98/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      
        <content type="html"><![CDATA[<p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/3ewwv5.png" alt="img"></p><p>整个空间按<strong>顺时针方向组织</strong>，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为<strong>Hash环</strong>。</p><p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/mnVEar.png" alt="img"></p><p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p><p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/jLyAHD.png" alt="img"></p><p>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/dcVBkF.jpeg" alt="img"></p><p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/GnRaYo.png" alt="img"></p><p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p><p>综上所述，<strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><p>一致性Hash算法在<strong>服务节点太少时</strong>，容易因为节点分部不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/sst6R2.png" alt="img"></p><p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/AW4w6u.png" alt="img"></p><p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(7)——intset</title>
      <link href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(7)%E2%80%94%E2%80%94intset/"/>
      <url>/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(7)%E2%80%94%E2%80%94intset/</url>
      
        <content type="html"><![CDATA[<p>Redis里面使用intset是为了实现集合(set)这种对外的数据结构。set结构类似于数学上的集合的概念，它包含的元素无序，且不能重复。Redis里的set结构还实现了基础的集合并、交、差的操作。与Redis对外暴露的其它数据结构类似，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。概括来讲，当set中添加的元素都是整型且元素数目较少时，set使用intset作为底层数据结构，否则，set使用dict作为底层数据结构。</p><p>在本文中我们将大体分成三个部分进行介绍：</p><p>集中介绍intset数据结构。<br>讨论set是如何在intset和dict基础上构建起来的。<br>集中讨论set的并、交、差的算法实现以及时间复杂度。注意，其中差集的计算在Redis中实现了两种算法。<br>我们在讨论中还会涉及到一个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-max-intset-entries <span class="number">512</span></span><br></pre></td></tr></table></figure><p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p><p>intset数据结构简介<br>intset顾名思义，是由整数组成的集合。实际上，intset是一个由整数组成的有序集合，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。</p><p>intset的数据结构定义如下（出自intset.h和intset.c）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">uint32_t encoding;</span><br><span class="line">uint32_t length;</span><br><span class="line">int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line">#<span class="function">define <span class="title">INTSET_ENC_INT16</span> <span class="params">(sizeof(int16_t)</span>)</span></span><br><span class="line"><span class="function">#define <span class="title">INTSET_ENC_INT32</span> <span class="params">(sizeof(int32_t)</span>)</span></span><br><span class="line"><span class="function">#define <span class="title">INTSET_ENC_INT64</span> <span class="params">(sizeof(int64_t)</span>)</span></span><br></pre></td></tr></table></figure><p>各个字段含义如下：</p><p>encoding: 数据编码，表示intset中的每个数据元素用几个字节来存储。它有三种可能的取值：INTSET_ENC_INT16表示每个元素用2个字节存储，INTSET_ENC_INT32表示每个元素用4个字节存储，INTSET_ENC_INT64表示每个元素用8个字节存储。因此，intset中存储的整数最多只能占用64bit。<br>length: 表示intset中的元素个数。encoding和length两个字段构成了intset的头部（header）。<br>contents: 是一个柔性数组（flexible array member），表示intset的header后面紧跟着数据元素。这个数组的总长度（即总字节数）等于encoding * length。柔性数组在Redis的很多数据结构的定义中都出现过（例如sds, quicklist, skiplist），用于表达一个偏移量。contents需要单独为其分配空间，这部分内存不包含在intset结构当中。<br>其中需要注意的是，intset可能会随着数据的添加而改变它的数据编码：</p><p>最开始，新创建的intset使用占内存最小的INTSET_ENC_INT16（值为2）作为数据编码。<br>每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。<br>下图给出了一个添加数据的具体例子（点击看大图）。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/qTKjzc.png" alt="intset添加数据举例"></p><p>在上图中：</p><p>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。<br>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。<br>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。<br>在添加每个元素的过程中，intset始终保持从小到大有序。<br>与ziplist类似，intset也是按小端（little endian）模式存储的（参见维基百科词条Endianness）。比如，在上图中intset添加完所有数据之后，表示encoding字段的4个字节应该解释成0x00000004，而第5个数据应该解释成0x000186A0 = 100000。<br>intset与ziplist相比：</p><p>ziplist可以存储任意二进制串，而intset只能存储整数。<br>ziplist是无序的，而intset是从小到大有序的。因此，在ziplist上查找只能遍历，而在intset上可以进行二分查找，性能更高。<br>ziplist可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段len），而intset只能整体使用一个统一的编码（encoding）。<br>intset的查找和添加操作<br>要理解intset的一些实现细节，只需要关注intset的两个关键操作基本就可以了：查找（intsetFind）和添加（intsetAdd）元素。</p><p>intsetFind的关键代码如下所示（出自intset.c）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint8_t <span class="title">intsetFind</span><span class="params">(intset *is, int64_t value)</span> </span>&#123;</span><br><span class="line">uint8_t valenc = _intsetValueEncoding(value);</span><br><span class="line"><span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, int64_t value, uint32_t *pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)-<span class="number">1</span>, mid = -<span class="number">1</span>;</span><br><span class="line">int64_t cur = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((unsigned <span class="keyword">int</span>)min + (unsigned <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid-<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于以上代码，我们需要注意的地方包括：</p><p>intsetFind在指定的intset中查找指定的元素value，找到返回1，没找到返回0。<br>_intsetValueEncoding函数会根据要查找的value落在哪个范围而计算出相应的数据编码（即它应该用几个字节来存储）。<br>如果value所需的数据编码比当前intset的编码要大，则它肯定在当前intset所能存储的数据范围之外（特别大或特别小），所以这时会直接返回0；否则调用intsetSearch执行一个二分查找算法。<br>intsetSearch在指定的intset中查找指定的元素value，如果找到，则返回1并且将参数pos指向找到的元素位置；如果没找到，则返回0并且将参数pos指向能插入该元素的位置。<br>intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：<br>特殊处理intset为空的情况。<br>特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。<br>真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。<br>代码中出现的intrev32ifbe是为了在需要的时候做大小端转换的。前面我们提到过，intset里的数据是按小端（little endian）模式存储的，因此在大端（big endian）机器上运行时，这里的intrev32ifbe会做相应的转换。<br>这个查找算法的总的时间复杂度为O(log n)。<br>而intsetAdd的关键代码如下所示（出自intset.c）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;</span><br><span class="line">uint8_t valenc = _intsetValueEncoding(value);</span><br><span class="line">uint32_t pos;</span><br><span class="line"><span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于以上代码，我们需要注意的地方包括：</p><p>intsetAdd在intset中添加新元素value。如果value在添加前已经存在，则不会重复添加，这时参数success被置为0；如果value在原来intset中不存在，则将value插入到适当位置，这时参数success被置为0。<br>如果要添加的元素value所需的数据编码比当前intset的编码要大，那么则调用intsetUpgradeAndAdd将intset的编码进行升级后再插入value。<br>调用intsetSearch，如果能查到，则不会重复添加。<br>如果没查到，则调用intsetResize对intset进行内存扩充，使得它能够容纳新添加的元素。因为intset是一块连续空间，因此这个操作会引发内存的realloc（参见<a href="http://man.cx/realloc%EF%BC%89%E3%80%82%E8%BF%99%E6%9C%89%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E3%80%82%E5%90%8C%E6%97%B6%E8%B0%83%E7%94%A8intsetMoveTail%E5%B0%86%E5%BE%85%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E5%90%8E%E9%9D%A2%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%9F%E4%B8%80%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A81%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E8%BF%99%E4%B9%9F%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E3%80%82%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E5%9C%A8intsetMoveTail%E4%B8%AD%E6%98%AF%E8%B0%83%E7%94%A8memmove%E5%AE%8C%E6%88%90%E8%BF%99%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E7%9A%84%E3%80%82memmove%E4%BF%9D%E8%AF%81%E4%BA%86%E5%9C%A8%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%8D%E4%BC%9A%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E9%87%8D%E5%8F%A0%E6%88%96%E8%A6%86%E7%9B%96%EF%BC%8C%E5%85%B7%E4%BD%93%E5%8F%82%E8%A7%81http://man.cx/memmove%E3%80%82">http://man.cx/realloc）。这有可能带来一次数据拷贝。同时调用intsetMoveTail将待插入位置后面的元素统一向后移动1个位置，这也涉及到一次数据拷贝。值得注意的是，在intsetMoveTail中是调用memmove完成这次数据拷贝的。memmove保证了在拷贝过程中不会造成数据重叠或覆盖，具体参见http://man.cx/memmove。</a><br>intsetUpgradeAndAdd的实现中也会调用intsetResize来完成内存扩充。在进行编码升级时，intsetUpgradeAndAdd的实现会把原来intset中的每个元素取出来，再用新的编码重新写入新的位置。<br>注意一下intsetAdd的返回值，它返回一个新的intset指针。它可能与传入的intset指针is相同，也可能不同。调用方必须用这里返回的新的intset，替换之前传进来的旧的intset变量。类似这种接口使用模式，在Redis的实现代码中是很常见的，比如我们之前在介绍sds和ziplist的时候都碰到过类似的情况。<br>显然，这个intsetAdd算法总的时间复杂度为O(n)。<br>Redis的set<br>为了更好地理解Redis对外暴露的set数据结构，我们先看一下set的一些关键的命令。下面是一些命令举例：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/j8ypEM.png" alt="set命令举例"></p><p>上面这些命令的含义：</p><p>sadd用于分别向集合s1和s2中添加元素。添加的元素既有数字，也有非数字（”a”和”b”）。<br>sismember用于判断指定的元素是否在集合内存在。<br>sinter, sunion和sdiff分别用于计算集合的交集、并集和差集。<br>我们前面提到过，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。例如，具体到上述命令的执行过程中，集合s1的底层数据结构会发生如下变化：</p><p>在开始执行完sadd s1 13 5之后，由于添加的都是比较小的整数，所以s1底层是一个intset，其数据编码encoding = 2。<br>在执行完sadd s1 32768 10 100000之后，s1底层仍然是一个intset，但其数据编码encoding从2升级到了4。<br>在执行完sadd s1 a b之后，由于添加的元素不再是数字，s1底层的实现会转成一个dict。<br>我们知道，dict是一个用于维护key和value映射关系的数据结构，那么当set底层用dict表示的时候，它的key和value分别是什么呢？实际上，key就是要添加的集合元素，而value是NULL。</p><p>除了前面提到的由于添加非数字元素造成集合底层由intset转成dict之外，还有两种情况可能造成这种转换：</p><p>添加了一个数字，但它无法用64bit的有符号数来表达。intset能够表达的最大的整数范围为-264~264-1，因此，如果添加的数字超出了这个范围，这也会导致intset转成dict。<br>添加的集合元素个数超过了set-max-intset-entries配置的值的时候，也会导致intset转成dict（具体的触发条件参见t_set.c中的setTypeAdd相关代码）。<br>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p><p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p><p>Redis set的并、交、差算法<br>Redis set的并、交、差算法的实现代码，在t_set.c中。其中计算交集调用的是sinterGenericCommand，计算并集和差集调用的是sunionDiffGenericCommand。它们都能同时对多个（可以多于2个）集合进行运算。当对多个集合进行差集运算时，它表达的含义是：用第一个集合与第二个集合做差集，所得结果再与第三个集合做差集，依次向后类推。</p><p>我们在这里简要介绍一下三个算法的实现思路。</p><p>交集<br>计算交集的过程大概可以分为三部分：</p><p>检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，则不用继续计算了，最终的交集就是空集。<br>对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。<br>对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。<br>需要注意的是，上述第3步在集合中进行查找，对于intset和dict的存储来说时间复杂度分别是O(log n)和O(1)。但由于只有小集合才使用intset，所以可以粗略地认为intset的查找也是常数时间复杂度的。因此，如Redis官方文档上所说（<a href="http://redis.io/commands/sinter%EF%BC%89%EF%BC%8Csinter%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%EF%BC%9A">http://redis.io/commands/sinter），sinter命令的时间复杂度为：</a></p><p>O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</p><p>并集<br>计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。向集合中添加元素会自动去重。</p><p>由于要遍历所有集合的每个元素，所以Redis官方文档给出的sunion命令的时间复杂度为（<a href="http://redis.io/commands/sunion%EF%BC%89%EF%BC%9A">http://redis.io/commands/sunion）：</a></p><p>O(N) where N is the total number of elements in all given sets.</p><p>注意，这里同前面讨论交集计算一样，将元素插入到结果集合的过程，忽略intset的情况，认为时间复杂度为O(1)。</p><p>差集<br>计算差集有两种可能的算法，它们的时间复杂度有所区别。</p><p>第一种算法：</p><p>对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。<br>这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。</p><p>第二种算法：</p><p>将第一个集合的所有元素都加入到一个中间集合中。<br>遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。<br>最后中间集合剩下的元素就构成了差集。<br>这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。</p><p>在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。还有两点需要注意：</p><p>在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。<br>如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。<br>对于sdiff的时间复杂度，Redis官方文档（<a href="http://redis.io/commands/sdiff%EF%BC%89%E5%8F%AA%E7%BB%99%E5%87%BA%E4%BA%86%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E6%98%AF%E4%B8%8D%E5%87%86%E7%A1%AE%E7%9A%84%E3%80%82">http://redis.io/commands/sdiff）只给出了第二种算法的结果，是不准确的。</a></p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(6)——skiplist</title>
      <link href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(6)%E2%80%94%E2%80%94skiplist/"/>
      <url>/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(6)%E2%80%94%E2%80%94skiplist/</url>
      
        <content type="html"><![CDATA[<p>Redis里面使用skiplist是为了实现sorted set这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。同时，skiplist这种数据结构对于很多人来说都比较陌生，因为大部分学校里的算法课都没有对这种数据结构进行过详细的介绍。因此，为了介绍得足够清楚，本文会比这个系列的其它几篇花费更多的篇幅。</p><p>我们将大体分成三个部分进行介绍：</p><p>介绍经典的skiplist数据结构，并进行简单的算法分析。这一部分的介绍，与Redis没有直接关系。我会尝试尽量使用通俗易懂的语言进行描述。<br>讨论Redis里的skiplist的具体实现。为了支持sorted set本身的一些要求，在经典的skiplist基础上，Redis里的相应实现做了若干改动。<br>讨论sorted set是如何在skiplist, dict和ziplist基础上构建起来的。<br>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><p>我们在讨论中会详细解释这两个配置的含义。</p><p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p><p>skiplist数据结构简介<br>skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p><p>我们在《Redis内部数据结构详解》系列的第一篇中介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。</p><p>这种数据结构是由William Pugh发明的，最早出现于他在1990年发表的论文《Skip Lists: A Probabilistic Alternative to Balanced Trees》。对细节感兴趣的同学可以下载论文原文来阅读。</p><p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p><p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/zHZ5VR.png" alt="有序链表结构图"></p><p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/7rzLC6.png" alt="每两个节点增加一个跳跃指针的有序链表"></p><p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/xyAmY4.png" alt="一个搜索路径的例子"></p><p>23首先和7比较，再和19比较，比它们都大，继续向后比较。<br>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。<br>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。<br>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/HCh3Ej.png" alt="两层跳跃指针"></p><p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p><p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/SGxB4f.png" alt="skiplist插入形成过程"></p><p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p><p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/RPidRP.png" alt="skiplist上的查找路径展示"></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p><p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p><p>但是，如果你是第一次接触skiplist，那么一定会产生一个疑问：节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？为了回答这个疑问，我们需要分析skiplist的统计性能。</p><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p><p>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。<br>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。<br>节点最大的层数不允许超过一个最大值，记为MaxLevel。<br>这个计算随机层数的伪码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">level := <span class="number">1</span></span><br><span class="line"><span class="comment">// random()返回一个[0...1)的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">random</span><span class="params">()</span> &lt; p and level &lt; MaxLevel <span class="keyword">do</span></span></span><br><span class="line"><span class="function">level :</span>= level + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">1</span>/<span class="number">4</span></span><br><span class="line">MaxLevel = <span class="number">32</span></span><br></pre></td></tr></table></figure><p>skiplist的算法性能分析<br>在这一部分，我们来简单分析一下skiplist的时间复杂度和空间复杂度，以便对于skiplist的性能有一个直观的了解。如果你不是特别偏执于算法的性能分析，那么可以暂时跳过这一小节的内容。</p><p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p><p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p><p>节点层数至少为1。而大于1的节点层数，满足一个概率分布。<br>节点层数恰好等于1的概率为1-p。<br>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。<br>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。<br>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。<br>……<br>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p><p>skiplist平均层数计算</p><p>现在很容易计算出：</p><p>当p=1/2时，每个节点所包含的平均指针数目为2；<br>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。<br>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p><p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p><p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p><p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p><p>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。<br>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。<br>这两种情形如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/SmOqP6.png" alt="skiplist沿查找路径回溯"></p><p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C(<span class="number">0</span>)=<span class="number">0</span></span><br><span class="line">C(k)=(<span class="number">1</span>-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)</span><br></pre></td></tr></table></figure><p>代入，得到一个差分方程并化简：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(k)=(<span class="number">1</span>-p)(C(k)+<span class="number">1</span>) + p(C(k-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">C(k)=<span class="number">1</span>/p+C(k-<span class="number">1</span>)</span><br><span class="line">C(k)=k/p</span><br></pre></td></tr></table></figure><p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p><p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p><p>第1层链表固定有n个节点；<br>第2层链表平均有n<em>p个节点；<br>第3层链表平均有n</em>p2个节点；<br>…<br>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p><p>综上，粗略来计算的话，平均查找长度约等于：</p><p>C(log1/pn-1)=(log1/pn-1)/p<br>即，平均时间复杂度为O(log n)。</p><p>当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。详情还请参见William Pugh的论文《Skip Lists: A Probabilistic Alternative to Balanced Trees》。</p><p>skiplist与平衡树、哈希表的比较<br>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。<br>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。<br>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。<br>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br>从算法实现难度上来比较，skiplist比平衡树要简单得多。<br>Redis中的skiplist实现<br>在这一部分，我们讨论Redis中的skiplist实现。</p><p>在Redis中，skiplist被用于实现暴露给外部的一个数据结构：sorted set。准确地说，sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict。这几个数据结构的关系，我们下一章再讨论。现在，我们先花点时间把sorted set的关键命令看一下。这些命令对于Redis里skiplist的实现，有重要的影响。</p><p>sorted set的命令举例<br>sorted set是一个有序的数据集合，对于像类似排行榜这样的应用场景特别适合。</p><p>现在我们来看一个例子，用sorted set来存储代数课（algebra）的成绩表。原始数据如下：</p><p>Alice 87.5<br>Bob 89.0<br>Charles 65.5<br>David 78.0<br>Emily 93.5<br>Fred 87.5<br>这份数据给出了每位同学的名字和分数。下面我们将这份数据存储到sorted set里面去：</p><p>sorted set命令举例</p><p>对于上面的这些命令，我们需要的注意的地方包括：</p><p>前面的6个zadd命令，将6位同学的名字和分数(score)都输入到一个key值为algebra的sorted set里面了。注意Alice和Fred的分数相同，都是87.5分。<br>zrevrank命令查询Alice的排名（命令中的rev表示按照倒序排列，也就是从大到小），返回3。排在Alice前面的分别是Emily、Bob、Fred，而排名(rank)从0开始计数，所以Alice的排名是3。注意，其实Alice和Fred的分数相同，这种情况下sorted set会把分数相同的元素，按照字典顺序来排列。按照倒序，Fred排在了Alice的前面。<br>zscore命令查询了Charles对应的分数。<br>zrevrange命令查询了从大到小排名为0~3的4位同学。<br>zrevrangebyscore命令查询了分数在80.0和90.0之间的所有同学，并按分数从大到小排列。<br>总结一下，sorted set中的每个元素主要表现出3个属性：</p><p>数据本身（在前面的例子中我们把名字存成了数据）。<br>每个数据对应一个分数(score)。<br>根据分数大小和数据本身的字典排序，每个数据会产生一个排名(rank)。可以按正序或倒序。<br>Redis中skiplist实现的特殊性<br>我们简单分析一下前面出现的几个查询命令：</p><p>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。<br>zscore由数据查询它对应的分数，这也不是skiplist所支持的。<br>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。<br>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。<br>实际上，Redis中sorted set的实现是这样的：</p><p>当数据较少时，sorted set是由一个ziplist来实现的。<br>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。<br>这里sorted set的构成我们在下一章还会再详细地讨论。现在我们集中精力来看一下sorted set与skiplist的关系，：</p><p>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。<br>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。<br>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。<br>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。<br>前述的查询过程，也暗示了各个操作的时间复杂度：</p><p>zscore只用查询一个dict，所以时间复杂度为O(1)<br>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以zrevrank的时间复杂度为O(log n)，而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。<br>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p><p>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。<br>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。<br>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。<br>在skiplist中可以很方便地计算出每个元素的排名(rank)。<br>skiplist的数据结构定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define ZSKIPLIST_MAXLEVEL <span class="number">32</span></span><br><span class="line">#define ZSKIPLIST_P <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">robj *obj;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line">struct zskiplistNode *backward;</span><br><span class="line">struct zskiplistLevel &#123;</span><br><span class="line">struct zskiplistNode *forward;</span><br><span class="line">unsigned <span class="keyword">int</span> span;</span><br><span class="line">&#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">struct zskiplistNode *header, *tail;</span><br><span class="line">unsigned <span class="keyword">long</span> length;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>这段代码出自server.h，我们来简要分析一下：</p><p>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。<br>zskiplistNode定义了skiplist的节点结构。<br>obj字段存放的是节点数据，它的类型是一个string robj。本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。有关robj的详情可以参见系列文章的第三篇：《Redis内部数据结构详解(3)——robj》。这样做的目的应该是为了方便在查找的时候对数据进行字典序的比较，而且，skiplist里的数据部分是数字的可能性也比较小。<br>score字段是数据对应的分数。<br>backward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。<br>level[]存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。需要注意的是，level[]是一个柔性数组（flexible array member），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。<br>zskiplist定义了真正的skiplist结构，它包含：<br>头指针header和尾指针tail。<br>链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中。<br>level表示skiplist的总层数，即所有节点层数的最大值。<br>下图以前面插入的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/rHPdAs.png" alt="Redis skiplist结构举例"></p><p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p><p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p><p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p><p>Redis中的sorted set<br>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p><p>当数据较少时，sorted set是由一个ziplist来实现的。<br>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。<br>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。在本系列前面关于ziplist的文章里，我们介绍过，ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p><p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p><p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p><p>还记得本文开头提到的两个Redis配置吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p><p>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。<br>当sorted set中插入的任意一个数据的长度超过了64的时候。<br>最后，zset结构的代码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">dict *dict;</span><br><span class="line">zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>Redis为什么用skiplist而不用平衡树？<br>在前面我们对于skiplist和平衡树、哈希表的比较中，其实已经不难看出Redis里使用skiplist而不用平衡树的原因了。现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are a few reasons:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With <span class="keyword">this</span> operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) They are simpler to implement, debug, and so forth. <span class="function">For instance thanks to the skip list simplicity I received a <span class="title">patch</span> <span class="params">(already in Redis master)</span> with augmented skip lists implementing ZRANK in <span class="title">O</span><span class="params">(log(N)</span>). It required little changes to the code.</span></span><br></pre></td></tr></table></figure><p>这段话原文出处：</p><p><a href="https://news.ycombinator.com/item?id=1171423">https://news.ycombinator.com/item?id=1171423</a></p><p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因，我们在前面其实也都涉及到了。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(2)——sds</title>
      <link href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(2)%E2%80%94%E2%80%94sds/"/>
      <url>/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(2)%E2%80%94%E2%80%94sds/</url>
      
        <content type="html"><![CDATA[<p>不管在哪门编程语言当中，字符串都几乎是使用最多的数据结构。sds正是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。与其它语言环境中出现的字符串相比，它具有如下显著的特点：</p><p>可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。<br>二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。<br>与传统的C语言字符串类型兼容。这个的含义接下来马上会讨论。<br>看到这里，很多对Redis有所了解的同学可能已经产生了一个疑问：Redis已经对外暴露了一个字符串结构，叫做string，那这里所说的sds到底和string是什么关系呢？可能有人会猜：string是基于sds实现的。这个猜想已经非常接近事实，但在描述上还不太准确。有关string和sds之间关系的详细分析，我们放在后面再讲。现在为了方便讨论，让我们先暂时简单地认为，string的底层实现就是sds。</p><p>在讨论sds的具体实现之前，我们先站在Redis使用者的角度，来观察一下string所支持的一些主要操作。下面是一个操作示例：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/30/FSls4k.png" alt="Redis string操作示例"></p><p>以上这些操作都比较简单，我们简单解释一下：</p><p>初始的字符串的值设为”tielei”。<br>第3步通过append命令对字符串进行了追加，变成了”tielei zhang”。<br>然后通过setbit命令将第53个bit设置成了1。bit的偏移量从左边开始算，从0开始。其中第48～55bit是中间的空格那个字符，它的ASCII码是0x20。将第53个bit设置成1之后，它的ASCII码变成了0x24，打印出来就是’$’。因此，现在字符串的值变成了”tielei$zhang”。<br>最后通过getrange取从倒数第5个字节到倒数第1个字节的内容，得到”zhang”。<br>这些命令的实现，有一部分是和sds的实现有关的。下面我们开始详细讨论。</p><p>sds的数据结构定义<br>我们知道，在C语言中，字符串是以’\0’字符结尾（NULL结束符）的字符数组来存储的，通常表达为字符指针的形式（char *）。它不允许字节0出现在字符串中间，因此，它不能用来存储任意的二进制数据。</p><p>我们可以在sds.h中找到sds的类型定义：</p><p>typedef char *sds;<br>肯定有人感到困惑了，竟然sds就等同于char *？我们前面提到过，sds和传统的C语言字符串保持类型兼容，因此它们的类型定义是一样的，都是char *。在有些情况下，需要传入一个C语言字符串的地方，也确实可以传入一个sds。但是，sds和char *并不等同。sds是Binary Safe的，它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。但这个长度字段在哪里呢？实际上sds还包含一个header结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr5 </span>&#123;</span><br><span class="line">unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr8 </span>&#123;</span><br><span class="line">uint8_t len; <span class="comment">/* used */</span></span><br><span class="line">uint8_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr16 </span>&#123;</span><br><span class="line">uint16_t len; <span class="comment">/* used */</span></span><br><span class="line">uint16_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr32 </span>&#123;</span><br><span class="line">uint32_t len; <span class="comment">/* used */</span></span><br><span class="line">uint32_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr64 </span>&#123;</span><br><span class="line">uint64_t len; <span class="comment">/* used */</span></span><br><span class="line">uint64_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">unsigned <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sds一共有5种类型的header。之所以有5种，是为了能让不同长度的字符串可以使用不同大小的header。这样，短字符串就能使用较小的header，从而节省内存。</p><p>一个sds字符串的完整结构，由在内存地址上前后相邻的两部分组成：</p><p>一个header。通常包含字符串的长度(len)、最大容量(alloc)和flags。sdshdr5有所不同。<br>一个字符数组。这个字符数组的长度等于最大容量+1。真正有效的字符串数据，其长度通常小于最大容量。在真正的字符串数据之后，是空余未用的字节（一般以字节0填充），允许在不重新分配内存的前提下让字符串数据向后做有限的扩展。在真正的字符串数据之后，还有一个NULL结束符，即ASCII码为0的’\0’字符。这是为了和传统C字符串兼容。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符。<br>除了sdshdr5之外，其它4个header的结构都包含3个字段：</p><p>len: 表示字符串的真正长度（不包含NULL结束符在内）。<br>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。<br>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。<br>#define SDS_TYPE_5  0<br>#define SDS_TYPE_8  1<br>#define SDS_TYPE_16 2<br>#define SDS_TYPE_32 3<br>#define SDS_TYPE_64 4<br>sds的数据结构，我们有必要非常仔细地去解析它。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/30/b74Qv8.png" alt="Redis dict结构举例"></p><p>上图是sds的一个内部结构的例子。图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdshdr16类型的header。但它们都表达了同样的一个长度为6的字符串的值：”tielei”。下面我们结合代码，来解释每一部分的组成。</p><p>sds的字符指针（s1和s2）就是指向真正的数据（字符数组）开始的位置，而header位于内存地址较低的方向。在sds.h中有一些跟解析header有关的宏定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define SDS_TYPE_MASK <span class="number">7</span></span><br><span class="line">#define SDS_TYPE_BITS <span class="number">3</span></span><br><span class="line">#<span class="function">define <span class="title">SDS_HDR_VAR</span><span class="params">(T,s)</span> struct sdshdr##T *sh </span>= (<span class="keyword">void</span>*)((s)-(sizeof(struct sdshdr##T)));</span><br><span class="line">#<span class="function">define <span class="title">SDS_HDR</span><span class="params">(T,s)</span> <span class="params">((struct sdshdr##T *)</span><span class="params">((s)</span>-<span class="params">(sizeof(struct sdshdr##T)</span>)))</span></span><br><span class="line"><span class="function">#define <span class="title">SDS_TYPE_5_LEN</span><span class="params">(f)</span> <span class="params">((f)</span>&gt;&gt;SDS_TYPE_BITS)</span></span><br></pre></td></tr></table></figure><p>其中SDS_HDR用来从sds字符串获得header起始位置的指针，比如SDS_HDR(8, s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。</p><p>当然，使用SDS_HDR之前我们必须先知道到底是哪一种header，这样我们才知道SDS_HDR第1个参数应该传什么。由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段。比如，s1[-1]和s2[-1]分别获得了s1和s2的flags的值。然后取flags的最低3个bit得到header的类型。</p><p>由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。<br>由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。<br>有了header指针，就能很快定位到它的len和alloc字段：</p><p>s1的header中，len的值为0x06，表示字符串数据长度为6；alloc的值为0x80，表示字符数组最大容量为128。<br>s2的header中，len的值为0x0006，表示字符串数据长度为6；alloc的值为0x03E8，表示字符数组最大容量为1000。（注意：图中是按小端地址构成）<br>在各个header的类型定义中，还有几个需要我们注意的地方：</p><p>在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。<br>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（flexible array member），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。<br>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。<br>至此，我们非常清楚地看到了：sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处：</p><p>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。<br>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<br>弄清了sds的数据结构，它的具体操作函数就比较好理解了。</p><p>sds的一些基础函数<br>sdslen(const sds s): 获取sds字符串长度。<br>sdssetlen(sds s, size_t newlen): 设置sds字符串长度。<br>sdsinclen(sds s, size_t inc): 增加sds字符串长度。<br>sdsalloc(const sds s): 获取sds字符串容量。<br>sdssetalloc(sds s, size_t newlen): 设置sds字符串容量。<br>sdsavail(const sds s): 获取sds字符串空余空间（即alloc - len）。<br>sdsHdrSize(char type): 根据header类型得到header大小。<br>sdsReqType(size_t string_size): 根据字符串数据长度计算所需要的header类型。<br>这里我们挑选sdslen和sdsReqType的代码，察看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> inline size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">unsigned <span class="keyword">char</span> flags = s[-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line"><span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line"><span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line"><span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line"><span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line"><span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line"><span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line"><span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line"><span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line"><span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> inline <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(size_t string_size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line"><span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line"><span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="keyword">if</span> (string_size &lt; 1ll&lt;&lt;<span class="number">32</span>)</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟前面的分析类似，sdslen先用s[-1]向低地址方向偏移1个字节，得到flags；然后与SDS_TYPE_MASK进行按位与，得到header类型；然后根据不同的header类型，调用SDS_HDR得到header起始指针，进而获得len字段。</p><p>通过sdsReqType的代码，很容易看到：</p><p>长度在0和2^5-1之间，选用SDS_TYPE_5类型的header。<br>长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header。<br>长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header。<br>长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header。<br>长度大于2^32的，选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1。<br>注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到最近3.2 branch上的commit 6032340才修复。</p><p>sds的创建和销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, size_t initlen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *sh;</span><br><span class="line">sds s;</span><br><span class="line"><span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line"><span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">* since type 5 is not good at this. */</span></span><br><span class="line"><span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line"><span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">unsigned <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        memset(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((unsigned <span class="keyword">char</span>*)s)-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        memcpy(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">size_t initlen = (init == NULL) ? <span class="number">0</span> : strlen(init);</span><br><span class="line"><span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == NULL) <span class="keyword">return</span>;</span><br><span class="line">s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[-<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sdsnewlen创建一个长度为initlen的sds字符串，并使用init指向的字符数组（任意二进制数据）来初始化数据。如果init为NULL，那么使用全0来初始化数据。它的实现中，我们需要注意的是：</p><p>如果要创建一个长度为0的空字符串，那么不使用SDS_TYPE_5类型的header，而是转而使用SDS_TYPE_8类型的header。这是因为创建的空字符串一般接下来的操作很可能是追加数据，但SDS_TYPE_5类型的sds字符串不适合追加数据（会引发内存重新分配）。<br>需要的内存空间一次性进行分配，其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）。<br>初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\0’）。<br>关于sdsfree，需要注意的是：内存要整体释放，所以要先计算出header起始指针，把它传给s_free函数。这个指针也正是在sdsnewlen中调用s_malloc返回的那个地址。</p><p>sds的连接（追加）操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, size_t len)</span> </span>&#123;</span><br><span class="line">size_t curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    memcpy(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sdscatlen(s, t, strlen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, size_t addlen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">size_t avail = sdsavail(s);</span><br><span class="line">size_t len, newlen;</span><br><span class="line"><span class="keyword">char</span> type, oldtype = s[-<span class="number">1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line"><span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    </span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    </span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line">    </span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        memcpy((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[-<span class="number">1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sdscatlen将t指向的长度为len的任意二进制数据追加到sds字符串s的后面。本文开头演示的string的append命令，内部就是调用sdscatlen来实现的。</p><p>在sdscatlen的实现中，先调用sdsMakeRoomFor来保证字符串s有足够的空间来追加长度为len的数据。sdsMakeRoomFor可能会分配新的内存，也可能不会。</p><p>sdsMakeRoomFor是sds实现中很重要的一个函数。关于它的实现代码，我们需要注意的是：</p><p>如果原来字符串中的空余空间够用（avail &gt;= addlen），那么它什么也不做，直接返回。<br>如果需要分配空间，它会比实际请求的要多分配一些，以防备接下来继续追加。它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。<br>按分配后的空间大小，可能需要更换header类型（原来header的alloc字段太短，表达不了增加后的容量）。<br>如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置。<br>如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间。s_realloc的具体实现得看Redis编译的时候选用了哪个allocator（在Linux上默认使用jemalloc）。但不管是哪个realloc的实现，它所表达的含义基本是相同的：它尽量在原来分配好的地址位置重新分配，如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁。参见<a href="http://man.cx/realloc%E3%80%82">http://man.cx/realloc。</a><br>从sdscatlen的函数接口，我们可以看到一种使用模式：调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。</p><p>浅谈sds与string的关系<br>现在我们回过头来看看本文开头给出的string操作的例子。</p><p>append操作使用sds的sdscatlen来实现。前面已经提到。<br>setbit和getrange都是先根据key取到整个sds字符串，然后再从字符串选取或修改指定的部分。由于sds就是一个字符数组，所以对它的某一部分进行操作似乎都比较简单。<br>但是，string除了支持这些操作之外，当它存储的值是个数字的时候，它还支持incr、decr等操作。那么，当string存储数字值的时候，它的内部存储还是sds吗？实际上，不是了。而且，这种情况下，setbit和getrange的实现也会有所不同。这些细节，我们放在下一篇介绍robj的时候再进行系统地讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(3)——robj</title>
      <link href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(3)%E2%80%94%E2%80%94robj/"/>
      <url>/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(3)%E2%80%94%E2%80%94robj/</url>
      
        <content type="html"><![CDATA[<p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash等。我们可以看到，key的类型固定是string，而value可能的类型是多个。</p><p>而从Redis内部实现的角度来看，在前面第一篇文章中，我们已经提到过，一个database内的这个映射关系是用一个dict来维护的。dict的key固定用一种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是robj（全名是redisObject）。举个例子：如果value是一个list，那么它的内部存储结构是一个quicklist（quicklist的具体实现我们放在后面的文章讨论）；如果value是一个string，那么它的内部存储结构一般情况下是一个sds。当然实际情况更复杂一点，比如一个string类型的value，如果它的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。而一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p><p>robj的数据结构定义<br>在server.h中我们找到跟robj定义相关的代码，如下（注意，本系列文章中的代码片段全部来源于Redis源码的3.2分支）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line">#define OBJ_STRING <span class="number">0</span></span><br><span class="line">#define OBJ_LIST <span class="number">1</span></span><br><span class="line">#define OBJ_SET <span class="number">2</span></span><br><span class="line">#define OBJ_ZSET <span class="number">3</span></span><br><span class="line">#define OBJ_HASH <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment">* internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment">* is set to one of this fields for this object. */</span></span><br><span class="line">  #define OBJ_ENCODING_RAW <span class="number">0</span>     <span class="comment">/* Raw representation */</span></span><br><span class="line">  #define OBJ_ENCODING_INT <span class="number">1</span>     <span class="comment">/* Encoded as integer */</span></span><br><span class="line">  #define OBJ_ENCODING_HT <span class="number">2</span>      <span class="comment">/* Encoded as hash table */</span></span><br><span class="line">  #define OBJ_ENCODING_ZIPMAP <span class="number">3</span>  <span class="comment">/* Encoded as zipmap */</span></span><br><span class="line">  #define OBJ_ENCODING_LINKEDLIST <span class="number">4</span> <span class="comment">/* Encoded as regular linked list */</span></span><br><span class="line">  #define OBJ_ENCODING_ZIPLIST <span class="number">5</span> <span class="comment">/* Encoded as ziplist */</span></span><br><span class="line">  #define OBJ_ENCODING_INTSET <span class="number">6</span>  <span class="comment">/* Encoded as intset */</span></span><br><span class="line">  #define OBJ_ENCODING_SKIPLIST <span class="number">7</span>  <span class="comment">/* Encoded as skiplist */</span></span><br><span class="line">  #define OBJ_ENCODING_EMBSTR <span class="number">8</span>  <span class="comment">/* Embedded sds string encoding */</span></span><br><span class="line">  #define OBJ_ENCODING_QUICKLIST <span class="number">9</span> <span class="comment">/* Encoded as linked list of ziplists */</span></span><br><span class="line"></span><br><span class="line">#define LRU_BITS <span class="number">24</span></span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">unsigned type:<span class="number">4</span>;</span><br><span class="line">unsigned encoding:<span class="number">4</span>;</span><br><span class="line">unsigned lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"><span class="keyword">int</span> refcount;</span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>一个robj包含如下5个字段：</p><p>type: 对象的数据类型。占4个bit。可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构（即我们在第一篇文章中提到的第一个层面的5种数据结构）。<br>encoding: 对象的内部表示方式（也可以称为编码）。占4个bit。可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。<br>lru: 做LRU替换算法用，占24个bit。这个不是我们这里讨论的重点，暂时忽略。<br>refcount: 引用计数。它允许robj对象在某些情况下被共享。<br>ptr: 数据指针。指向真正的数据。比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist。<br>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><p>比如，当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><p>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。<br>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。<br>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。接下来我们会讨论到这个细节。<br>再举一个例子：当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p><p>OBJ_ENCODING_HT: hash采用一个dict来表示。<br>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示（ziplist的具体实现我们放在后面的文章讨论）。<br>本文剩余主要部分将针对表示string的robj对象，围绕它的3种不同的encoding来深入讨论。前面代码段中出现的所有10种encoding，在这里我们先简单解释一下，在这个系列后面的文章中，我们应该还有机会碰到它们。</p><p>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。<br>OBJ_ENCODING_INT: 表示成数字。实际用long表示。<br>OBJ_ENCODING_HT: 表示成dict。<br>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。<br>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。<br>OBJ_ENCODING_ZIPLIST: 表示成ziplist。<br>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。<br>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。<br>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。<br>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。<br>我们来总结一下robj的作用：</p><p>为多种数据类型提供一种统一的表示方式。<br>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。<br>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。<br>string robj的编码过程<br>当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。这一过程的核心代码，是object.c中的tryObjectEncoding函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">robj *tryObjectEncoding(robj *o) &#123;</span><br><span class="line"><span class="keyword">long</span> value;</span><br><span class="line">sds s = o-&gt;ptr;</span><br><span class="line">size_t len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure this is a string object, the only type we encode</span></span><br><span class="line"><span class="comment">     * in this function. Other types use encoded memory efficient</span></span><br><span class="line"><span class="comment">     * representations but are handled by the commands implementing</span></span><br><span class="line"><span class="comment">     * the type. */</span></span><br><span class="line">    serverAssertWithInfo(NULL,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try some specialized encoding only for objects that are</span></span><br><span class="line"><span class="comment">     * RAW or EMBSTR encoded, in other words objects that are still</span></span><br><span class="line"><span class="comment">     * in represented by an actually array of chars. */</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It&#x27;s not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</span></span><br><span class="line"><span class="comment">     * they are not handled. We handle them only as values in the keyspace. */</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 21 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">21</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &amp;&amp;</span><br><span class="line">              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);</span><br><span class="line">            o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the string is small and is still RAW encoded,</span></span><br><span class="line"><span class="comment">     * try the EMBSTR encoding which is more efficient.</span></span><br><span class="line"><span class="comment">     * In this representation the object and the SDS string are allocated</span></span><br><span class="line"><span class="comment">     * in the same chunk of memory to save space and cache misses. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o;</span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s));</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can&#x27;t encode the object...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do the last try, and at least optimize the SDS string inside</span></span><br><span class="line"><span class="comment">     * the string object to require little space, in case there</span></span><br><span class="line"><span class="comment">     * is more than 10% of free space at the end of the SDS string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We do that only for relatively large strings as this branch</span></span><br><span class="line"><span class="comment">     * is only entered if the length of the string is greater than</span></span><br><span class="line"><span class="comment">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW &amp;&amp;</span><br><span class="line">        sdsavail(s) &gt; len/<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        o-&gt;ptr = sdsRemoveFreeSpace(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the original object. */</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行的操作比较复杂，我们有必要仔细看一下每一步的操作：</p><p>第1步检查，检查type。确保只对string类型的对象进行操作。<br>第2步检查，检查encoding。sdsEncodedObject是定义在server.h中的一个宏，确保只对OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR编码的string对象进行操作。这两种编码的string都采用sds来存储，可以尝试进一步编码处理。<br>#define sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)<br>第3步检查，检查refcount。引用计数大于1的共享对象，在多处被引用。由于编码过程结束后robj的对象指针可能会变化（我们在前一篇介绍sdscatlen函数的时候提到过类似这种接口使用模式），这样对于引用计数大于1的对象，就需要更新所有地方的引用，这不容易做到。因此，对于计数大于1的对象不做编码处理。<br>试图将字符串转成64位的long。64位的long所能表达的数据范围是-2^63到2^63-1，用十进制表达出来最长是20位数（包括负号）。这里判断小于等于21，似乎是写多了，实际判断小于等于20就够了（如果我算错了请一定告诉我哦）。string2l如果将字符串转成long转成功了，那么会返回1并且将转好的long存到value变量里。<br>在转成long成功时，又分为两种情况。<br>第一种情况：如果Redis的配置不要求运行LRU替换算法，且转成的long型数字的值又比较小（小于OBJ_SHARED_INTEGERS，在目前的实现中这个值是10000），那么会使用共享数字对象来表示。之所以这里的判断跟LRU有关，是因为LRU算法要求每个robj有不同的lru字段值，所以用了LRU就不能共享robj。shared.integers是一个长度为10000的数组，里面预存了10000个小的数字对象。这些小数字对象都是encoding = OBJ_ENCODING_INT的string robj对象。<br>第二种情况：如果前一步不能使用共享小对象来表示，那么将原来的robj编码成encoding = OBJ_ENCODING_INT，这时ptr字段直接存成这个long型的值。注意ptr字段本来是一个void *指针（即存储的是内存地址），因此在64位机器上有64位宽度，正好能存储一个64位的long型值。这样，除了robj本身之外，它就不再需要额外的内存空间来存储字符串值。<br>接下来是对于那些不能转成64位long的字符串进行处理。最后再做两步处理：<br>如果字符串长度足够小（小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT，定义为44），那么调用createEmbeddedStringObject编码成encoding = OBJ_ENCODING_EMBSTR；<br>如果前面所有的编码尝试都没有成功（仍然是OBJ_ENCODING_RAW），且sds里空余字节过多，那么做最后一次努力，调用sds的sdsRemoveFreeSpace接口来释放空余字节。<br>其中调用的createEmbeddedStringObject，我们有必要看一下它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">robj *createEmbeddedStringObject(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, size_t len) &#123;</span><br><span class="line">robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">struct sdshdr8 *sh = (<span class="keyword">void</span>*)(o+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        memcpy(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memset(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createEmbeddedStringObject对sds重新分配内存，将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片。这个连续的内存块包含如下几部分：</p><p>16个字节的robj结构。<br>3个字节的sdshdr8头。<br>最多44个字节的sds字符数组。<br>1个NULL结束符。<br>加起来一共不超过64字节（16+3+44+1），因此这样的一个短字符串可以完全分配在一个64字节长度的内存块中。</p><p>string robj的解码过程<br>当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。</p><p>这一解码过程的核心代码，是object.c中的getDecodedObject函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">robj *getDecodedObject(robj *o) &#123;</span><br><span class="line">robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,strlen(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown encoding type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程比较简单，需要我们注意的点有：</p><p>编码为OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR的字符串robj对象，不做变化，原封不动返回。站在使用者的角度，这两种编码没有什么区别，内部都是封装的sds。<br>编码为数字的字符串robj对象，将long重新转为十进制字符串的形式，然后调用createStringObject转为sds的表示。注意：这里由long转成的sds字符串长度肯定不超过20，而根据createStringObject的实现，它们肯定会被编码成OBJ_ENCODING_EMBSTR的对象。createStringObject的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robj *createStringObject(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, size_t len) &#123;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line"><span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再谈sds与string的关系<br>在上一篇文章中，我们简单地提到了sds与string的关系；在本文介绍了robj的概念之后，我们重新总结一下sds与string的关系。</p><p>确切地说，string在Redis中是用一个robj来表示的。<br>用来表示string的robj可能编码成3种内部表示：OBJ_ENCODING_RAW, OBJ_ENCODING_EMBSTR, OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把string存成了long型。<br>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。<br>对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。而如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执行setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。由于篇幅原因，这三个命令的实现代码这里就不详细介绍了，有兴趣的读者可以参考Redis源码：<br>t_string.c中的appendCommand函数；<br>biops.c中的setbitCommand函数；<br>t_string.c中的getrangeCommand函数。<br>值得一提的是，append和setbit命令的实现中，都会最终调用到db.c中的dbUnshareStringValue函数，将string对象的内部编码转成OBJ_ENCODING_RAW的（只有这种编码的robj对象，其内部的sds 才能在后面自由追加新的内容），并解除可能存在的对象共享状态。这里面调用了前面提到的getDecodedObject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) &#123;</span><br><span class="line">serverAssert(o-&gt;type == OBJ_STRING);</span><br><span class="line"><span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != OBJ_ENCODING_RAW) &#123;</span><br><span class="line">robj *decoded = getDecodedObject(o);</span><br><span class="line">o = createRawStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">decrRefCount(decoded);</span><br><span class="line">dbOverwrite(db,key,o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>robj的引用计数操作<br>将robj的引用计数加1和减1的操作，定义在object.c中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">&quot;decrRefCount against refcount &lt;= 0&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: serverPanic(<span class="string">&quot;Unknown object type&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">zfree(o);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">o-&gt;refcount--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们特别关注一下将引用计数减1的操作decrRefCount。如果只剩下最后一个引用了（refcount已经是1了），那么在decrRefCount被调用后，整个robj将被释放。</p><p>注意：Redis的del命令就依赖decrRefCount操作将value释放掉。</p><p>经过了本文的讨论，我们很容易看出，robj所表示的就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪个（或哪些）第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist, 等），则通过不同的encoding来区分。可以说，robj是联结两个层面的数据结构的桥梁。</p><p>本文详细介绍了OBJ_STRING类型的字符串对象的底层实现，其编码和解码过程在Redis里非常重要，应用广泛，我们在后面的讨论中可能还会遇到。现在有了robj的概念基础，我们下一篇会讨论ziplist，以及它与hash的关系。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(5)——quicklist</title>
      <link href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(5)%E2%80%94%E2%80%94quicklist/"/>
      <url>/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(5)%E2%80%94%E2%80%94quicklist/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们介绍一个Redis内部数据结构——quicklist。Redis对外暴露的list数据类型，它底层实现所依赖的内部数据结构就是quicklist。</p><p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size -<span class="number">2</span></span><br><span class="line">list-compress-depth <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们在讨论中会详细解释这两个配置的含义。</p><p>注：本文讨论的quicklist实现基于Redis源码的3.2分支。</p><p>quicklist概述<br>Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：</p><p>lpush: 在左侧（即列表头部）插入数据。<br>rpop: 在右侧（即列表尾部）删除数据。<br>rpush: 在右侧（即列表尾部）插入数据。<br>lpop: 在左侧（即列表头部）删除数据。<br>这些操作都是O(1)时间复杂度的。</p><p>当然，list也支持在任意中间位置的存取操作，比如lindex和linsert，但它们都需要对list进行遍历，所以时间复杂度较高，为O(N)。</p><p>概况起来，list具有这样的一些特点：它是一个能维持数据项先后顺序的列表（各个数据项的先后顺序由插入位置决定），便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。这不正是一个双向链表所具有的特点吗？</p><p>list的内部实现quicklist正是一个双向链表。在quicklist.c的文件头部注释中，是这样描述quicklist的：</p><p>A doubly linked list of ziplists</p><p>它确实是一个双向链表，而且是一个ziplist的双向链表。</p><p>这是什么意思呢？</p><p>我们知道，双向链表是由多个节点（Node）组成的。这个描述的意思是：quicklist的每个节点都是一个ziplist。ziplist我们已经在上一篇介绍过。</p><p>ziplist本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。</p><p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p><p>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。<br>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。<br>于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。</p><p>不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</p><p>这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：</p><p>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。<br>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。<br>可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数list-max-ziplist-size，就是为了让使用者可以来根据自己的情况进行调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size -<span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。</p><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p><p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><p>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）<br>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。<br>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。<br>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）<br>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。<br>另外，list的设计目标是能够用来存储很长的数据列表的。比如，Redis官网给出的这个教程：Writing a simple Twitter clone with PHP and Redis，就是使用list来存储类似Twitter的timeline数据。</p><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-compress-depth <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p><p>参数list-compress-depth的取值含义如下：</p><p>0: 是个特殊值，表示都不压缩。这是Redis的默认值。<br>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。<br>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。<br>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。<br>依此类推…<br>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>Redis对于quicklist内部节点的压缩算法，采用的LZF——一种无损压缩算法。</p><p>quicklist的数据结构定义<br>quicklist相关的数据结构定义可以在quicklist.h中找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklistNode &#123;</span><br><span class="line">struct quicklistNode *prev;</span><br><span class="line">struct quicklistNode *next;</span><br><span class="line">unsigned <span class="keyword">char</span> *zl;</span><br><span class="line">unsigned <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">unsigned <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">unsigned <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">unsigned <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">unsigned <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">unsigned <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">unsigned <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line">typedef struct quicklistLZF &#123;</span><br><span class="line">unsigned <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line"><span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line">typedef struct quicklist &#123;</span><br><span class="line">quicklistNode *head;</span><br><span class="line">quicklistNode *tail;</span><br><span class="line">unsigned <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">unsigned <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line"><span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">unsigned <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>quicklistNode结构代表quicklist的一个节点，其中各个字段的含义如下：</p><p>prev: 指向链表前一个节点的指针。<br>next: 指向链表后一个节点的指针。<br>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。<br>sz: 表示zl指向的ziplist的总大小（包括zlbytes, zltail, zllen, zlend和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。<br>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。<br>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。<br>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。<br>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。<br>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。<br>extra: 其它扩展字段。目前Redis的实现里也没用上。<br>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p><p>sz: 表示压缩后的ziplist大小。<br>compressed: 是个柔性数组（flexible array member），存放压缩后的ziplist字节数组。<br>真正表示quicklist的数据结构是同名的quicklist这个struct：</p><p>head: 指向头节点（左侧第一个节点）的指针。<br>tail: 指向尾节点（右侧第一个节点）的指针。<br>count: 所有ziplist数据项的个数总和。<br>len: quicklist节点的个数。<br>fill: 16bit，ziplist大小设置，存放list-max-ziplist-size参数的值。<br>compress: 16bit，节点压缩深度设置，存放list-compress-depth参数的值。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/30/n9nwJJ.png" alt="Redis quicklist 结构图"></p><p>上图是一个quicklist的结构图举例。图中例子对应的ziplist大小配置和节点压缩深度配置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size <span class="number">3</span></span><br><span class="line">list-compress-depth <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这个例子中我们需要注意的几点是：</p><p>两端各有2个橙黄色的节点，是没有被压缩的。它们的数据指针zl指向真正的ziplist。中间的其它节点是被压缩过的，它们的数据指针zl指向被压缩后的ziplist结构，即一个quicklistLZF结构。<br>左侧头节点上的ziplist里有2项数据，右侧尾节点上的ziplist里有1项数据，中间其它节点上的ziplist里都有3项数据（包括压缩的节点内部）。这表示在表的两端执行过多次push和pop操作后的一个状态。<br>现在我们来大概计算一下quicklistNode结构中的count字段这16bit是否够用。</p><p>我们已经知道，ziplist大小受到list-max-ziplist-size参数的限制。按照正值和负值有两种情况：</p><p>当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。<br>当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。<br>实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。</p><p>下面进入代码分析阶段。</p><p>quicklist的创建<br>当我们使用lpush或rpush命令第一次向一个不存在的list里面插入数据的时候，Redis会首先调用quicklistCreate接口创建一个空的quicklist。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">quicklist *quicklistCreate(<span class="keyword">void</span>) &#123;</span><br><span class="line">struct quicklist *quicklist;</span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(sizeof(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = NULL;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;fill = -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在很多介绍数据结构的书上，实现双向链表的时候经常会多增加一个空余的头节点，主要是为了插入和删除操作的方便。从上面quicklistCreate的代码可以看出，quicklist是一个不包含空余头节点的双向链表（head和tail都初始化为NULL）。</p><p>quicklist的push操作<br>quicklist的push操作是调用quicklistPush来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistPush</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">const</span> size_t sz,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">quicklistPushHead(quicklist, value, sz);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">quicklistPushTail(quicklist, value, sz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add new entry to head node of quicklist.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Returns 0 if used existing head.</span></span><br><span class="line"><span class="comment">* Returns 1 if new head created. */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, size_t sz)</span> </span>&#123;</span><br><span class="line">  quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">  <span class="keyword">if</span> (likely(</span><br><span class="line">  _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">  quicklist-&gt;head-&gt;zl =</span><br><span class="line">  ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">  quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  quicklistNode *node = quicklistCreateNode();</span><br><span class="line">  node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">       quicklistNodeUpdateSz(node);</span><br><span class="line">       _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">  &#125;</span><br><span class="line">  quicklist-&gt;count++;</span><br><span class="line">  quicklist-&gt;head-&gt;count++;</span><br><span class="line">  <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add new entry to tail node of quicklist.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Returns 0 if used existing tail.</span></span><br><span class="line"><span class="comment">* Returns 1 if new tail created. */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, size_t sz)</span> </span>&#123;</span><br><span class="line">  quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">  <span class="keyword">if</span> (likely(</span><br><span class="line">  _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">  quicklist-&gt;tail-&gt;zl =</span><br><span class="line">  ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">  quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  quicklistNode *node = quicklistCreateNode();</span><br><span class="line">  node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">       quicklistNodeUpdateSz(node);</span><br><span class="line">       _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">  &#125;</span><br><span class="line">  quicklist-&gt;count++;</span><br><span class="line">  quicklist-&gt;tail-&gt;count++;</span><br><span class="line">  <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  不管是在头部还是尾部插入数据，都包含两种情况：</p><p>如果头节点（或尾节点）上ziplist大小没有超过限制（即_quicklistNodeAllowInsert返回1），那么新数据被直接插入到ziplist中（调用ziplistPush）。<br>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用_quicklistInsertNodeAfter）。<br>在_quicklistInsertNodeAfter的实现中，还会根据list-compress-depth的配置将里面的节点进行压缩。它的实现比较繁琐，我们这里就不展开讨论了。</p><p>quicklist的其它操作<br>quicklist的操作较多，且实现细节都比较繁杂，这里就不一一分析源码了，我们简单介绍一些比较重要的操作。</p><p>quicklist的pop操作是调用quicklistPopCustom来实现的。quicklistPopCustom的实现过程基本上跟quicklistPush相反，先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。删除后还可能涉及到里面节点的解压缩问题。</p><p>quicklist不仅实现了从头部或尾部插入，也实现了从任意指定的位置插入。quicklistInsertAfter和quicklistInsertBefore就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，情况比较复杂，有众多的逻辑分支。</p><p>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；<br>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；<br>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。<br>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。<br>quicklistSetOptions用于设置ziplist大小配置参数（list-max-ziplist-size）和节点压缩深度配置参数（list-compress-depth）。代码比较简单，就是将相应的值分别设置给quicklist结构的fill字段和compress字段。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(4)——ziplist</title>
      <link href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(4)%E2%80%94%E2%80%94ziplist/"/>
      <url>/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(4)%E2%80%94%E2%80%94ziplist/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们首先介绍一个新的Redis内部数据结构——ziplist，然后在文章后半部分我们会讨论一下在robj, dict和ziplist的基础上，Redis对外暴露的hash结构是怎样构建起来的。</p><p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><p>本文的后半部分会对这两个配置做详细的解释。</p><p>什么是ziplist<br>Redis官方对于ziplist的定义是（出自ziplist.c的文件头部注释）：</p><p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time.</p><p>翻译一下就是说：ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p><p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。我们接下来很快就会讨论到这些实现细节。</p><p>ziplist的数据结构定义<br>ziplist的数据结构组成是本文要讨论的重点。实际上，ziplist还是稍微有点复杂的，它复杂的地方就在于它的数据结构定义。一旦理解了数据结构，它的一些操作也就比较容易理解了。</p><p>我们接下来先从总体上介绍一下ziplist的数据结构定义，然后举一个实际的例子，通过例子来解释ziplist的构成。如果你看懂了这一部分，本文的任务就算完成了一大半了。</p><p>从宏观上看，ziplist的内存结构如下：</p><p><zlbytes><zltail><zllen><entry>…<entry><zlend></p><p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p><p><zlbytes>: 32bit，表示ziplist占用的字节总数（也包括<zlbytes>本身占用的4个字节）。<br><zltail>: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<zltail>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。<br><zllen>: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2^16-1。这里需要特别注意的是，如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果<zllen>小于等于2^16-2（也就是不等于2^16-1），那么<zllen>就表示ziplist中数据项的个数；否则，也就是<zllen>等于16bit全为1的情况，那么<zllen>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。<br><entry>: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。<br><zlend>: ziplist最后1个字节，是一个结束标记，值固定等于255。<br>上面的定义中还值得注意的一点是：<zlbytes>, <zltail>, <zllen>既然占据多个字节，那么在存储的时候就有大端（big endian）和小端（little endian）的区别。ziplist采取的是小端模式来存储，这在下面我们介绍具体例子的时候还会再详细解释。</p><p>我们再来看一下每一个数据项<entry>的构成：</p><p><prevrawlen><len><data></p><p>我们看到在真正的数据（<data>）前面，还有两个字段：</p><p><prevrawlen>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。<br><len>: 表示当前数据项的数据长度（即<data>部分的长度）。也采用变长编码。<br>那么<prevrawlen>和<len>是怎么进行变长编码的呢？各位读者打起精神了，我们终于讲到了ziplist的定义中最繁琐的地方了。</p><p>先说<prevrawlen>。它有两种可能，或者是1个字节，或者是5个字节：</p><p>如果前一个数据项占用字节数小于254，那么<prevrawlen>就只用一个字节来表示，这个字节的值就是前一个数据项的占用字节数。<br>如果前一个数据项占用字节数大于等于254，那么<prevrawlen>就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数。<br>有人会问了，为什么没有255的情况呢？</p><p>这是因为：255已经定义为ziplist结束标记<zlend>的值了。在ziplist的很多操作的实现中，都会根据数据项的第1个字节是不是255来判断当前是不是到达ziplist的结尾了，因此一个正常的数据的第1个字节（也就是<prevrawlen>的第1个字节）是不能够取255这个值的，否则就冲突了。</p><p>而<len>字段就更加复杂了，它根据第1个字节的不同，总共分为9种情况（下面的表示法是按二进制表示）：</p><p>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<len>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。<br>|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<len>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。<br>|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，<data>都是按字符串来存储的；从下面第4种情况开始，<data>开始变为按整数来存储了。<br>|11000000| - 1 byte。<len>字段占用1个字节，值为0xC0，后面的数据<data>存储为2个字节的int16_t类型。<br>|11010000| - 1 byte。<len>字段占用1个字节，值为0xD0，后面的数据<data>存储为4个字节的int32_t类型。<br>|11100000| - 1 byte。<len>字段占用1个字节，值为0xE0，后面的数据<data>存储为8个字节的int64_t类型。<br>|11110000| - 1 byte。<len>字段占用1个字节，值为0xF0，后面的数据<data>存储为3个字节长的整数。<br>|11111110| - 1 byte。<len>字段占用1个字节，值为0xFE，后面的数据<data>存储为1个字节的整数。<br>|1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<data>字段来表示真正的数据了，而是<len>和<data>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。<br>好了，ziplist的数据结构定义，我们介绍完了，现在我们看一个具体的例子。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/30/VvGUNH.png" alt="Redis Ziplist Sample"></p><p>上图是一份真实的ziplist数据。我们逐项解读一下：</p><p>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。<br>头4个字节（0x21000000）是按小端（little endian）模式存储的<zlbytes>字段。什么是小端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条Endianness）。因此，这里<zlbytes>的值应该解析成0x00000021，用十进制表示正好就是33。<br>接下来4个字节（byte[4..7]）是<zltail>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。<br>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。<br>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。<br>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。<br>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。<br>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。<br>最后1个字节（byte[32]）表示<zlend>，是固定的值255（0xFF）。<br>总结一下，这个ziplist里存了4个数据项，分别为：</p><p>字符串: “name”<br>字符串: “tielei”<br>字符串: “age”<br>整数: 20<br>（好吧，被你发现了~~tielei实际上当然不是20岁，他哪有那么年轻啊……）</p><p>实际上，这个ziplist是通过两个hset命令创建出来的。这个我们后半部分会再提到。</p><p>好了，既然你已经阅读到这里了，说明你还是很有耐心的（其实我写到这里也已经累得不行了）。可以先把本文收藏，休息一下，回头再看后半部分。</p><p>接下来我要贴一些代码了。</p><p>ziplist的接口<br>我们先不着急看实现，先来挑几个ziplist的重要的接口，看看它们长什么样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned <span class="keyword">char</span> *ziplistNew(<span class="keyword">void</span>);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistMerge(unsigned <span class="keyword">char</span> **first, unsigned <span class="keyword">char</span> **second);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistPush(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *s, unsigned <span class="keyword">int</span> slen, <span class="keyword">int</span> where);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistIndex(unsigned <span class="keyword">char</span> *zl, <span class="keyword">int</span> index);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistNext(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *p);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistPrev(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *p);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistInsert(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *p, unsigned <span class="keyword">char</span> *s, unsigned <span class="keyword">int</span> slen);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistDelete(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> **p);</span><br><span class="line">unsigned <span class="keyword">char</span> *ziplistFind(unsigned <span class="keyword">char</span> *p, unsigned <span class="keyword">char</span> *vstr, unsigned <span class="keyword">int</span> vlen, unsigned <span class="keyword">int</span> skip);</span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(unsigned <span class="keyword">char</span> *zl)</span></span>;</span><br></pre></td></tr></table></figure><p>我们从这些接口的名字就可以粗略猜出它们的功能，下面简单解释一下：</p><p>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。<br>ziplistNew: 创建一个空的ziplist（只包含<zlbytes><zltail><zllen><zlend>）。<br>ziplistMerge: 将两个ziplist合并成一个新的ziplist。<br>ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。<br>ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。<br>ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。<br>ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。<br>ziplistDelete: 删除指定的数据项。<br>ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。<br>ziplistLen: 计算ziplist的长度（即包含数据项的个数）。<br>ziplist的插入逻辑解析<br>ziplist的相关接口的具体实现，还是有些复杂的，限于篇幅的原因，我们这里只结合代码来讲解插入的逻辑。插入是很有代表性的操作，通过这部分来一窥ziplist内部的实现，其它部分的实现我们也就会很容易理解了。</p><p>ziplistPush和ziplistInsert都是插入，只是对于插入位置的限定不同。它们在内部实现都依赖一个名为__ziplistInsert的内部函数，其代码如下（出自ziplist.c）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> unsigned <span class="keyword">char</span> *__ziplistInsert(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *p, unsigned <span class="keyword">char</span> *s, unsigned <span class="keyword">int</span> slen) &#123;</span><br><span class="line">size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">unsigned <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">size_t offset;</span><br><span class="line"><span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">unsigned <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">we use it uninitialized. */</span></span><br><span class="line">zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unsigned <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is untouched, however zipEncodeLength will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(NULL,prevlen);</span><br><span class="line">    reqlen += zipEncodeLength(NULL,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-<span class="number">1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        memcpy(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单解析一下这段代码：</p><p>这个函数是在指定的位置p插入一段新的数据，待插入数据的地址指针是s，长度为slen。插入后形成一个新的数据项，占据原来p的配置，原来位于p位置的数据项以及后面的所有数据项，需要统一向后移动，给新插入的数据项留出空间。参数p指向的是ziplist中某一个数据项的起始位置，或者在向尾端插入的时候，它指向ziplist的结束标记<zlend>。<br>函数开始先计算出待插入位置前一个数据项的长度prevlen。这个长度要存入新插入的数据项的<prevrawlen>字段。<br>然后计算当前数据项占用的总字节数reqlen，它包含三部分：<prevrawlen>, <len>和真正的数据。其中的数据部分会通过调用zipTryEncoding先来尝试转成整数。<br>由于插入导致的ziplist对于内存的新增需求，除了待插入数据项占用的reqlen之外，还要考虑原来p位置的数据项（现在要排在待插入数据项之后）的<prevrawlen>字段的变化。本来它保存的是前一项的总长度，现在变成了保存当前插入的数据项的总长度。这样它的<prevrawlen>字段本身需要的存储空间也可能发生变化，这个变化可能是变大也可能是变小。这个变化了多少的值nextdiff，是调用zipPrevLenByteDiff计算出来的。如果变大了，nextdiff是正值，否则是负值。<br>现在很容易算出来插入后新的ziplist需要多少字节了，然后调用ziplistResize来重新调整大小。ziplistResize的实现里会调用allocator的zrealloc，它有可能会造成数据拷贝。<br>现在额外的空间有了，接下来就是将原来p位置的数据项以及后面的所有数据都向后挪动，并为它设置新的<prevrawlen>字段。此外，还可能需要调整ziplist的<zltail>字段。<br>最后，组装新的待插入数据项，放在位置p。<br>hash与ziplist<br>hash是Redis中可以用来存储一个对象结构的比较理想的数据类型。一个对象的各个属性，正好对应一个hash结构的各个field。</p><p>我们在网上很容易找到这样一些技术文章，它们会说存储一个对象，使用hash比string要节省内存。实际上这么说是有前提的，具体取决于对象怎么来存储。如果你把对象的多个属性存储到多个key上（各个属性值存成string），当然占的内存要多。但如果你采用一些序列化方法，比如Protocol Buffers，或者Apache Thrift，先把对象序列化为字节数组，然后再存入到Redis的string中，那么跟hash相比，哪一种更省内存，就不一定了。</p><p>当然，hash比序列化后再存入string的方式，在支持的操作命令上，还是有优势的：它既支持多个field同时存取（hmset/hmget），也支持按照某个特定的field单独存取（hset/hget）。</p><p>实际上，hash随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。在field比较少，各个value值也比较小的时候，hash采用ziplist来实现；而随着field增多和value值增大，hash可能会变成dict来实现。当hash底层变成dict来实现的时候，它的存储效率就没法跟那些序列化方式相比了。</p><p>当我们为某个key第一次执行 hset key field value 命令的时候，Redis会创建一个hash结构，这个新创建的hash底层就是一个ziplist。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robj *createHashObject(<span class="keyword">void</span>) &#123;</span><br><span class="line">unsigned <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的createHashObject函数，出自object.c，它负责的任务就是创建一个新的hash结构。可以看出，它创建了一个type = OBJ_HASH但encoding = OBJ_ENCODING_ZIPLIST的robj对象。</p><p>实际上，本文前面给出的那个ziplist实例，就是由如下两个命令构建出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset user:<span class="number">100</span> name tielei</span><br><span class="line">hset user:<span class="number">100</span> age <span class="number">20</span></span><br></pre></td></tr></table></figure><p>每执行一次hset命令，插入的field和value分别作为一个新的数据项插入到ziplist中（即每次hset产生两个数据项）。</p><p>当随着数据的插入，hash底层的这个ziplist就可能会转成dict。那么到底插入多少才会转呢？</p><p>还记得本文开头提到的两个Redis配置吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成dict：</p><p>当hash中的数据项（即field-value对）的数目超过512的时候，也就是ziplist数据项超过1024的时候（请参考t_hash.c中的hashTypeSet函数）。<br>当hash中插入的任意一个value的长度超过了64的时候（请参考t_hash.c中的hashTypeTryConversion函数）。<br>Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p><p>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能。<br>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。<br>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。<br>总之，ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内部数据结构详解(1)——dict</title>
      <link href="/2024/12/26/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(1)%E2%80%94%E2%80%94dict/"/>
      <url>/2024/12/26/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(1)%E2%80%94%E2%80%94dict/</url>
      
        <content type="html"><![CDATA[<p>如果你使用过Redis，一定会像我一样对它的内部实现产生兴趣。《Redis内部数据结构详解》是我准备写的一个系列，也是我个人对于之前研究Redis的一个阶段性总结，着重讲解Redis在内存中的数据结构实现（暂不涉及持久化的话题）。Redis本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p><p>当我们在本文中提到Redis的“数据结构”，可能是在两个不同的层面来讨论它。</p><p>第一个层面，是从使用者的角度。比如：</p><p>string<br>list<br>hash<br>set<br>sorted set<br>这一层面也是Redis暴露给外部的调用接口。</p><p>第二个层面，是从内部实现的角度，属于更底层的实现。比如：</p><p>dict<br>sds<br>ziplist<br>quicklist<br>skiplist<br>第一个层面的“数据结构”，Redis的官方文档(<a href="http://redis.io/topics/data-types-intro)%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82%E6%9C%AC%E6%96%87%E7%9A%84%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E8%AE%A8%E8%AE%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%B1%82%E9%9D%A2%EF%BC%8CRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%B1%82%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9ARedis%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%B1%82%E9%9D%A2%E7%9A%84%E5%90%84%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B1%82%E9%9D%A2%E7%9A%84%E6%9B%B4%E9%AB%98%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%82">http://redis.io/topics/data-types-intro)有详细的介绍。本文的重点在于讨论第二个层面，Redis数据结构的内部实现，以及这两个层面的数据结构之间的关系：Redis如何通过组合第二个层面的各种基础数据结构来实现第一个层面的更高层的数据结构。</a></p><p>在讨论任何一个系统的内部实现的时候，我们都要先明确它的设计原则，这样我们才能更深刻地理解它为什么会进行如此设计的真正意图。在本文接下来的讨论中，我们主要关注以下几点：</p><p>存储效率（memory efficiency）。Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着Redis一定是非常精细地考虑了压缩数据、减少内存碎片等问题。<br>快速响应时间（fast response time）。与快速响应时间相对的，是高吞吐量（high throughput）。Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，快速响应时间是比高吞吐量更重要的目标。有时候，这两个目标是矛盾的。<br>单线程（single-threaded）。Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。<br>本文是《Redis内部数据结构详解》系列的第一篇，讲述Redis一个重要的基础数据结构：dict。</p><p>dict是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。Redis的一个database中所有key到value的映射，就是使用一个dict来维护的。不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。比如，一个Redis hash结构，当它的field较多时，便会采用dict来存储。再比如，Redis配合使用dict和skiplist来共同维护一个sorted set。这些细节我们后面再讨论，在本文中，我们集中精力讨论dict本身的实现。</p><p>dict本质上是为了解决算法中的查找问题（Searching），一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。我们平常使用的各种Map或dictionary，大都是基于哈希表实现的。在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，基于哈希表的查找性能能做到非常高效，接近O(1)，而且实现简单。</p><p>在Redis中，dict也是一个基于哈希表的算法。和传统的哈希算法类似，它采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发重哈希（rehashing）。Redis的dict实现最显著的一个特点，就在于它的重哈希。它采用了一种称为增量式重哈希（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p><p>下面进行详细介绍。</p><p>dict的数据结构定义<br>为了实现增量式重哈希（incremental rehashing），dict的数据结构里包含两个哈希表。在重哈希期间，数据从第一个哈希表向第二个哈希表迁移。</p><p>dict的C代码定义如下（出自Redis源码dict.h）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ypedef struct dictEntry &#123;</span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line">    <span class="function">unsigned <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    unsigned <span class="keyword">long</span> size;</span><br><span class="line">    unsigned <span class="keyword">long</span> sizemask;</span><br><span class="line">    unsigned <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>为了能更清楚地展示dict的数据结构定义，我们用一张结构图来表示它。如下。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/30/6PgnL8.png" alt="Redis dict结构图"></p><p>结合上面的代码和结构图，可以很清楚地看出dict的结构。一个dict由如下若干项组成：</p><p>一个指向dictType结构的指针（type）。它通过自定义的方式使得dict的key和value能够存储任何类型的数据。<br>一个私有数据指针（privdata）。由调用者在创建dict的时候传进来。<br>两个哈希表（ht[2]）。只有在重哈希的过程中，ht[0]和ht[1]才都有效。而在平常情况下，只有ht[0]有效，ht[1]里面没有任何数据。上图表示的就是重哈希进行到中间某一步时的情况。<br>当前重哈希索引（rehashidx）。如果rehashidx = -1，表示当前没有在重哈希过程中；否则，表示当前正在进行重哈希，且它的值记录了当前重哈希进行到哪一步了。<br>当前正在进行遍历的iterator的个数。这不是我们现在讨论的重点，暂时忽略。<br>dictType结构包含若干函数指针，用于dict的调用者对涉及key和value的各种操作进行自定义。这些操作包含：</p><p>hashFunction，对key进行哈希值计算的哈希算法。<br>keyDup和valDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递对象指针。<br>keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。<br>keyDestructor和valDestructor，分别定义对key和value的析构函数。<br>私有数据指针（privdata）就是在dictType的某些操作被调用时会传回给调用者。</p><p>需要详细察看的是dictht结构。它定义一个哈希表的结构，由如下若干项组成：</p><p>一个dictEntry指针数组（table）。key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。<br>size：标识dictEntry指针数组的长度。它总是2的指数。<br>sizemask：用于将哈希值映射到table的位置索引。它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。<br>used：记录dict中现有的数据个数。它与size的比值就是装载因子（load factor）。这个比值越大，哈希值冲突概率越高。<br>dictEntry结构中包含k, v和指向链表下一项的next指针。k是void指针，这意味着它可以指向任何类型。v是个union，当它的值是uint64_t、int64_t或double类型时，就不再需要额外的存储，这有利于减少内存碎片。当然，v也可以是void指针，以便能存储任何类型的数据。</p><p>dict的创建（dictCreate）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dict *dictCreate(dictType *type,</span><br><span class="line"><span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">dict *d = zmalloc(sizeof(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">_dictInit</span><span class="params">(dict *d, dictType *type,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">_dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">d-&gt;type = type;</span><br><span class="line">d-&gt;privdata = privDataPtr;</span><br><span class="line">d-&gt;rehashidx = -<span class="number">1</span>;</span><br><span class="line">d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_dictReset</span><span class="params">(dictht *ht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ht-&gt;table = NULL;</span><br><span class="line">ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dictCreate为dict的数据结构分配空间并为各个变量赋初值。其中两个哈希表ht[0]和ht[1]起始都没有分配空间，table指针都赋为NULL。这意味着要等第一个数据插入时才会真正分配空间。</p><p>dict的查找（dictFind）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function">define <span class="title">dictIsRehashing</span><span class="params">(d)</span> <span class="params">((d)</span>-&gt;rehashidx !</span>= -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dictEntry *dictFind(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">dictEntry *he;</span><br><span class="line">unsigned <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> NULL; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述dictFind的源码，根据dict当前是否正在重哈希，依次做了这么几件事：</p><p>如果当前正在进行重哈希，那么将重哈希过程向前推进一步（即调用_dictRehashStep）。实际上，除了查找，插入和删除也都会触发这一动作。这就将重哈希过程分散到各个查找、插入和删除操作中去了，而不是集中在某一个操作中一次性做完。<br>计算key的哈希值（调用dictHashKey，里面的实现会调用前面提到的hashFunction）。<br>先在第一个哈希表ht[0]上进行查找。在table数组上定位到哈希值对应的位置（如前所述，通过哈希值与sizemask进行按位与），然后在对应的dictEntry链表上进行查找。查找的时候需要对key进行比较，这时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项。否则，进行下一步。<br>判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回NULL）。否则，在ht[1]上进行查找（过程与上一步相同）。<br>下面我们有必要看一下增量式重哈希的_dictRehashStep的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_dictRehashStep</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line"><span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="keyword">assert</span>(d-&gt;ht[<span class="number">0</span>].size &gt; (unsigned <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == NULL) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            unsigned <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = NULL;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dictRehash每次将重哈希至少向前推进n步（除非不到n步整个重哈希就结束了），每一步都将ht[0]上某一个bucket（即一个dictEntry链表）上的每一个dictEntry移动到ht[1]上，它在ht[1]上的新位置根据ht[1]的sizemask进行重新计算。rehashidx记录了当前尚未迁移（有待迁移）的ht[0]的bucket位置。</p><p>如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么它就没有可迁移的数据。这时它尝试在ht[0].table数组中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，则最多走n*10步，本次重哈希暂告结束。</p><p>最后，如果ht[0]上的数据都迁移到ht[1]上了（即d-&gt;ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。</p><p>根据以上对于重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上去了。</p><p>dict的插入（dictAdd和dictReplace）<br>dictAdd插入新的一对key和value，如果key已经存在，则插入失败。</p><p>dictReplace也是插入一对key和value，不过在key存在的时候，它会更新value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dictEntry *entry = dictAddRaw(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">dictEntry *entry;</span><br><span class="line">dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(sizeof(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">_dictKeyIndex</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unsigned <span class="keyword">int</span> h, idx, table;</span><br><span class="line">dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是dictAdd的关键实现代码。我们主要需要注意以下几点：</p><p>它也会触发推进一步重哈希（_dictRehashStep）。<br>如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]。<br>在对应的bucket中插入数据的时候，总是插入到dictEntry的头部。因为新数据接下来被访问的概率可能比较高，这样再次查找它时就比较次数较少。<br>_dictKeyIndex在dict中寻找插入位置。如果不在重哈希过程中，它只查找ht[0]；否则查找ht[0]和ht[1]。<br>_dictKeyIndex可能触发dict内存扩展（_dictExpandIfNeeded，它将哈希表长度扩展为原来两倍，具体请参考dict.c中源码）。<br>dictReplace在dictAdd基础上实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    entry = dictFind(d, key);</span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    dictFreeVal(d, &amp;auxentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind，这其实相当于两次查找过程。这里Redis的代码不够优化。</p><p>dict的删除（dictDelete）<br>dictDelete的源码这里忽略，具体请参考dict.c。需要稍加注意的是：</p><p>dictDelete也会触发推进一步重哈希（_dictRehashStep）<br>如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key；否则ht[0]和ht[1]它都要查找。<br>删除成功后会调用key和value的析构函数（keyDestructor和valDestructor）。</p>]]></content>
      
      
      <categories>
          
          <category> 5.缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis面试</title>
      <link href="/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/"/>
      <url>/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h2><p>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(2)——sds" target="_blank">Redis内部数据结构详解(2)——sds</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(3)——robj" target="_blank">Redis内部数据结构详解(3)——robj</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(5)——quicklist" target="_blank">Redis内部数据结构详解(5)——quicklist</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(6)——skiplist" target="_blank">Redis内部数据结构详解(6)——skiplist</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(7)——intset" target="_blank">Redis内部数据结构详解(7)——intset</a></p><h2 id="2-数据结构-对象头RedisObject"><a href="#2-数据结构-对象头RedisObject" class="headerlink" title="2.数据结构-对象头RedisObject"></a>2.数据结构-对象头RedisObject</h2><p>16字节的存储空间</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/bJEfKW.png" alt="image-20250102202655892"></p><h2 id="3-数据结构-string"><a href="#3-数据结构-string" class="headerlink" title="3.数据结构-string"></a>3.数据结构-string</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/rjQfDK.png" alt="image-20250102202754751"></p><p>相比较于C语言中的字符串，头部信息里面包含了字符串的实际长度len，可以通过O（1）的时间复杂度得到</p><p>有点类似于Java中的ArrayList</p><p>数组长度和数组容量使用范型来定义是为了追求内存的极致优化，对于不同长度的字符串，底层采用不同类型的数据来保存，字符串比较短的时候，可以使用byte和short来表示。</p><h2 id="4-数据结构-string-三种底层编码方式"><a href="#4-数据结构-string-三种底层编码方式" class="headerlink" title="4.数据结构-string 三种底层编码方式"></a>4.数据结构-string 三种底层编码方式</h2><p>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(2)——sds" target="_blank">Redis内部数据结构详解(2)——sds</a></p><p>1).当存储的字符串全是数字的时候，此时使用int方式来存储</p><p>2).当存储的字符串长度小于等于44字符的时候，使用embstr方式来存储</p><p>对象头和SDS对象本身在内存中地址连续</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/Bg8xfb.png" alt="image-20250102202948214"></p><p>3).长度大于44字符时，采用raw方式存储</p><p>对象头和SDS对象本身在内存中地址不连续</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/pFNY9U.png" alt="image-20250102203002638"></p><h2 id="5-数据结构-string-为什么上面的阈值是44呢？"><a href="#5-数据结构-string-为什么上面的阈值是44呢？" class="headerlink" title="5.数据结构-string  为什么上面的阈值是44呢？"></a>5.数据结构-string  为什么上面的阈值是44呢？</h2><p>一个字符串包含RedisObject和SDS的数据结构，至少会占用19（16 + 3）个字节的空间大小。</p><p>C语言中的内存分配器分配内存大小的单位都是2的n次方，为了容纳一个完整的embstr对象，最少要分配32字节的空间。稍微长一些就是64字节了。所以定义大于64字节就属于大字符串。</p><p>64-19 = 45.剩余可防存放字符串的空间45字节，而字符串又是以NULL结尾，占据了1个字节，所以阈值为44</p><h2 id="6-数据结构-List"><a href="#6-数据结构-List" class="headerlink" title="6.数据结构-List"></a>6.数据结构-List</h2><p>1).Redis3.2版本之前，使用两种数据结构作为底层实现。</p><p>1.压缩列表 zipList<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p><p>设计初衷是为了节约内存。使用一块连续的内存空间存储。每个元素长度不同，采用变长编码</p><p>如果采用双向链表，那么就需要额外的内存空间来维护头尾两个指针，在zipList在结构上可以得到上一个结点的长度和当前结点的长度。通过上一个结点的长度可以定位到上一个元素起始的位置，而通过当前结点的长度，可以将指针定位到下一个元素的起始位置。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/uWGGCP.png" alt="image-20250103170948845"></p><p>变长编码体现在prevrawlensize属性，它记录的是prerawlen的大小，分为两种。</p><p>a.若前一个结点的长度小于254字节，那么则使用1字节来存储prerawlen</p><p>b.若前一个结点的长度大于等于254字节，那么将第一个字节设置为254，然后接下来的4个字节保存实际的长度。也就是用5个字节来表示prerawlen的长度。</p><p>存在连锁更新问题</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/19QcEp.png" alt="image-20250103171040501"></p><p>2.双向链表 LinkedList</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/nlVJG4.png" alt="image-20250103170908319"></p><p>2).3.2之后，将压缩列表和双向链表结合，称之为quickList<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(5)——quicklist" target="_blank">Redis内部数据结构详解(5)——quicklist</a></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/C2q46W.png" alt="image-20250103170838283"></p><h2 id="7-数据结构-hash"><a href="#7-数据结构-hash" class="headerlink" title="7.数据结构-hash"></a>7.数据结构-hash</h2><p>1).当数据量较小的时候，采用zipList作为hash的底层实现<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p><p>2).另一种方式是字典dict<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/IYVx7k.png" alt="image-20250103171223481"></p><p>rehashidx用于标记rehash的进度，为0 表示rehash开始</p><p>hash表dictht结构</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/21EHHO.png" alt="image-20250103171255778"></p><p>table 2维数组，第一维度数组表示hash表的槽位，第二个维度是每一个槽对应的链表</p><p>真正的存储数据的结构dictEnrty</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/WQwrSU.png" alt="image-20250103171324284"></p><p>完整结构图</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/JL9imI.png" alt="image-20250103171429515"></p><h2 id="8-dict的扩容和缩容"><a href="#8-dict的扩容和缩容" class="headerlink" title="8.dict的扩容和缩容"></a>8.dict的扩容和缩容</h2><p>1).扩容</p><p>是为了减少hash冲突的概率</p><p>扩容的时机：</p><p>a.BGSAVE和BGREWRITEAOF指令的情况下，hash表的负载因子大于等于1的时候进行扩容。</p><p>b.正在执行BGSAVE和BGREWRITEAOF指令的情况下，hash表的负载因子大于等于5的时候进行扩容。</p><p>扩容的大小:</p><p>扩容后的dictEntry数组长度为第一个大于等于 ht[0].used * 2 的 2^n 也就是第一个大于等于已使用数量的两倍的2的幂次方。</p><p>渐进式rehash:</p><p>rehash进行期间，每次对字典执行添加、删除、查找或者更新操作的时候，除了执行指定的操作之外，还会顺带将dictht[0] hash表当中在rehashidx索引上的所有键值对进行rehash到dictht[1]当中，当一次rehash工作完成之后，会将rehashidx的值+1。</p><p>同时在循环时间事件serverCron当中，会调用rehash相关函数，在1ms的时间内，进行rehash处理，每次仅处理少量的转移任务（100个元素）</p><p>随着字典操作的不断执行，最终在某个时间点上，dictht[0]当中所有的键值对都会被rehash到dictht[1]当中，此时将rehashidx属性值设置为-1，表示rehash操作已经完成，将dictht[0]重新赋值dictht[1],接着清空dictht[1]。</p><p>2).缩容</p><p>减少空间的消耗。</p><p>缩容的时机：</p><p>负载因子小于0.1的时候，Redis自动开始对Hash表进行缩容操作。</p><p>缩容的大小：</p><p>缩容后的dictEntry数组长度为第一个大于等于 ht[0].used 的 2^n 也就是第一个大于等于已使用数量的2的幂次方。</p><h2 id="9-数据结构-set"><a href="#9-数据结构-set" class="headerlink" title="9.数据结构-set"></a>9.数据结构-set</h2><p>1).当存储的元素都是整数值，且数据量不大时使用inset<br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(7)——intset" target="_blank">Redis内部数据结构详解(7)——intset</a></p><p>结构定义</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/iZlIcI.png" alt="image-20250103172348366"></p><p>编码格式有3种，为了节省内存，会根据插入数据的大小选择不一样的类型来存储。</p><p>length记录保存数据的数组contents中共有多少个元素。</p><p>contents数组，真正存储数据的地方，数组时按照从小到大有序排列，且不包含任何重复项</p><p>优点：节省内存</p><p>缺点：升级过程中消耗资源；不支持降级</p><p>2).其他时候使用dict，结构等同于hash中的dict<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a></p><h2 id="10-inset整数升级过程"><a href="#10-inset整数升级过程" class="headerlink" title="10.inset整数升级过程"></a>10.inset整数升级过程</h2><p>假设一开始4个元素，1、2、3、4，依次存储在contents当中。每个元素占据了16位</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/L5nEHg.png" alt="image-20250103172542625"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/uH4W1J.png" alt="image-20250103172557637"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/mICCJ6.png" alt="image-20250103172610323"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/P8Eq4z.png" alt="image-20250103172625367"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/SZYlK6.png" alt="image-20250103172640937"></p><h2 id="11-数据结构-zset"><a href="#11-数据结构-zset" class="headerlink" title="11.数据结构-zset"></a>11.数据结构-zset</h2><p>1).ziplist，元素数量小于128个 所有元素的长度都小于64字节的时候 使用该数据结构。<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p><p>以上两个条件可以通过Redis配置文件 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改</p><p>2).其他时候，由跳表和字典组成的数据结构<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(6)——skiplist" target="_blank">Redis内部数据结构详解(6)——skiplist</a></p><p>字典结构来存储value和score的对应关系，跳表提供按照score排序的功能</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/AYmEZm.png" alt="image-20250103173213499"></p><p>zskiplist是skiplist的数据结构</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/oI339f.png" alt="image-20250103173239203"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Xm4xz5.png" alt="image-20250103173253700"></p><p>跳表结构的更新：</p><p>当插入一个数据的时候，根据score找到插入的位置，然后随机计算出结点的层数，插入，再修改结点间的引用关系。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/H7HYma.png" alt="image-20250103173351076"></p><p>随机层数的伪代码：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/bmyxCe.png" alt="image-20250103173418136"></p><p>p为0.25，MaxLevel为32</p><h2 id="12-Redis持久化"><a href="#12-Redis持久化" class="headerlink" title="12.Redis持久化"></a>12.Redis持久化</h2><p>1).RDB快照(snapshot)</p><p>Redis DataBase缩写快找。Redis中的默认的持久化机制</p><p>按照一定的时间将内存的数据以快找的形式保存到磁盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p>N 秒内数据集至少有 M 个改动  例如 save 60 1000  表示 60秒至少有1000个键被改动 则自动保存一次</p><p>优点:</p><p>a.只有一个文件dump.rdb，方便持久化</p><p>b.容灾性好，一个文件可以保存到安全的磁盘</p><p>c.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</p><p>d.相对于数据集大时，比AOF的启动效率更高。</p><p>缺点:</p><p>a.数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。</p><p>2).AOF(append-only file)</p><p>将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p>优点:</p><p>a.数据安全</p><p>b.AOF rewrite模式。AOF文件没有被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令。</p><p>c.aof文件是明文的，可阅读性较好</p><p>缺点:</p><p>a.AOF文件比RDB文件大，且恢复速度慢</p><p>b.数据集大的时候，比RDB启动效率低</p><p>3).当两种方式同时开启的时候，Redis会优先选择AOF恢复</p><p>4).混合持久化</p><p>Redis4.0新的持久化选项</p><p>将rdb文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志</p><h2 id="13-Redis的过期策略有哪些"><a href="#13-Redis的过期策略有哪些" class="headerlink" title="13.Redis的过期策略有哪些"></a>13.Redis的过期策略有哪些</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了</p><p>1).定时过期</p><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即删除。</p><p>该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><p>2).惰性过期</p><p>只有当访问一个key的时候，才会判断key是否过期，过期则删除。</p><p>该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><p>3).定期过期</p><p>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。</p><p>通过调整定时扫描器的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p><p>redis中同时使用了惰性过期和定期过期两种策略。</p><h2 id="14-Redis的内存淘汰策略有哪些"><a href="#14-Redis的内存淘汰策略有哪些" class="headerlink" title="14.Redis的内存淘汰策略有哪些"></a>14.Redis的内存淘汰策略有哪些</h2><p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p><p><strong>a) 针对设置了过期时间的key做处理：</strong></p><ol><li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li><li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li><li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li><li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li></ol><p><strong>b) 针对所有的key做处理：</strong></p><ol><li>allkeys-random：从所有键值对中随机选择并删除数据。</li><li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li><li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li></ol><p><strong>c) 不处理：</strong></p><ol><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ol><p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）</p><p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p><p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p><ol><li>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</li><li>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</li></ol><h2 id="15-缓存雪崩、缓存击穿、缓存穿透及解决方案"><a href="#15-缓存雪崩、缓存击穿、缓存穿透及解决方案" class="headerlink" title="15.缓存雪崩、缓存击穿、缓存穿透及解决方案"></a>15.缓存雪崩、缓存击穿、缓存穿透及解决方案</h2><ul><li><strong>缓存雪崩</strong>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol><li>过期时间随机，防止同一时间大量数据过期</li><li>缓存预热：项目启动加载缓存到redis</li><li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li><li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li></ol></li><li><strong>缓存穿透</strong>：指数据库没有数据，导致请求落到数据库上<ol><li>接口层增加校验，对id进行规则拦截</li><li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li><li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li></ol></li><li><strong>缓存击穿</strong>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol><li>key不过期</li><li>加互斥锁</li></ol></li></ul><h2 id="16-大key"><a href="#16-大key" class="headerlink" title="16.大key"></a>16.大key</h2><p>按照一定规则拆分大key，比如一个key中放入了全量类型的配置，可以拆成若干个不同类型的key，大key变小。</p><h2 id="17-热key"><a href="#17-热key" class="headerlink" title="17.热key"></a>17.热key</h2><p>集群模式下，把key复制若干份，使得不同的key分配在不同的槽中，用户访问的时候，可以根据用户id进行hash操作，使不同用户访问不同的key，但是这些key里的信息都是完全一致的，同时更新缓存的时候也需要注意更新所有的缓存key</p><h2 id="18-缓存与数据库数据一致性"><a href="#18-缓存与数据库数据一致性" class="headerlink" title="18.缓存与数据库数据一致性"></a>18.缓存与数据库数据一致性</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/HwOLrx.png" /><p>解决方案：</p><ol><li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li><li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li><li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li><li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li></ol><h2 id="19-redis主从模式"><a href="#19-redis主从模式" class="headerlink" title="19.redis主从模式"></a>19.redis主从模式</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/ygdr0K.png" alt="image-20250103194315166"></p><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/MaCJgw.png" alt="image-20250103194336735"></p><h2 id="20-redis主从同步完整的复制流程"><a href="#20-redis主从同步完整的复制流程" class="headerlink" title="20.redis主从同步完整的复制流程"></a>20.redis主从同步完整的复制流程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Hu0vV9.png" alt="image-20250103194420907"></p><h2 id="21-master节点-run-id的作用"><a href="#21-master节点-run-id的作用" class="headerlink" title="21.master节点 run id的作用"></a>21.master节点 run id的作用</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/pQgEVY.png" alt="image-20250103194507663"></p><h2 id="22-主从模式全量复制"><a href="#22-主从模式全量复制" class="headerlink" title="22.主从模式全量复制"></a>22.主从模式全量复制</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/UYw9C3.png" alt="image-20250103194701314"></p><h2 id="23-主从模式增量同步"><a href="#23-主从模式增量同步" class="headerlink" title="23.主从模式增量同步"></a>23.主从模式增量同步</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/L8uamg.png" alt="image-20250103194716908"></p><h2 id="24-redis哨兵模式（sentinal）"><a href="#24-redis哨兵模式（sentinal）" class="headerlink" title="24.redis哨兵模式（sentinal）"></a>24.redis哨兵模式（sentinal）</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/UgkOH4.png" alt="image-20250103194800854"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/QCCXWz.png" alt="image-20250103194827176"></p><p>为什么redis哨兵集群只有2个节点无法正常工作</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/DdMjxl.png" alt="image-20250103194857786"></p><p>经典的3节点哨兵集群</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Hvikh4.png" alt="image-20250103194923140"></p><p>异步复制导致的数据丢失问题</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/KPp10n.png" alt="image-20250103195018023"></p><p>集群脑裂导致的数据丢失问题</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/pKPBFB.png" alt="image-20250103195042749"></p><p>解决异步复制和脑裂导致的数据丢失</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/vUFWYC.png" alt="image-20250103195222151"></p><p>redis哨兵的选举算法</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/cpGAz7.png" alt="image-20250103195251420"></p><h2 id="25-redis集群模式cluster"><a href="#25-redis集群模式cluster" class="headerlink" title="25.redis集群模式cluster"></a>25.redis集群模式cluster</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/NPhM4O.png" alt="image-20250103195336523"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/XSllGZ.png" alt="image-20250103195400875"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/bqT5gR.png" alt="image-20250103195413493"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/IYFZRT.png" alt="image-20250103195429337"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/0REkEU.png" alt="image-20250103195446204"></p><h2 id="26-一致性hash"><a href="#26-一致性hash" class="headerlink" title="26.一致性hash"></a>26.一致性hash</h2><p>地址：<a href="/2025/01/03/5.缓存/一致性hash" target="_blank">一致性hash</a></p><h2 id="27-Redis-避免缓存穿透的利器之BloomFilter"><a href="#27-Redis-避免缓存穿透的利器之BloomFilter" class="headerlink" title="27.Redis-避免缓存穿透的利器之BloomFilter"></a>27.Redis-避免缓存穿透的利器之BloomFilter</h2><p>地址：<a href="/2025/01/03/5.缓存/Redis-避免缓存穿透的利器之BloomFilter" target="_blank">Redis-避免缓存穿透的利器之BloomFilter</a></p><h2 id="28-redis单线程为什么快"><a href="#28-redis单线程为什么快" class="headerlink" title="28.redis单线程为什么快"></a>28.redis单线程为什么快</h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p><ol><li>完全基于内存操作</li><li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li><li>使用单线程，无上下文的切换成本</li><li>基于非阻塞的IO多路复用机制</li></ol><h2 id="29-那为什么Redis6-0之后又改用多线程呢"><a href="#29-那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="29.那为什么Redis6.0之后又改用多线程呢?"></a>29.那为什么Redis6.0之后又改用多线程呢?</h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p><p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h2 id="30-redis单线程模型原理"><a href="#30-redis单线程模型原理" class="headerlink" title="30.redis单线程模型原理"></a>30.redis单线程模型原理</h2><p>1、首先redis是单线程的，为什么redis会是单线程的呢？ </p><p>从redis的性能上进行考虑，单线程避免了上下文频繁切换问题，效率高； </p><p>从redis的内部结构设计原理进行考虑，redis是基于Reactor模式开发了自己的网络事件处理器： </p><p>这个处理器被称为文件事件处理器（file event handler）。而这个文件事件处理器是单线程的，所以才叫redis的单线程模型，这也决定了redis是单线程的。 </p><p>2、聊一聊redis的单线程模型构造部分？ </p><p>redis单线程模型中最为核心的就是文件事件处理器 而文件事件处理器结构包含5个部分，其实真正包含为4个部分（不包含socket队列，加上主要方便后面理解）：多个socket、IO多路复用程序、socket队列、文件事件分派器、以及事件处理器。而事件处理器又分为3个部分为：连接应答处理器、命令请求处理器、命令回复处理器。如图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/dZTLix.png" alt="img"></p><p>3、redis单线程模型的大致工作流程及原理 客户端与redis进行通信大致流程：</p><p>1)、首先在redis启动初始化的时候，redis会先将事件处理器中的连接应答处理器和AE_READABLE事件关联起来;</p><p>2)、如果客户端向redis发起连接，会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于连接应答处理器和AE_READABLE事件在redis初始化的时候已经关联起来，所以由连接应答处理器来处理跟客户端建立连接，然后通过ServerSocket创建一个与客户端一对一对应的socket，如叫socket01，同时将这个socket01的AE_READABLE事件和命令请求处理器关联起来。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/GKfInf.png" alt="img"></p><p>3)、当客户端向redis发生请求时(读、写操作)，首先就会在对应的socket如socket01上会产生AE_READABLE事件(步骤A)，产生该事件后会被IO多路复用程序监听到(步骤B)，然后IO多路复用程序会把监听到的socket信息放入到队列中(步骤C)，事件分配器每次从队列中取出一个socket(步骤D)，然后事件分派器把socket给对应的事件处理器(步骤E)。由于命令处理器和socket01的AE_READABLE事件关联起来了，然后对应的命令请求处理器来处理。这个命令请求处理器会从事件分配器传递过来的socket01上读取相关的数据，如何执行相应的读写处理。操作执行完之后，redis就会将准备好相应的响应数据(如你在redis客户端输入 set a 123回车时会看到响应ok)，并将socket01的AE_WRITABLE事件和命令回复处理器关联起来。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/NnGKoM.png" alt="img"></p><p>4)、当客户端会查询redis是否完成相应的操作，就会在socket01上产生一个AE_WRITABLE事件，会由对应的命令回复处理器来处理，就是将准备好的相应数据写入socket01(由于socket连接是双向的),返回给客户端，如读操作，客户端会显示ok。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/9VZ464.png" alt="img"></p><p>5)、如果命令回复处理器执行完成后，就会删除这个socket01的AE_WRITABLE事件和命令回复处理器的关联。</p><p> 6)、这样客户端就和redis进行了一次通信。由于连接应答处理器执行一次就够了，如果客户端在次进行操作就会由命令请求处理器来处理，反复执行。</p><h2 id="31-场景题"><a href="#31-场景题" class="headerlink" title="31.场景题"></a>31.场景题</h2><p>1).排行榜（多维度）</p><p>eg:time整数部分+时间小数部分</p><p>2).redis实现消息队列</p><p>一般使用list结构作为队列，<strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>如果对方追问可不可以不用sleep呢？</p><p>list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</p><h2 id="32-redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁"><a href="#32-redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁" class="headerlink" title="32.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁"></a>32.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁</h2><p>1.redis <code>SET key value NX PX 30000</code></p><p>2.zk  随机创建目录</p><p>3.zk 创建有序的目录结构</p><p>4.redission。  tryLock</p><h2 id="33-redis和数据库数据一致性问题"><a href="#33-redis和数据库数据一致性问题" class="headerlink" title="33.redis和数据库数据一致性问题"></a>33.redis和数据库数据一致性问题</h2><p>缓存策略的最佳实践是 Cache Aside Pattern。分别分为读缓存最佳实践和写缓存最佳实践。</p><p>读缓存最佳实践：先读缓存，命中则返回；未命中则查询数据库，再写到缓存中。</p><p>写缓存最佳实践：</p><p>先写数据库，再操作缓存；</p><p>直接删除缓存，而不是修改，因为当缓存的更新成本很高，需要访问多张表联合计算，建议直接删除缓存，而不是更新，另外，删除缓存操作简单，副作用只是增加了一次 chache miss，建议大家使用该策略。</p><p>在以上最佳实践下，为了尽可能保证缓存与数据库的一致性，我们可以采用延迟双删。</p><p>防止删除失败，我们采用异步重试机制保证能正确删除，异步机制我们可以发送删除消息到 mq 消息中间件，或者利用 canal 订阅 MySQL binlog 日志监听写请求删除对应缓存。</p><p>那么，如果我非要保证绝对一致性怎么办，先给出结论：</p><p>没有办法做到绝对的一致性，这是由 CAP 理论决定的，缓存系统适用的场景就是非强一致性的场景，所以它属于 CAP 中的 AP。</p><p>所以，我们得委曲求全，可以去做到 BASE 理论中说的最终一致性。</p><p>其实一旦在方案中使用了缓存，那往往也就意味着我们放弃了数据的强一致性，但这也意味着我们的系统在性能上能够得到一些提升。</p><p>所谓 tradeoff 正是如此。</p><h2 id="34-setnx用到的参数"><a href="#34-setnx用到的参数" class="headerlink" title="34.setnx用到的参数"></a>34.setnx用到的参数</h2><p><code>SET key value NX PX 30000</code></p><p>第三个参数：把key、value set到redis中的策略</p><ul><li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li><li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li></ul><p>第四个参数：过期时间单位</p><ul><li>  ex ：seconds 秒</li><li>  px : milliseconds 毫秒</li></ul><p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error</p><p>第五个参数：有两种可选的值，</p><p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM面试</title>
      <link href="/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/"/>
      <url>/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="1-jvm内存模型"><a href="#1-jvm内存模型" class="headerlink" title="1.jvm内存模型"></a>1.jvm内存模型</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/0Wv4TH.png" style="zoom:67%;" /><p><strong>堆</strong>：堆Java虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为Yound区年轻代和Old区老年代，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是8:1:1的大小。</p><p><strong>栈</strong>：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。</p><p>局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，他的参数会被传递至从0开始的连续的局部变量表中。</p><p>操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。</p><p>动态连接用于将符号引用表示的方法转换为实际方法的直接引用。</p><p><strong>元数据</strong>：在Java1.7之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。</p><p>Class文件就是类和接口的定义信息。</p><p>运行时常量池就是类和接口的常量池运行时的表现形式。</p><p><strong>本地方法栈</strong>：主要用于执行本地native方法的区域</p><p><strong>程序计数器</strong>：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址</p><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><h2 id="2-PC寄存器为什么会被设定为线程私有的？"><a href="#2-PC寄存器为什么会被设定为线程私有的？" class="headerlink" title="2.PC寄存器为什么会被设定为线程私有的？"></a>2.PC寄存器为什么会被设定为线程私有的？</h2><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响</p><h2 id="3-什么是虚拟机栈（线程私有）？"><a href="#3-什么是虚拟机栈（线程私有）？" class="headerlink" title="3.什么是虚拟机栈（线程私有）？"></a>3.什么是虚拟机栈（线程私有）？</h2><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p><ul><li><strong>特点？</strong></li></ul><ol><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li><li>栈不存在垃圾回收问题</li><li>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li></ol><ul><li><strong>该区域有哪些异常</strong>？</li></ul><ol><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li></ol><ul><li><strong>栈帧的内部结构？</strong></li></ul><ol><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ol><h2 id="4-什么是本地方法栈（线程私有）？"><a href="#4-什么是本地方法栈（线程私有）？" class="headerlink" title="4.什么是本地方法栈（线程私有）？"></a>4.什么是本地方法栈（线程私有）？</h2><ul><li><strong>本地方法接口</strong></li></ul><p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><ul><li><strong>本地方法栈(Native Method Stack)</strong></li></ul><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p><h2 id="5-什么是方法区（线程共享）？"><a href="#5-什么是方法区（线程共享）？" class="headerlink" title="5.什么是方法区（线程共享）？"></a>5.什么是方法区（线程共享）？</h2><p>方法区（method area）只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）**是 **Hotspot** 虚拟机特有的概念， Java8 的时候又被**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</p><p>JDK1.8之前调节方法区大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区（永久代）初始大小</span><br><span class="line">-XX:MaxPermSize=N //方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError </span><br></pre></td></tr></table></figure><p>JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小</span><br></pre></td></tr></table></figure><h2 id="6-栈、堆、方法区的交互关系"><a href="#6-栈、堆、方法区的交互关系" class="headerlink" title="6.栈、堆、方法区的交互关系"></a>6.栈、堆、方法区的交互关系</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/P08Jqc.png" alt="img"></p><h2 id="7-堆区内存是怎么细分的？"><a href="#7-堆区内存是怎么细分的？" class="headerlink" title="7.堆区内存是怎么细分的？"></a>7.堆区内存是怎么细分的？</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/9neMNd.jpeg" alt="img"></p><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ol><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li></ol><p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p><ul><li><strong>年轻代 (Young Generation)</strong></li></ul><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p><ol><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ol><ul><li><strong>老年代(Old Generation)</strong></li></ul><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p><h2 id="8-JVM中对象在堆中的生命周期"><a href="#8-JVM中对象在堆中的生命周期" class="headerlink" title="8.JVM中对象在堆中的生命周期?"></a>8.JVM中对象在堆中的生命周期?</h2><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代 <ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区 <ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） <ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h2 id="9-JVM中对象的分配过程"><a href="#9-JVM中对象的分配过程" class="headerlink" title="9.JVM中对象的分配过程?"></a>9.JVM中对象的分配过程?</h2><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li><p>new 的对象先放在伊甸园区，此区有大小限制</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p></li><li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</p></li><li><p>什么时候才会去养老区呢？ 默认是 15 次回收标记</p></li><li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</p></li><li><p>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</p></li></ol><h2 id="10-静态变量与局部变量的对比"><a href="#10-静态变量与局部变量的对比" class="headerlink" title="10.静态变量与局部变量的对比"></a>10.静态变量与局部变量的对比</h2><p>变量按照数据类型：基本数据类型和引用数据类型</p><p>变量按照类中声明位置：成员变量（类变量　ｓｔａｔｉｃ　，局部变量）　局部变量</p><p>成员变量　在使用前都经过默认赋值，ｉｎｔ显式赋值。</p><p>实例变量　随着对象创建会在堆空间中分配实例变量空间，并进行默认赋值。</p><p>局部变量显式赋值，否则没法使用。</p><p>在栈帧中，与性能调优最为密切的就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>在局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收。</p><h2 id="11-方法重写的本质"><a href="#11-方法重写的本质" class="headerlink" title="11.方法重写的本质"></a>11.方法重写的本质</h2><p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做Ｃ。</p><p>如果在类型Ｃ中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过则返回java.lang.IllegalAccessError。</p><p>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p><p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p><p><em>java.lang.IllegalAccessError</em></p><p>程序试图访问或者修改一个属性或调用一个方法，这个属性或者方法，你没有权限访问，一般的，这个会引起编译期异常，这个错误 如果发生在运行时，就说明一个类发生了不兼容的改变。</p><p><strong>补充：多态的本质就是指向同一个虚方法表的引用。</strong></p><h2 id="12-对象创建过程"><a href="#12-对象创建过程" class="headerlink" title="12.对象创建过程"></a>12.对象创建过程</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/4jwdVI.png" alt="image-20220331111041423" style="zoom:67%;" /><ol><li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li><li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li><li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li><li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li></ol><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/CsPWv6.jpeg" alt="img"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/KBdhXF.jpeg" alt="img"></p><h2 id="13-对象分配过程"><a href="#13-对象分配过程" class="headerlink" title="13.对象分配过程"></a>13.对象分配过程</h2><p>1.new的对象先放在伊甸园区，此区有大小限制。</p><p>2.当伊甸园的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区的不在被其他对象所引用的对象销毁，在加载新的对象放在伊甸园区。</p><p>3.然后将伊甸园区剩余的对象移动到幸存者0.</p><p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，接着再去幸存者1区。</p><p>5.啥时候去养老区呢？可以设置次数，默认是15次。-XX:MaxTenuringThreshold=</p><p>(伊甸园区满了会触发ygc，将幸存者区域和伊甸园区都回收一下，但是幸存者区满了不会触发垃圾回收)</p><p>总结：针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区或者元空间收集。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/ZaOcEV.jpeg" alt="img"></p><h2 id="14-类的加载过程"><a href="#14-类的加载过程" class="headerlink" title="14.类的加载过程"></a>14.类的加载过程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/BmICQh.png" alt="image-20241224100812571"></p><p>加载-&gt;链接（验证，准备，解析）-&gt;初始化</p><p>1）<strong>加载</strong></p><p>通过全限定类名加载一个类的二进制字节流，将静态结构转化为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象</p><p>加载.class文件的方式：</p><p>从本地系统中直接加载</p><p>通过网络获取，典型场景：Web Applet</p><p>从zip压缩包中读取，成为日后jar ，war格式的基础</p><p>运行时计算生成，使用最多的是：动态代理技术</p><p>其他文件生成：典型场景JSP</p><p>从专有数据库提取.class文件，比较少见</p><p>从加密文件中获取，典型的防Class文件被反编译的保护措施</p><p>2）<strong>链接</strong></p><p>1.验证：确保class文件内容不会危害到当前虚拟机</p><p>2.准备：为类变量分配内存并设置初始值，不会为实例变量分配空间初始化，类变量分配在方法区，实例变量分配在堆空间。</p><p>3.解析：将常量池的符号引用转换为直接引用</p><p>3）<strong>初始化</strong></p><p>执行类构造器方法（完成静态属性和静态代码块变量的赋值操作）的过程，此方法不需要定义，是javac完成的。</p><p>clinit()不同于类的构造器,他只会加载一次。若该类具有父类，JVM会保证子类的clinit()执行前，父类的clinit()已经执行完毕。</p><p>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。 任何一个类声明以后，内部至少存在一个类的构造器</p><h2 id="15-类加载器"><a href="#15-类加载器" class="headerlink" title="15.类加载器"></a>15.类加载器</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/n30NxU.jpeg" alt="图片" style="zoom:67%;" /><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/F2CdXl.jpeg" alt="img"></p><p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p><p>1）<strong>启动类加载器</strong></p><p>启动类加载器 BootStrap ClassLoader</p><p>加载java核心类库，只加载java javax sun开头的类</p><p>2）<strong>系统类加载器</strong></p><p>extends ClassLoader java ClassLoader.getSystemClassLoader();</p><p>加载用户自定义类，父类加载器为扩展类加载器</p><p>3）<strong>拓展类加载器</strong></p><p>extends ClassLoader java SystemClassLoader.getParent();</p><p>4）<strong>用户自定义类加载器</strong></p><p>extends ClassLoader</p><p>1.为什么要用户自定义类加载器？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">隔离加载类` `修改类加载的方式` `扩展加载源` `防止源码泄露</span><br></pre></td></tr></table></figure><p>2.用户自定义类加载器步骤？</p><p>jdk1.2之前，继承ClassLoader重写loadClass().jdk1.2之后建议重写findClass()</p><p>也可以继承URLClassLoader,避免了自己编写findClass()以及获取自己码流的方式。</p><p>3.ClassLoader</p><p>它是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">getParent()</span> <span class="string">返回父类加载器</span></span><br><span class="line"><span class="meta">loadClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">findClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">defineClass(String</span> <span class="string">name,byte[] b ,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</span></span><br></pre></td></tr></table></figure><h2 id="16-JVM类加载机制有哪些？"><a href="#16-JVM类加载机制有哪些？" class="headerlink" title="16.JVM类加载机制有哪些？"></a>16.JVM类加载机制有哪些？</h2><ol><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li><li><strong>双亲委派机制</strong>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ol><h2 id="17-双亲委派机制"><a href="#17-双亲委派机制" class="headerlink" title="17.双亲委派机制"></a>17.双亲委派机制</h2><p>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p><p>java虚拟机对class文件采用的是按需加载，而且加载某个类的class文件时，java虚拟机采用的是双亲委派机制，就是把请求交由父类加载器处理，它是一种任务委派模式</p><p>1）<strong>工作原理</strong></p><p>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</p><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器。</p><p>如果父加载器可以完成类加载任务，就成功返回，倘若父加载器无法完成此类加载任务，子加载器才会尝试自己去加载。</p><p>2）<strong>举例</strong></p><p>1.调用JDBC接口，接口是引导类加载器加载的，但是实现类是系统类加载器加载的。</p><p>2.假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>java.lang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String)，最终通过引导类加载器进行加载。</p><p>3）<strong>优点</strong></p><p>1、安全性，避免自己写的类替换掉java核心类；保护程序安全，防止核心API被随意篡改</p><p>2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p><p>4）<strong>双亲委托模式的弊端</strong></p><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><p>5）思考</p><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法,抹去其中的双亲委派机制,仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?</p><p>这也不行!因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器还是扩展类加载器，最终都必须调用java.lang.classLoader.defineClass(String,byte[], int, int, ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p><p>6）特殊情况:</p><p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p><p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h2 id="18-破坏双亲委派机制"><a href="#18-破坏双亲委派机制" class="headerlink" title="18.破坏双亲委派机制"></a>18.破坏双亲委派机制</h2><p>①破坏双亲委派机制1</p><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><p><strong>第一次破坏双亲委派机制:</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><p>不仅<strong>要继承ClassLoader</strong>类，还要<strong>重写loadClass和findClass</strong>方法</p><p>②破坏双亲委派机制2</p><p>第二次破坏双亲委派机制:线程上下文类加载器</p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题〈越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码,那该怎么办呢?</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的)，肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的NDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?(SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计:线程上下文类加载器（Thread ContextClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如NDI、JDBC、JCE、JAXB和BT等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/DWQ5xc.jpeg" alt="img"></p><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><p>③破坏双亲委派机制3</p><p>第三次破坏双亲委派机制:</p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换（Hot Swap)、模块热部署（Hot Deployment）等</p><p>IBM公司主导的JSR-291(即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:（不细讲）</p><p>1）将以java.*开头的类，委派给父类加载器加载。</p><p>2）否则，将委派列表名单内的类，委派给父类加载器加载。</p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p><p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p><p>7）否则，类查找失败。</p><p>说明:只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结:</p><p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如:OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</p><h2 id="19-热替换的实现"><a href="#19-热替换的实现" class="headerlink" title="19.热替换的实现"></a>19.热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如: PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重新定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p>注意:由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同个类，在虚拟机内部，会认为这2个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/2021032601270166.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><h2 id="20-Class-forName-和ClassLoader-loadClass-区别"><a href="#20-Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="20.Class.forName()和ClassLoader.loadClass()区别?"></a>20.Class.forName()和ClassLoader.loadClass()区别?</h2><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul><h2 id="21-什么是-TLAB-（Thread-Local-Allocation-Buffer）"><a href="#21-什么是-TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="21.什么是 TLAB （Thread Local Allocation Buffer）?"></a>21.什么是 TLAB （Thread Local Allocation Buffer）?</h2><ul><li><p>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/FYl0lQ.jpeg" alt="img"></p></li><li><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></p></li><li><p>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</p></li></ul><h2 id="22-为什么要有-TLAB"><a href="#22-为什么要有-TLAB" class="headerlink" title="22.为什么要有 TLAB ?"></a>22.为什么要有 TLAB ?</h2><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/4HQcAo.jpeg" alt="img"></p><h2 id="23-ClassLoader源码解析"><a href="#23-ClassLoader源码解析" class="headerlink" title="23.ClassLoader源码解析"></a>23.ClassLoader源码解析</h2><p><code>ClassLoader</code> 与现有类加载的关系：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/MibqQF.jpeg" alt="img"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 <code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承 <code>ClassLoader</code> 类。</p><h3 id="1）ClassLoader的主要方法"><a href="#1）ClassLoader的主要方法" class="headerlink" title="1）ClassLoader的主要方法"></a>1）ClassLoader的主要方法</h3><p><code>public final ClassLoader getParent()</code>返回该类加载器的超类加载器</p><p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回<code>ClassNotFoundException</code>异常。</p><p>该方法中的逻辑就是双亲委派模式的实现。</p><p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写<code>loadClass</code>方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中，从前面的分析可知， <code>findClass()</code>方法是在l<code>oadClass()</code>方法中被调用的，当<code>loadClass()</code>方法中父加载器加载失败后，则会调用自己的<code>findClass()</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是<code>ClassLoader</code>类中并没有实现<code>findClass()</code>方法的具体代码逻辑，取而代之的是抛出<code>ClassNotFoundException</code>异常，同时应该知道的是<code>findClass</code>方法通常是和<code>defineClass</code>方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p><p><code>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</code>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义<code>ClassLoader</code>子类中可以使用。</p><p><code>defineClass()</code>方法是用来将byte字节流解析成<code>JVM</code>能够识别的Class对象(<code>ClassLoader</code>中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p><p><code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader的findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 编写findClass方法的逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的class文件字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>protected final void resolveClass(Class&lt;?&gt; c)</code>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析(即加载的同时也进行解析)。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>查找名称为name的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例。这个方法是final方法，无法被修改。</p><p><code>private final ClassLoader parent</code>它也是一个<code>ClassLoader</code>的实例，这个字段所表示的<code>ClassLoader</code>也称为这个<code>ClassLoader</code>的双亲。在类加载的过程中,<code>ClassLoader</code>可能会将某些请求交予自己的双亲处理。</p><h4 id="①loadClass-的剖析"><a href="#①loadClass-的剖析" class="headerlink" title="①loadClass()的剖析"></a>①loadClass()的剖析</h4><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguig.java.User&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>涉及到对如下方法的调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve:true-加载class的同时进行解析操作。</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">       <span class="comment">//首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器。</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载（递归）</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//parent为null:父类加载器是引导类加教器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//当前类的加载器的父类加载器未加载此类or此类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//调用当前ClassLoader的findClass()</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）SecureClassLoader与URLClassLoader"><a href="#2）SecureClassLoader与URLClassLoader" class="headerlink" title="2）SecureClassLoader与URLClassLoader"></a>2）SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/jkfwPx.jpeg" alt="img"></p><h3 id="3）ExtClassLoader与AppClassLoader"><a href="#3）ExtClassLoader与AppClassLoader" class="headerlink" title="3）ExtClassLoader与AppClassLoader"></a>3）ExtClassLoader与AppClassLoader</h3><p>了解完<code>URLClassLoader</code>后接着看看剩余的两个类加载器，即拓展类加载器<code>ExtClassLoader</code>和系统类加载<code>AppClassLoader</code>，这两个类都继承自<code>URLClassLoader</code>，是<code>sun.misc.Launcher</code>的静态内部类。</p><p><code>sun.misc.Launcher</code>主要被系统用于启动主应用程序，<code>ExtClassLoader</code>和<code>AppClassLoader</code>都是由<code>sun.misc.Launcher</code>创建的，其类主要类结构如下:</p><p><img src="https://img-blog.csdnimg.cn/20210326012558316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>我们发现<code>ExtClassLoader</code>并没有重写<code>loadClass()</code>方法，这足矣说明其遵循双亲委派模式，而<code>AppClassLoader</code>重载了<code>loadclass()</code>方法，但最终调用的还是父类<code>loadClass()</code>方法，因此依然遵守双亲委派模式。</p><h3 id="4）Class-forName与ClassLoader-loadClass"><a href="#4）Class-forName与ClassLoader-loadClass" class="headerlink" title="4）Class.forName与ClassLoader.loadClass()"></a>4）Class.forName与ClassLoader.loadClass()</h3><p><code>Class.forName()</code>:是一个静态方法,最常用的是<code>Class.forName(String className);</code>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时,会执行类的初始化。</p><p>如:<code>Class.forName( &quot;com.atguigu.java.Helloworld&quot;) ;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.loadClass()`:这是一个实例方法,需要一个`ClassLoader`对象来调用该方法。该方法将class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化。该方法因为需要得到个`ClassLoader`对象,所以可以根据需要指定使用哪个类加载器.如: `ClassLoader cl=......;</span><br><span class="line">cl.loadClass (&quot;com.atguigu.java.Helloworld&quot; );</span><br></pre></td></tr></table></figure><h2 id="24-类加载器Java9新特性"><a href="#24-类加载器Java9新特性" class="headerlink" title="24.类加载器Java9新特性"></a>24.类加载器Java9新特性</h2><p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><p>1.扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform classloader)。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</p><p>JDK 9时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HONE>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p><p>2.平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</p><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/3EVRSl.jpeg" alt="img"></p><p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在 JDK9及更高版本的JDK中崩溃。</p><p>3.在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p><p>4.启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器〈以前是C++实现)，但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</p><p>5.类加载的委派关系也发生了变动。</p><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/WDjLwL.png" alt="image-20241224110158151"></p><p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块。</p><h2 id="25-两种类装载方式"><a href="#25-两种类装载方式" class="headerlink" title="25.两种类装载方式"></a>25.两种类装载方式</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种 ：</p><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h2 id="26-深拷贝和浅拷贝"><a href="#26-深拷贝和浅拷贝" class="headerlink" title="26.深拷贝和浅拷贝"></a>26.深拷贝和浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。</p><h2 id="27-对象创建的几种方式"><a href="#27-对象创建的几种方式" class="headerlink" title="27.对象创建的几种方式"></a>27.对象创建的几种方式</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/PllR3d.png" alt="image-20241224112935380"></p><h2 id="28-为对象分配内存两种方式"><a href="#28-为对象分配内存两种方式" class="headerlink" title="28.为对象分配内存两种方式"></a>28.为对象分配内存两种方式</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p><ul><li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li><li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li></ul><p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/WGOpjX.png" alt="内存分配的两种方式"></p><h2 id="29-对象的创建过程中处理并发安全问题"><a href="#29-对象的创建过程中处理并发安全问题" class="headerlink" title="29.对象的创建过程中处理并发安全问题"></a>29.对象的创建过程中处理并发安全问题</h2><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><ul><li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li></ul><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/jfM1F2.png" alt="内存分配时保证线程安全的两种方式"></p><h2 id="30-介绍一下强引用、软引用、弱引用、虚引用的区别？"><a href="#30-介绍一下强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="30.介绍一下强引用、软引用、弱引用、虚引用的区别？"></a>30.介绍一下强引用、软引用、弱引用、虚引用的区别？</h2><p>1）强引用</p><p>我们平时new了一个对象就是强引用，例如 Object obj = new Object();</p><p>即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p><p>2）软引用</p><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);     <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure><p><strong>用处：</strong> 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p><p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = <span class="keyword">new</span> Browser();               <span class="comment">// 获取页面进行浏览</span></span><br><span class="line">SoftReference sr = <span class="keyword">new</span> SoftReference(prev); <span class="comment">// 浏览完毕后置为软引用        </span></span><br><span class="line"><span class="keyword">if</span>(sr.get()!=<span class="keyword">null</span>)&#123; </span><br><span class="line">    rev = (Browser) sr.get();           <span class="comment">// 还没有被回收器回收，直接获取</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    prev = <span class="keyword">new</span> Browser();               <span class="comment">// 由于内存吃紧，所以对软引用的对象回收了</span></span><br><span class="line">    sr = <span class="keyword">new</span> SoftReference(prev);       <span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）弱引用</p><p>具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br><span class="line">等价于</span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>4）虚引用</p><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><h2 id="31-怎么判断对象是否可以被回收？"><a href="#31-怎么判断对象是否可以被回收？" class="headerlink" title="31.怎么判断对象是否可以被回收？"></a>31.怎么判断对象是否可以被回收？</h2><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p><p>一般有两种方法来判断：</p><ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h2 id="32-在Java中，对象什么时候可以被垃圾回收"><a href="#32-在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="32.在Java中，对象什么时候可以被垃圾回收"></a>32.在Java中，对象什么时候可以被垃圾回收</h2><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h2 id="33-JVM-运行时堆内存如何分代"><a href="#33-JVM-运行时堆内存如何分代" class="headerlink" title="33.JVM 运行时堆内存如何分代?"></a>33.JVM 运行时堆内存如何分代?</h2><p>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/r0bGp6.png" alt="image-20241224141523427"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/2fLuAO.png" alt="image-20241224141540105"></p><p>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。</p><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 <strong>1:2</strong> ( 该值可以通过参数 –XX:NewRatio 来指定 )，</p><p>即：<strong>新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小</strong>。</p><p>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分</p><p>默认的，<strong>Eden: from : to = 8 :1 : 1</strong> ( 可以通过参数<strong>–XX:SurvivorRatio</strong> 来设定 )，即： <strong>Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小</strong>。</p><p>JVM <strong>每次只会使用 Eden 和其中的一块 Survivor 区域</strong>来为对象服务，所以<strong>无论什么时候，总是有一块Survivor区域是空闲着的</strong>。</p><p>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p><p><strong>新生代</strong></p><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。<br><strong>Eden 区</strong><br>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。<br><strong>Servivor from 区</strong><br>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。<br><strong>Servivor to 区</strong><br>保留了一次 MinorGC 过程中的幸存者。<br><strong>MinorGC 的过程（复制-&gt;清空-&gt;互换）</strong><br>MinorGC 采用复制算法。</p><ol><li>eden、 servicorFrom 复制到 ServicorTo，年龄+1<br>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</li><li>清空 eden、 servicorFrom<br>然后，清空 Eden 和 ServicorFrom 中的对象；</li><li>ServicorTo 和 ServicorFrom 互换<br>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</li></ol><p><strong>老年代</strong></p><p>主要存放应用程序中生命周期长的内存对象。<br>老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。<br>FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><p><strong>永久代</strong></p><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h2 id="34-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor"><a href="#34-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor" class="headerlink" title="34.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor"></a>34.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor</h2><p>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p><p>1）共享内存区划分</p><ul><li>共享内存区 = 持久带 + 堆</li><li>持久带 = 方法区 + 其他</li><li>Java堆 = 老年代 + 新生代</li><li>新生代 = Eden + S0 + S1</li></ul><p>2）一些参数的配置</p><ul><li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。</li><li>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)</li><li>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</li></ul><h2 id="35-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#35-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="35.为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>35.为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h2><ul><li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</li><li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li><li>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</li></ul><h2 id="36-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#36-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="36.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>36.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h2><p>先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。</p><ul><li>Java堆 = 老年代 + 新生代</li><li>新生代 = Eden + S0 + S1</li><li>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</li><li><strong>大对象</strong>（需要大量连续内存空间的Java对象，如那种很长的字符串）<strong>直接进入老年态</strong>；</li><li>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，<strong>若年龄超过一定限制（15），则被晋升到老年态</strong>。即<strong>长期存活的对象进入老年态</strong>。</li><li>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和年老代</strong>。</li><li>Major GC <strong>发生在老年代的GC</strong>，<strong>清理老年区</strong>，经常会伴随至少一次Minor GC，<strong>比Minor GC慢10倍以上</strong>。</li></ul><h2 id="37-JVM中的永久代中会发生垃圾回收吗"><a href="#37-JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="37.JVM中的永久代中会发生垃圾回收吗"></a>37.JVM中的永久代中会发生垃圾回收吗</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h2 id="38-JAVA8-与元数据"><a href="#38-JAVA8-与元数据" class="headerlink" title="38.JAVA8 与元数据"></a>38.JAVA8 与元数据</h2><p>在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入native memory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制</p><h2 id="39-如何判断对象可以被回收？"><a href="#39-如何判断对象可以被回收？" class="headerlink" title="39.如何判断对象可以被回收？"></a>39.如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：</p><ul><li>引用计数：</li></ul><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p><ul><li>可达性分析（Reachability Analysis）：</li></ul><p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p><h2 id="40-引用计数法"><a href="#40-引用计数法" class="headerlink" title="40.引用计数法"></a>40.引用计数法</h2><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p><h2 id="41-可达性分析"><a href="#41-可达性分析" class="headerlink" title="41.可达性分析"></a>41.可达性分析</h2><p>为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h2 id="42-Minor-GC与Full-GC分别在什么时候发生？"><a href="#42-Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="42.Minor GC与Full GC分别在什么时候发生？"></a>42.Minor GC与Full GC分别在什么时候发生？</h2><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p><h2 id="43-标记清除算法"><a href="#43-标记清除算法" class="headerlink" title="43.标记清除算法"></a>43.标记清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法，复制算法，标记-压缩算法。</p><p>当堆中的有效内存空间被耗尽时，就会停止整个程序，然后进行两项工作，第一项是标记，第二项则是清除。</p><p>标记：从引用跟节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p><p>清除：对堆内存从头到尾进行线性遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收。</p><p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，存活对象比较多的情况下极为高效。</p><p>缺点：标记和清除过程的效率都不高，这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小，对空闲列表的管理会增加分配对象时的工作量；标记清除后会产生大量不连续的内存碎片，虽然空闲区域的大小是足够的，但却可能没有一个单一的区域能满足这次分配所需大小，分配还会失败，不得不触发再一次的垃圾回收。</p><p>何为清除：<strong>所谓清除，并不是并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新的对象需要加载时，判断垃圾的位置空间是够够，够就存放</strong>。</p><h2 id="44-标记整理算法"><a href="#44-标记整理算法" class="headerlink" title="44.标记整理算法"></a>44.标记整理算法</h2><p>算法标记的过程与标记清除算法中的标记过程一样，但是对标记后出的垃圾对象的处理情况有所不同，他不是直接对可回收对象进行清理，而是让所有的对象都像一端移动，然后直接清理掉端边界以外的内存。在基于标记整理算法的收集齐实现中，一般增加句柄和句柄表。</p><p>优点：经过整理之后，新对象的分配只需要通过指针碰撞便能完成，比较简单；使用这种方法，空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p><p>缺点：ＧＣ暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新他们的引用地址。</p><h2 id="45-复制算法"><a href="#45-复制算法" class="headerlink" title="45.复制算法"></a>45.复制算法</h2><p>复制算法主要是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按照容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还活着的对象复制到另一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p><p>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低。所以老年代一般会选用其他算法，如标记整理算法。一种典型的基于复制算法的垃圾回收是<code>stop-and-copy</code>算法，他将堆分为对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。</p><p>优点：标记阶段和复制阶段可以同时进行，每次只对一块内存进行回收，运行高效，只需要移动栈顶指针，按顺序分配内存即可，实现简单，内存回收时，不用考虑内存碎片的出现。</p><p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p><h2 id="46-分代收集算法"><a href="#46-分代收集算法" class="headerlink" title="46.分代收集算法"></a>46.分代收集算法</h2><p>将堆内存划分为新生代，老年代和永久代。新生代又被进一步划分为伊甸园区和幸存者0，幸存者1区。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xms和-Xmx来控制。分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收，以便提高回收效率。</p><p>新生代：几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。新生代大小可以由<code>-Xmn</code>来控制，也可以用<code>-XX:SurvivorRatio</code>来控制 Eden 和 Survivor 的比例。</p><p>老年代：在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。</p><p>永久代：用于存放静态文件（<code>class</code>类、方法）和常量等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些<code>class</code>，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。永久代在 Java SE8 特性中已经被移除了，取而代之的是元空间（<code>MetaSpace</code>），因此也不会再出现<code>java.lang.OutOfMemoryError: PermGen error</code>的错误了。</p><p>特别的，在分代收集算法中，对象的存储具有以下特点：</p><p>1.对象优先在伊甸园区分配</p><p>2.大对象直接进入老年代</p><p>3.长期存活的对象将进入老年代，默认为15岁</p><p>对于晋升老年代的年龄阈值，为什么是15岁？</p><p>实际上，HotSpot虚拟机的对象头其中一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称为<code>mark word</code>。在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么<code>Mark Word</code>的 32bit 空间中 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，其中对象的分代年龄占 4 位，也就是从<code>0000</code>到<code>1111</code>，而其值最大为 15，所以分代年龄也就不可能超过 15 这个数值了。</p><p><strong>GC的分类</strong></p><p>新生代GC Minor GC ：发生在新生代的垃圾收集动作，因为java对象大多具有朝生夕灭的特性，因此MinorGC非常频繁，一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可以选用复制算法。</p><p>老年代GC Major GC：发生在老年代的垃圾回收动作。Major GC 经常会伴随至少一次Minor GC。由于老年代中的对象的生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了之后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”算法或“标记-整理”算法来进行回收。新生代采用空闲指针的方式来控制 GC 触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发 GC。当连续分配对象时，对象会逐渐从 Eden 到 Survivor，最后到老年代。</p><h2 id="47-增量收集算法"><a href="#47-增量收集算法" class="headerlink" title="47.增量收集算法"></a>47.增量收集算法</h2><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种STW的状态，在该状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统稳定性。为了解决这个问题，即对实时垃圾收集算法的亚久直接导致增量收集算法的产生。</p><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程 和应用程序线程交替执行。每次，垃圾收集线程值收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，一直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或复制工作。</p><p>缺点：线程切换和上下文的转换消耗性能，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p><h2 id="48-分区算法"><a href="#48-分区算法" class="headerlink" title="48.分区算法"></a>48.分区算法</h2><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小空间。每一个小空间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><h2 id="55-垃圾判断算法"><a href="#55-垃圾判断算法" class="headerlink" title="55.垃圾判断算法"></a>55.垃圾判断算法</h2><p>１）引用计数法</p><p>在这种算法中，假设堆中每个对象都有一个引用计数器。当一个对象被创建并且初始化赋值以后，对象的计数器就会设置为１，每当有一个地方引用他，计数器的值就会＋１，例如将对象Ｂ赋值给对象Ａ，那么Ｂ被引用，Ｂ的引用计数器就会＋１.</p><p>反之，当引用失效的时候，比如一个对象的某个引用被设置了新的值，则之前被引用的对象的计数器就会－１.而那些引用计数为０的对象，就可以称之为垃圾，可以被收集。</p><p>特别的，当一个对象被当做垃圾收集时，他引用的任何对象的计数器的值都－１.</p><p>优点：实现简单，对程序不被长时间打断的实时环境比较有利</p><p>缺点：需要额外的空间来存储计数器，难以检测对象之间的循环依赖</p><p>java并没有选择引用计数，是因为其存在一个基本难题，也就是很难处理循环引用关系。</p><p>Python如何解决循环引用？手动解决（在合适的时机，接触引用关系）使用弱引用weakref（weakref是Python提供的标准库，为了解决循环依赖）</p><p>２）可达性分析算法</p><p>可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。</p><p>对象成为可达对象的两个条件：</p><p>对象属于跟集中的对象　　　　　对象被一个可达的对象引用</p><h2 id="56-在java语言中，GC-ROOTS-包括以下几类元素："><a href="#56-在java语言中，GC-ROOTS-包括以下几类元素：" class="headerlink" title="56.在java语言中，GC ROOTS 包括以下几类元素："></a>56.在java语言中，GC ROOTS 包括以下几类元素：</h2><p>虚拟机栈中引用的对象（各个线程被调用的方法中使用到的参数，局部变量等）</p><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p><p>方法区中类静态属性引用的对象（java类的引用类型静态变量）</p><p>方法区中常量引用的对象（字符串常量池（String Table）里的引用）</p><p>所有被同步锁synchronized持有的对象</p><p>java虚拟机内部的引用（基本数据类型对应的class对象，一些常驻的异常对象，系统类加载器）</p><p>本地代码缓存</p><p>临时的（分代收集，局部回收）</p><p><strong>如何判断一个root</strong></p><p>由于root采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那他就是一个root。</p><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须<code>Stop the World</code>的一个重要原因。</p><p>优点：可以解决循环引用的问题，不需要占用额外的空间</p><p>缺点：多线程场景下，其他线程可能会更新已经访问过的对象的引用。</p><h2 id="57-Minor-GC-Major-GC-fULL-GC"><a href="#57-Minor-GC-Major-GC-fULL-GC" class="headerlink" title="57.Minor GC,Major GC,fULL GC"></a>57.Minor GC,Major GC,fULL GC</h2><p>jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分回收都是指新生代。</p><p>针对hotSpotVM的实现，它里面的GC按照回收区域分为两大类型：一种是部分收集，一种是FullGC</p><p>1.部分收集：不是完整收集整个Java堆的垃圾回收，又分为：</p><p>1）新生代收集Minor GC：只是新生代的垃圾收集</p><p>2）老年代收集Major GC：只是老年代的垃圾收集</p><p>目前只有CMSGC拥有单独收集老年代的行为，很多时候Minor GC会和FullGC混淆使用，需要具体分辨老年代回收还是整堆回收。</p><p>3）混合收集：收集整个新生代以及部分老年代的垃圾</p><p>2.整堆收集：收集整个java堆和方法区的垃圾</p><h2 id="58-分代式GC策略触发条件"><a href="#58-分代式GC策略触发条件" class="headerlink" title="58.分代式GC策略触发条件"></a>58.分代式GC策略触发条件</h2><p>1）<strong>年轻代触发机制</strong></p><p>1.当年轻代空间不足时，就会出发minorGC，这里的年轻代指的是Eden满，Survivor满不会触发GC</p><p>2.因为java对象大多数存活时间比较短暂，所以MinorGC非常频繁，一般回收速度也比较快。</p><p>3.MinorGC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/goXjGG.png" alt="image-20241224143345938"></p><p>2）<strong>老年代GC触发机制</strong></p><p>1.指的是发生在老年代的GC，对象从老年代消失时，我们说的MajorGC和FullGC发生了。</p><p>2.出现了MajorGC，经常会伴随至少一次的MinorGC，也就是在老年代空间不足的时候，会先尝试触发minorGC，如果之后空间还是不足，则会触发MajorGC。</p><p>3.MajorGC的速度一般会比MinorGC慢10倍以上，STW时间更长。</p><p>4.如果MajorGC后，内存还是不足，就会OOM。</p><p>3）<strong>FullGC触发条件</strong></p><p>1.System.gc() 不是一定执行的。</p><p>2.老年代空间不足</p><p>3.方法区空间不足</p><p>4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</p><p>5.Eden区，survivor0 区向survivor1区复制时，对象大小大于To Space可用区域，则把该对象转存到老年代，且老年代的可用内存小于该对象的内存就会触发GC。</p><p>Full GC是开发或者调优中尽量要避免的，这样暂停时间会短一些。</p><h2 id="59-从逃逸分析角度分析对象内存分配"><a href="#59-从逃逸分析角度分析对象内存分配" class="headerlink" title="59.从逃逸分析角度分析对象内存分配"></a>59.从逃逸分析角度分析对象内存分配</h2><p>1）堆是分配对象存储的唯一选择嘛？</p><p>在java虚拟机中，对象在java堆中分配内存的，这是一个普遍的常识。但是有一个特殊的情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能优化成栈上分配。这样就无需再堆上分配内存，也无须进行垃圾回收了。这是最常见的堆外存储技术。</p><p>2）逃逸分析</p><p>1.如果将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>2.这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>3.通过逃逸分析，hotspot编译器能够分析出一个新的对象的引用的适用范围从而决定是否要将这个对象分配到堆上。</p><p>4.逃逸分析的基本行为就是分析对象动态作用域：</p><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p><p>5.没有发生逃逸的对象，则可以分配到栈上，随着方法的执行结束，栈空间就被移除，栈空间指向堆空间对象的引用就没了，等到年轻代GC，对象就会被回收。</p><p>3）补充</p><p>其实主要就是解决了循环引用，没有逃逸分析，这个对象可能一直不被回收，但是有了逃逸分析，栈帧销毁，这个对象就是垃圾了。</p><h2 id="60-使用逃逸分析堆代码进行优化"><a href="#60-使用逃逸分析堆代码进行优化" class="headerlink" title="60.使用逃逸分析堆代码进行优化"></a>60.使用逃逸分析堆代码进行优化</h2><p>1）栈上分配</p><p>将堆分配转换为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束后，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见的栈上分配场景：在逃逸分析中，已经说明了。分别是给成员变量赋值，方法返回值，实例引用传递。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis //默认开启</span><br></pre></td></tr></table></figure><p>2）同步省略</p><p>如果一个对象被发现只能从一个线程被访问到，那么这个对象的操作可以不考虑同步。线程同步的代价是相当高的，同步的后果是降低并发和性能。在动态编译同步代码块的时候，jit编译器可以借助逃逸分析来判断同步块所使用的锁的对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性能，这个取消的性能就叫做同步省略，也叫锁消除。</p><p>3）分离对象或标量替换</p><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不存储在内存，而是存储在CPU寄存器中</p><p>1.标量是指一个无法在分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量，java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p>2.标量替换的参数设置</p><p>参数-XX：+EliminateAllocations开启了标量替换，允许将对象打散分配在栈上。</p><p>3.逃逸分析技术并不成熟，其根本原因就是无法保证逃逸分析的性能消耗一定高于他的消耗。虽然经过逃逸分析可以做标量替换，栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程，虽然并不成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><p><strong>通过逃逸分析，jvm会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于jvm设计者的选择。HotSpot虚拟机中并未这么做，所以可以明确所有的对象实力都是创建在堆上。</strong></p><p>intern字符串的缓存和静态变量曾经都被分配到永久带上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配 ，所以这一点同样符合前面的一点结论：对象实例都是分配在堆上。</p><h2 id="61-垃圾回收分类"><a href="#61-垃圾回收分类" class="headerlink" title="61.垃圾回收分类"></a>61.垃圾回收分类</h2><p>按照垃圾回收线程分：串行垃圾回收器和并行垃圾回收器</p><p>串行回收是指在同一时间段内只允许有一个cpu执行垃圾回收操作，此时工作线程被暂停，直至垃圾回收结束。</p><p>并行则是允许运用多个cpu同时执行垃圾回收操作。</p><p>按照工作模式分：并发式垃圾回收器和独占式垃圾回收器</p><p>并发式垃圾回收器与应用程序线程交替，尽可能减少应用程序暂停时间。</p><p>独占式垃圾回收器一旦运行，就禁止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</p><p>按照碎片处理方式分类，压缩垃圾回收器和非压缩垃圾回收器</p><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p><p>非压缩式的垃圾回收器不进行这步操作。</p><p>按照工作的内存区间分：又可分为年轻代的垃圾回收器和老年代的垃圾回收器。</p><h2 id="62-评估GC的性能指标"><a href="#62-评估GC的性能指标" class="headerlink" title="62.评估GC的性能指标"></a>62.评估GC的性能指标</h2><p>吞吐量：运行用户代码的时间占总运行时间的比例。（总运行时间=程序运行时间+垃圾回收时间）</p><p>暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间。</p><p>收集频率：相对于应用程序的执行，收集发生的频率。</p><p>内存占用：java堆区所占内存大小。</p><p>三者总体表现会随着技术进步越来越好，主要抓住两点：吞吐量和暂停时间。</p><p>如果以吞吐量优先，那么必然需要降低内存回收的执行效率，但是这样会导致GC需要更长的时间来执行内存回收。如果选择低延迟优先，为了降低每次内存回收时的暂停时间，也只能频繁的执行内存回收，但又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p><p>标准：在最大吞吐量优先的情况下，降低停顿时间。</p><h2 id="63-不同的垃圾回收器概述"><a href="#63-不同的垃圾回收器概述" class="headerlink" title="63.不同的垃圾回收器概述"></a>63.不同的垃圾回收器概述</h2><p>1）垃圾收集器发展历史</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.3发布Serial GC 他是第一款GC。ParNew是Serial 的多线程版本。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.4发布Parallel GC 和 Concurrent Mark Sweep GC。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK6之后Parallel GC称为HotSpot默认垃圾回收器。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.7引入G1。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK9把G1变为默认垃圾收集器，替代CMS。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK10中G1垃圾收集器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK11引入Epsilon GC。同时引入ZGC。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK12增强G1，自动返回未使用堆内存给操作系统，同时引入Shenandoah GC。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK13增强ZGC。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK14删除CMS，并拓展ZGC的平台兼容性。</span><br></pre></td></tr></table></figure><p>2）垃圾收集器分类</p><p>串行回收器：<code>Serial，Serial Old</code></p><p>并行回收器：<code>ParNew，Parallel Scavenge，Parallel Old</code></p><p>并发回收器：<code>CMS,Gl</code></p><p>新生代收集器：<code>Serial，ParNew，Parallel Scavenge</code></p><p>老年代收集器：<code>Serial Old，Parallel Old，CMS</code></p><p>整堆收集器：<code>G1</code></p><p><strong>为什么要有很多收集器？</strong></p><p>因为java使用场景很多，移动端，服务端等。所以就需要针对不同的场景，提供不同的垃圾回收器，提高垃圾收集的性能。</p><p>对垃圾收集器进行比较只是对具体应用场景选择最合适的收集器。</p><p><strong>如何查看默认的垃圾收集器？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags  查看命令行相关参数（包含垃圾收集器）</span><br><span class="line"></span><br><span class="line">使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</span><br><span class="line"></span><br><span class="line">Parallel Scavenge 和 Parallel Old</span><br></pre></td></tr></table></figure><h2 id="64-Serial-回收器（串行回收器）"><a href="#64-Serial-回收器（串行回收器）" class="headerlink" title="64.Serial 回收器（串行回收器）"></a>64.Serial 回收器（串行回收器）</h2><p>jdk1.3之前回收新生代的唯一选择（HotSpot在Client模式下的默认新生代垃圾收集器）</p><p>Serial 收集器采用复制算法，串行回收和STW机制的方式执行内存回收。</p><p>除了年轻代，Serial收集器还提供用于执行老年代垃圾回收的Serial Old收集器。Serial Old 收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法。</p><p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。</p><p>Serial Old在Server模式下主要有两个用途：1.与新生代的Parallel Scavenge配合使用 2.作为老年代CMS收集器的后备垃圾收集方案。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/lwcN7o.jpeg" alt="img"></p><p>这个收集器是一个单线程的收集器，但他的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到他收集结束。</p><p>优势：简单而高效，对于限定单个CPU的环境来讲，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。（运行在Client模式下的虚拟机是个不错的选择）</p><p>在HotSpot虚拟机中，使用<code>-XX:UseSerialGC</code> 参数可以指定年轻代和老年代都是用串行收集器。（等价于新生代使用Serial GC，老年代使用Serial Old GC），一般在java web程序中是不会使用这种垃圾回收器的。</p><h2 id="65-ParNew回收器（并行回收）"><a href="#65-ParNew回收器（并行回收）" class="headerlink" title="65.ParNew回收器（并行回收）"></a>65.ParNew回收器（并行回收）</h2><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。（Par是Parallel的缩写 New只能处理新生代）</p><p>ParNew收集器除了采用并行回收方式执行内存回收外，两款垃圾收集器之间几乎没有差别，也是STW，也是复制算法。</p><p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/21K01T.jpeg" alt="img"></p><p>对于新生代，回收次数频繁，使用并行高效。对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p><p>由于ParNew收集器是并行回收，那么是否可以断定在任何场景下他的回收效率都比Serial收集器更高效？</p><p>1.多核系统下，充分利用系统资源，可以快速完成垃圾收集，提升程序吞吐量。</p><p>2.但是单个CPU下，他不一定有Serial收集器更高效。避免了线程切换。</p><p><strong>除了Serial 外，目前只有ParNew 能与CMS收集器配合工作。</strong></p><p>在程序中，开发人员可以通过选项<code>-XX:UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务 。他表示年轻代使用并行收集器并不影响老年代。</p><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数相同的线程数。</p><h2 id="66-Parallel-Scavenge-回收器（吞吐量优先）"><a href="#66-Parallel-Scavenge-回收器（吞吐量优先）" class="headerlink" title="66.Parallel Scavenge 回收器（吞吐量优先）"></a>66.Parallel Scavenge 回收器（吞吐量优先）</h2><p>1）概述</p><p>HotSpot的年轻代除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法，并行回收和STW机制。</p><p>那么他的出现是否多此一举呢？</p><p>1.和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，他也被称为吞吐量优先的垃圾收集器。</p><p>2.自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p><p>高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：那些执行批量处理，订单处理，工资支付，科学计算的应用程序。</p><p>Parallel 收集器在jdk1.6的时候提供了用于执行老年代垃圾搜集的Parallel Old收集器，用来替代老年代的Serial Old收集器。Parallel Old收集器采用了标记-压缩算法，但是同样也是基于并行回收和STW机制。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/CwEK5R.png" alt="image-20241224145425458"></p><p>在程序吞吐量优先的场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾回收器。</p><p>2）参数配置</p><p><code>-XX:UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收器。（分别适用于新生代和老年代。默认是JDK8开启的）</p><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般的最好与CPU数量相等，避免线程数影响收集器性能。（默认情况下，CPU数小于8，ParallelGCThreads的值等于CPU数量，当cpu数大于8个的时候，ParallelGCThreads值=3+[5*cpu数]/8 ）</p><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（STW的时间，单位是ms）</p><p>为了尽可能把停顿时间控制在<code>MaxGCPauseMills</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于用户来讲，停顿时间越短，体验越好。但是在服务器端，我们注重高并发，整体的吞吐量，所以服务端适合Parallel，进行控制。（该参数谨慎使用）</p><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间比例（=1/(N+1)）用于衡量吞吐量大小。</p><p><code>-XX:UseAdaptiveSizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略</p><p>在这种模式下，年轻代的大小，Eden和幸存者的比例，晋升老年代的对象年龄等参数会被自动调整，已经达到在堆大小，吞吐量和停顿时间之间的平衡点。</p><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅仅指定虚拟机的最大堆，目标吞吐量和停顿时间，让虚拟机自己完成调优工作。</p><h2 id="67-CMS回收器（低延迟）"><a href="#67-CMS回收器（低延迟）" class="headerlink" title="67.CMS回收器（低延迟）"></a>67.CMS回收器（低延迟）</h2><p>1）概述</p><p>JDK1.5，这款收集器是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短就越适合于用户交互的程序，良好的响应速度能提升用户体验。</p><p>目前很大一部分的java应用集中在互联网或者B/S架构系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停段时间最短，以给用户较好的体验感。</p><p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会STW。</strong></p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Parial收集器中的一个。</p><p>在G1出现之前，CMS还是非常广泛的，一直到今天，仍然有许多系统使用CMS GC。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/XZSksi.jpeg" alt="img"></p><p>2）CMS工作流程</p><p><strong>初始标记</strong>：标记出GCROOTS能直接关联到的对象（速度快）</p><p><strong>并发标记</strong>：从GCROOTS的直接关联对象开始遍历整个对象图的过程（耗时长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行）</p><p><strong>重新标记</strong>：修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（时间比初始标记稍微长）</p><p><strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。（由于不需要移动存活的对象，所以这个阶段也是可以与用户线程并发执行的）</p><p>初始化标记和再次标记仍然要STW机制，目前所有的来收集器都做不到完全不需要STW，只是尽可能的缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>在CMS回收过程中，还应该确保应用程序线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序在运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动预备方案，临时启动Serial Old收集器来重新收集老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS的垃圾收集算法使用的是标记清除算法，不可避免的会产生内存碎片，无法使用指针碰撞，只能选择空闲列表。</p><p>标记清除算法会造成内存碎片，为什么不把算法换成标记整理算法呢？</p><p>因为当并发清除时，用标记整理算法整理内存的话，原来的用户线程使用的内存无法继续使用，要保证用户线程还能继续执行，前提是他运行的资源不受影响。</p><p>优点：并发收集，低延迟</p><p>缺点：会产生内存碎片，对CPU资源敏感（并发阶段，占用了一部分线程导致应用程序变慢，总吞吐量降低），无法处理浮动垃圾（在并发阶段如果产生新的垃圾对象，CMS无法对这些垃圾对象进行标记，最终会导致这些新产生 的垃圾对象没有及时回收，只能在下一次GC的时候释放这些之前未被回收的内存空间）</p><p>3）参数设置</p><p><code>-XX:+UseConcMarkSweepGC</code>  手动指定使用CMS收集器执行内存回收任务</p><p><code>-XX:CMSlnitiatingOccupanyFraction</code> 设置堆使用率的阈值，一旦达到阈值，便开始垃圾回收</p><p><code>-XX:+UseCMSCompactAtFullCollection</code>  用于指定在执行完<code>Full GC</code>后堆内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的的问题就是停顿时间变得更长了。</p><p><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置在执行了多少次Full GC后对内存进行压缩整理。</p><p><code>-XX:ParallelCMSThreads</code>  设置CMS线程数。CMS默认启动线程数是 <code>（ParallelGCThreads+3）/4</code>，<code>ParallelGCThreads</code> 是年轻代并行收集器的线程数。当CPU资源紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收节点可能会非常糟糕。</p><p>4）小技巧</p><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC，Parallel GC，Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><p>最小化的使用内存和并行开销 Serial GC</p><p>最大化应用程序的吞吐量 Parallel GC</p><p>最小化GC的中断或停顿时间 CMS GC</p><p>5）后续版本变化</p><p>JDK9 声明CMS为过时，JDK14直接删掉了，如果使用不会报错，只是会给出警告，并使用默认的垃圾收集器。</p><h2 id="68-G1回收器（区域分代化）"><a href="#68-G1回收器（区域分代化）" class="headerlink" title="68.G1回收器（区域分代化）"></a>68.G1回收器（区域分代化）</h2><p>1）概述</p><p>G1是在java7引入的垃圾回收器，为了适应不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量。</p><p>为什么叫G1回收器？</p><p>因为G1是一个并行回收器，他把堆内存分割成很多不相关的区域。G1有计划的避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个区域里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间，所以我们给G1一个名字，垃圾优先。</p><p>G1主要针对配备多核CPU以及大容量内存的机器，是JDK9以后的默认垃圾回收器，在JDK8还不是默认的垃圾回收器，需要使用<code>-XX:UseGmentGC</code>来启用。</p><p>与其他垃圾回收器相比，G1使用了全新的分区算法：</p><p>2）特点</p><p>①并行与并发</p><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</p><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会再整个回收阶段发生完全阻塞应用程序的情况。</p><p>②分代收集</p><p>从分代上看，G1依然属于分代型垃圾回收器，他会区分年轻代和老年代，年轻代依然有Eden区和幸存者区。但从堆的结构上看，他不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p><p>将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代。</p><p>和之前的各类回收器不同，他同时兼顾年轻代和老年代。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/xxnV8p.jpeg" alt="img"></p><p>③空间整合</p><p>CMS：标记清除算法，内存碎片，若干次GC后进行一次碎片整理。</p><p>G1将内存划分为一个个小区域，内存的回收是以一个个小区域为单位的。区域之间是复制算法，但是整体上可以看成标记压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当java堆非常大的时候，G1的优势更加明显。</p><p>④可预测的停顿时间</p><p>每次根据允许的收集时间，优先回收价值最大的区域，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>3）缺点</p><p>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高。</p><p>经验上来讲：在小内存应用上CMS的表现大概率会优先于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8G之间。</p><p>4）参数设置</p><p><code>-XX:+UseG1GC</code> 手动指定使用G1垃圾收集器执行内存回收任务</p><p><code>-XX:G1HeapRegionSize</code> 设置每个区域的大小。值是2的幂，范围是1M-32M之间。</p><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标</p><p><code>-XX:ParallelGCThread</code> 设置STW工作线程数，最多设置为8</p><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数</p><p><code>-XX:InitiatingHeapOccupancyPercent</code>  设置触发并发GC周期的java堆占用率阈值。超过此值，就会出发GC。</p><p>5）G1调优的步骤</p><p>开启垃圾收集器</p><p>设置堆的最大内存</p><p>设置最大停顿时间</p><p>G1提供了三种垃圾收集模式：YoungGC，Mixed GC和Full GC，在不同的条件下被触发。</p><p>6）适用场景</p><p>面向服务端应用，针对具有大内存，多处理器的机器</p><p>需要低GC延迟，并具有大堆的应用程序提供解决方案</p><p>用来替换掉jdk5的cms</p><p>HotSpot垃圾收集器，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾收集过程。</p><p>所有的区域都大小相同，并且在JVM生命周期内不会被改变，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离了，他们都是一部分区域的集合。通过区域的动态分配的方式实现逻辑上的连续。</p><p>7）Humongous</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous，主要存储大对象，如果超过1.5个区域，就放到H。</p><p>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果他是一个短期的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个H区，他专门用来存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p>8）回收过程</p><p>G1 GC的垃圾回收过程主要包括如下三个环节</p><p>年轻代GC</p><p>老年代并发标记过程</p><p>混合回收</p><p>如果需要，单线程，独占式，高强度的Full GC还是继续存在的。他针对GC的评估失败提供了一种失败保护机制，即强力回收。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/Fym41H.png" alt="image-20241224145938114"></p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年代区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值的时候，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的区域就可以了。同时，这个老年代的区域是和新生代一起被回收的。</p><p>①记忆集与写屏障</p><p>一个对象被不同区域引用的问题</p><p>一个区域不可能是孤立的，一个区域中的对象可能被其他任意区域中的对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p><p>在其他的分代收集器，也存在这样的问题</p><p>回收新生代也不得不同时扫描老年代？</p><p>这样的话会降低Minor GC的效率</p><p><strong>解决方法</strong></p><p>无论G1还是其他垃圾收集器，Jvm都是使用Remembered Set 来避免全局扫描。</p><p>每个区域都有一个对应的Remembered Set ；</p><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的区域</p><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在区域对应的Remembered Set 中；</p><p>当进行垃圾收集时，在GC跟节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><p>②年轻代GC</p><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收Eden区和幸存者区。</p><p>首先G1停止应用程序的执行，G1创建回收集，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和幸存者区所有的内存字分段。然后开始进行如下回收：扫描根  更新RSet  处理RSet  复制对象  处理引用</p><p>第一阶段，扫描根。</p><p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><p>第二阶段，更新RSet。</p><p>处理dirty card queue( 见备注)中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用。</p><p>第三阶段，处理RSet.</p><p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。第四阶段，复制对象。</p><p>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 01d区中空的内存分段。如果Survivor空间不够，Eden空 间的部分数据会直接晋升到老年代空间。</p><p>第五阶段，处理引用。</p><p>处理Soft，Weak，Phantom, Final, JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><p>②并发标记过程</p><p>初始标记阶段  根区域扫描  并发标记  再次标记  独占标记  独占清理  并发清理阶段</p><p>1.初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发- - 次年轻代GC。</p><p>2.根区域扫描(Root Region Scanning) : G1 GC扫描Survivor区直接可达的老年代， 区域对象，并标记被引用的对象。这一-过程必须在young GC之前完成。</p><p>3.并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)， 此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p><p>4.再次标记(Remark):由 于应用程序持续进行，需要修正上一- 次的标记结果。是STW 的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>5.独占清理(cleanup,STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p><p>➢这个阶段并不会实际上去做垃圾的收集。</p><p>6.并发清理阶段:识别并清理完全空闲的区域。</p><p>③混合回收</p><p>当越来越多的对象晋升到老年代，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集。从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</p><p>混合回收的回收集(Collection Set)包括八分之- -的老年代内存分段，Eden区 内存 分段，Survivor区 内存分段。混合回收的算法和年轻代回收的算法完全一样， 只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><p>④Full GC</p><p>G1的初衷就是要避免Full GC的出现，但是如果上述方式不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况下可以通过增大内存解决。</p><p>导致G1Full GC的原因可能有两个</p><p>Evacuation的时候没有足够的to-space来存放晋升的对象    并发处理过程完成之前空间耗尽</p><p>⑤G1回收器优化建议</p><p><strong>年轻代大小</strong></p><p>避免使用-Xmn或者-XX:NewRatio等相关选项显式设置年轻代的大小</p><p>固定年轻代的大小会覆盖暂停时间目标</p><p><strong>暂停时间目标不要太过严苛</strong></p><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p><p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p><h2 id="69-垃圾回收器总结"><a href="#69-垃圾回收器总结" class="headerlink" title="69.垃圾回收器总结"></a>69.垃圾回收器总结</h2><p>1）对比</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>单CPU的client模式</td></tr><tr><td>ParNew</td><td>并行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU的server模式与CMS配合使用</td></tr><tr><td>Parallel</td><td>并行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行</td><td>老年代</td><td>标记压缩</td><td>响应速度优先</td><td>单CPU的client模式</td></tr><tr><td>Parallel Old</td><td>并行</td><td>老年代</td><td>标记压缩</td><td>吞吐量优先</td><td>后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发</td><td>老年代</td><td>标记清除</td><td>响应速度优先</td><td>互联网/BS业务</td></tr><tr><td>G1</td><td>并发，并行</td><td>新生代，老年代</td><td>标记压缩，复制</td><td>响应速度优先</td><td>服务端应用</td></tr></tbody></table><p>GC发展阶段 Serial =&gt; Parallel(并行) =&gt;CMS(并发)=&gt;G1=&gt;ZGC</p><p>2）垃圾回收器的组合</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/qgBfVu.png" alt="image-20241224145644315"></p><p>3）怎么选择垃圾回收器？</p><p>1.优先调整堆的大小让JVM自适应完成</p><p>2.如果内存小于100M，使用串行收集器</p><p>3.如果是单核，单机程序，并且没有停顿时间的要求，串行收集器</p><p>4.如果是多CPU，需要高吞吐量，允许停顿时间超过1s，选择并行或者JVM自己选择</p><p>5.如果是多CPU，追求低停顿时间，需快速响应，使用并发收集器</p><p><strong>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1.</strong></p><p>没有最好的收集器，调优是针对特定场景，特定需求。</p><h2 id="70-CMS运行过程，缺点？"><a href="#70-CMS运行过程，缺点？" class="headerlink" title="70.CMS运行过程，缺点？"></a>70.CMS运行过程，缺点？</h2><p>整个过程分为四个步骤</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/wCHQlR.jpg" alt="image"></p><ol><li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li><li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li><li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li><li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li></ol><p><strong>缺点：</strong></p><ol><li>对CPU资源敏感（会和服务抢资源）</li><li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li><li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li></ol><h2 id="71-G1运行过程"><a href="#71-G1运行过程" class="headerlink" title="71.G1运行过程"></a>71.G1运行过程</h2><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p><ol><li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li><li>并发标记（Concurrent Marking）：同CMS的并发标记</li><li>最终标记（Remark，STW）：同CMS的重新标记</li><li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li></ol><h2 id="72-G1适合什么场景"><a href="#72-G1适合什么场景" class="headerlink" title="72.G1适合什么场景"></a>72.G1适合什么场景</h2><ol><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过1秒</li><li>8GB以上的堆内存(建议值)</li><li>停顿时间是500ms以内</li></ol><h2 id="73-什么情况下会触发Full-GC？"><a href="#73-什么情况下会触发Full-GC？" class="headerlink" title="73.什么情况下会触发Full GC？"></a>73.什么情况下会触发Full GC？</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p><ul><li><strong>调用 System.gc()</strong></li></ul><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><ul><li><strong>老年代空间不足</strong></li></ul><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><ul><li><strong>空间分配担保失败</strong></li></ul><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><ul><li><strong>JDK 1.7 及以前的永久代空间不足</strong></li></ul><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><ul><li><strong>Concurrent Mode Failure</strong></li></ul><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2 id="74-内存溢出与内存泄漏"><a href="#74-内存溢出与内存泄漏" class="headerlink" title="74.内存溢出与内存泄漏"></a>74.内存溢出与内存泄漏</h2><p>1）内存溢出</p><p>内存溢出是相对于内存泄漏来说的，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。大多数情况下，GC会进行各种年龄段的垃圾回收实在不行了就放大招，来一次Full GC操作，这时候会回收大量内存，供应用程序继续使用。javadoc对OOM的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>堆内存不够的原因有两个：java虚拟机的堆内存设置不够。代码中创建了大量的大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><p>OOM之前，通常垃圾收集器会先进行GC，当然也不是任何情况下垃圾收集器都会被触发：比如我们创建一个超过堆空间大小的对象。</p><p>2）内存泄漏</p><p>只有对象不在被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。实际上一些导致对象生命周期变得很长甚至OOM的操作，也称为内存泄漏。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM，导致程序崩溃。</p><p>这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存取决于磁盘交换区设定的大小。</p><p>Example：</p><p>1.单例模式，单例的生命周期默认和应用程序一样长，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，否则会导致内存泄漏的产生。</p><p>2.一些提供close的资源未关闭导致内存泄漏（数据库连接，网络连接，io连接）</p><h2 id="75-Stop-The-World"><a href="#75-Stop-The-World" class="headerlink" title="75.Stop The World"></a>75.Stop The World</h2><p>指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被停掉，没有任何响应。</p><p>STW事件和采用哪款垃圾收集器无关，所有GC都有这个事件。它是由JVM在后台自动发起和自动完成的。</p><h2 id="76-安全点与安全区域"><a href="#76-安全点与安全区域" class="headerlink" title="76.安全点与安全区域"></a>76.安全点与安全区域</h2><p>1）安全点</p><p>程序执行过程中并不是在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点。</p><p>安全点太少可能导致GC等待时间太长，太多可能导致程序运行时的性能问题。</p><p>方法调用，循环跳转，异常跳转。</p><p>如何在GC发生时，检查所有线程都跑到最近的安全点停下来呢？</p><p><strong>抢先式中断</strong>（目前没有虚拟机采用了）中断所有线程，哪个没到安全点就恢复线程，让线程跑到安全点。</p><p><strong>主动式中断</strong>设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p><p>2）安全区域</p><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入的GC安全点，但是假如程序处于sleep状态，这时候线程无法响应jvm的中断请求，走到安全点去中断挂起，jvm也不太可能的等待线程被唤醒。对于这种情况，就需要安全区域来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</p><p>实际执行时</p><p>当线程运行到安全区域的代码时，首先标识已经进入了安全区域，如果这段时间内发生GC，JVM会忽略标识为安全区域状态的线程。</p><p>当线程即将离开安全区域时，会检查jvm是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开安全区域的信号为止。</p><h2 id="77-再谈内存泄漏"><a href="#77-再谈内存泄漏" class="headerlink" title="77.再谈内存泄漏"></a>77.再谈内存泄漏</h2><p>1）内存泄露的理解与分析</p><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题(让JVM误以为此对象还在引用中，无法回收，造成内存泄漏)。</p><p>是否还被使用? 是</p><p>是否还被需要? 否</p><p>内存泄漏(memory leak) 的理解</p><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致0OM，也可以叫做宽泛意义上的“内存泄漏”。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/tkMTjm.png" alt="image-20241224155604073"></p><p>对象X引用对象Y,X的生命周期比Y的生命周期长;</p><p>那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的;</p><p>如果对象X还引用着生命周期比较短的A、B、C,对象A又引用着对象a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p><p>内存泄漏与内存溢出的关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.内存泄漏(memory leak )</span><br></pre></td></tr></table></figure><p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M 的内存一-直不回收，那么可以 用的内存只有512M 了，仿佛泄露掉了一部分;</p><p>通俗一点讲的话，内存泄漏就是[占着茅坑不拉shi]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.内存溢出(out of memory )</span><br></pre></td></tr></table></figure><p>申请内存时，没有足够的内存可以使用;</p><p>通俗一点儿讲，-一个厕所就三个坑，有两个站着茅坑不走的(内存泄漏)，剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位(内存)就不够了，内存泄漏变成内存溢出了。</p><p>可见，内存泄漏和内存溢出的关系:内存泄漏的增多，最终会导致内存溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泄漏的分类</span><br></pre></td></tr></table></figure><p>经常发生:发生内存泄露的代码会被多次执行，每次执行，泄露一块内存;</p><p>偶然发生:在某些特定情况下才会发生</p><p>一次性:发生内存泄露的方法只会执行一次;</p><p>隐式泄漏:一 直占着内存不释放，直到执行结束;严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p><p>2）Java中内存泄露的8种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-静态集合类</span><br></pre></td></tr></table></figure><p>静态集合类，如HashMap、 LinkedList等等。 如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2-单例模式</span><br></pre></td></tr></table></figure><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和JVM的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3-内部类持有外部类</span><br></pre></td></tr></table></figure><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。</p><p>这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4-各种连接，如数据库连接、网络连接和IO连接等</span><br></pre></td></tr></table></figure><p>各种连接，如数据库连接、网络连接和IO连接等。</p><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。</p><p>否则，如果在访问数据库的过程中，对Connection、 Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5-变量不合理的作用域</span><br></pre></td></tr></table></figure><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null,很有可能导致内存泄漏的发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6-改变哈希值</span><br></pre></td></tr></table></figure><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p><p>这也是String为什么被设置成了不可变类型，我们可以放心地把String 存入HashSet,或者把 String当做HashMap 的key值;</p><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">例<span class="number">2</span>：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示内存泄漏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7-缓存泄露</span><br></pre></td></tr></table></figure><p>内存泄漏的另一个常见来源是缓存，- -旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载-个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/oWfe4u.jpeg" alt="img"></p><p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函 数执行完成后，局部变量字 符串引用weakd1 ,weakd2,d1,d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以 看到，调用gc之后，HashMap的没有被回收，而WeakHashMap 里面的缓存被回收了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8-监听器和回调</span><br></pre></td></tr></table></figure><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p><p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p><p>3）内存泄露案例分析</p><p>①代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②分析</p><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p><p>代码的主要问题在pop函数，下面通过这张图示展现</p><p>假设这个栈- -直增长，增长后如下图所示</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/pnEJRU.png" alt="image-20241224155438585"></p><p>当进行大量的POP操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/U3liR7.png" alt="image-20241224155410221"></p><p>从上图可以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，这个内存泄漏很隐蔽。</p><p>③解决办法</p><p>将代码中的pop()方法变成如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elements[--size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦引用过期，清空这些引用，将引用置空。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/Ch5vZD.png" alt="image-20241224155345034"></p><h2 id="78-判断元空间是无用的类"><a href="#78-判断元空间是无用的类" class="headerlink" title="78.判断元空间是无用的类"></a>78.判断元空间是无用的类</h2><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="79-创建对象的几种方式"><a href="#79-创建对象的几种方式" class="headerlink" title="79.创建对象的几种方式"></a>79.创建对象的几种方式</h2><p>1）new</p><p>new（直接new ，工厂模式，构建者模式）</p><p>2）Class.forName().newInstance()</p><p>反射的方式，只能调用空参构造器，权限是public</p><p>3）Constructor.newInstance(xxx)</p><p>反射的方式，可以调用空参，带参的构造器，权限没要求</p><p>4）使用clone（）</p><p>不调用任何构造器，当前需要实现Cloneable接口，实现clone（）；分为深克隆和浅克隆  对象嵌套</p><p>5）使用反序列化</p><p>从文件，网络中获取一个对象的二进制流</p><p>6）第三方库Objenesis</p><h2 id="80-对象访问定位"><a href="#80-对象访问定位" class="headerlink" title="80.对象访问定位"></a>80.对象访问定位</h2><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p>定位，通过栈上reference访问。创建对象的目的是为了使用它。对象访问方式主要有两种：</p><p>1）句柄访问</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/B5G9am.png" alt="image-20241224155807589"></p><p>优点：引用中存储稳定句柄地址，对象被移动时只会改变句柄中实例数据指针即可，引用本身不需要被修改。</p><p>缺点：需要额外维护一个句柄，效率低。</p><p>2）直接指针(HotSpot采用)</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/iyABm8.jpeg" alt="img"></p><p>优点：效率高</p><h2 id="81-永久代为什么要被元空间替换？"><a href="#81-永久代为什么要被元空间替换？" class="headerlink" title="81.永久代为什么要被元空间替换？"></a>81.永久代为什么要被元空间替换？</h2><p>以前使用虚拟机内存，现在使用本地内存</p><p>①为永久代设置空间大小很难确定</p><p>②对永久代调优困难</p><p>方法区的垃圾收集主要分两部分</p><p>常量池中废弃的常量和不再使用的类型</p><h2 id="82-方法区的内部结构"><a href="#82-方法区的内部结构" class="headerlink" title="82.方法区的内部结构"></a>82.方法区的内部结构</h2><p>尽管所有方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾回收或者压缩，对于hotspot而言，方法区还有一个别名叫非堆，目的就是要和堆分开。所以方法区可以看做是一块独立于java堆的内存空间。方法区与堆空间一样，是多线程共享的，方法区在jvm启动的时候被创建，并且他的实际物理内存空间中和java堆区一样都可以是物理上不连续的。方法区的大小和堆一样可以选择固定大小和扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会OOM。关闭jvm就会释放这个区域的内存。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/W3xizJ.png" alt="image-20241224160725192"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/PMkm5Q.png" alt="image-20241224160746817"></p><p>他用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等。</p><p>1）类型信息</p><p>对每个加载的类型，jv必须在方法区存储一下类型信息。</p><p>全限定类名，直接父类的全限定类名，这个类型的修饰符，这个类型直接接口的一个有序列表</p><p>2）域信息</p><p>jvm必须在方法区中保存类型的所有域的信息以及域的声明顺序。</p><p>域的相关信息包括：域名称，域类型，域修饰符。</p><p>3）方法信息</p><p>jvm必须保存所有方法的以下信息，同域信息一样包括声明顺序</p><p>方法名称，返回类型，参数的数量和类型，顺序，方法的修饰符，方法的字节码，操作数栈，局部变量表以及大小，异常表</p><p>每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-12:09</span></span><br><span class="line"><span class="comment"> * 1.静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。</span></span><br><span class="line"><span class="comment"> * 2.类变量被类的所有实例共享，即使没有实例时你也可以放问他。</span></span><br><span class="line"><span class="comment"> * 3.全局常量 static final</span></span><br><span class="line"><span class="comment"> * 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</span></span><br><span class="line"><span class="comment"> *图：final-static</span></span><br><span class="line"><span class="comment"> * javap -v Order.class</span></span><br><span class="line"><span class="comment"> * javap -v  -p DemoE.class &gt; DemoE.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order=<span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a+<span class="string">&quot;----&quot;</span>+<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/l2fAui.jpeg" alt="img"></p><p>4）class文件中常量池的理解</p><p>方法区内部包含了运行时常量池，字节码文件内部包含了常量池。</p><p>为什么需要常量池？</p><p>java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在动态链接的时候就会用到运行时常量池。</p><p>一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池表，包含各种字面量和对应类型，域和方法的符号引用。</p><p>总结：常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。</p><p>5）运行时常量池</p><p>方法区的一部分，class文件的常量池被类加载器加载到运行时数据区就会在方法区生成对应的运行时常量池，JVM为每一个已经加载的类或接口都维护了一个常量池。池子中的数据就像数组一样，都是通过索引访问的，运行时常量池包括多种不同的变量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换位真实地址。</p><p>运行时常量池动态性，当创建类或者接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则会OOM。</p><h2 id="83-图解常量池操作"><a href="#83-图解常量池操作" class="headerlink" title="83.图解常量池操作"></a>83.图解常量池操作</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/FDbea1.png" alt="image-20241224160825218"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a=x/y;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时常量池</p><p>运行时常量池是方法区的一部分。</p><p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><h2 id="84-方法区的垃圾回收"><a href="#84-方法区的垃圾回收" class="headerlink" title="84.方法区的垃圾回收"></a>84.方法区的垃圾回收</h2><p>1.一般来说，方法区的回收效果不好，特别是类型的卸载，但是有时候回收又是必要的</p><p>2.方法区的垃圾回收主要是两部分：废弃的常量和不再使用的类型</p><p>3.方法区常量池主要存放：字面量和符号引用</p><p><strong>符号引用包括：1.类和接口的全限定类名2.字段的名称和描述符3.方法的名称和描述符</strong></p><p>4.只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>5.判断一个类是否可以被回收</p><p>1.该类所属的实例都已经被回收</p><p>2.加载该类的类加载器已经被回收</p><p>3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的对象</p><h2 id="85-直接内存"><a href="#85-直接内存" class="headerlink" title="85.直接内存"></a>85.直接内存</h2><p>不是虚拟机运行时数据区的一部分，也不是jvm规范中定义的内存区域。</p><p>直接内存是在java堆外，直接向系统申请的内存空间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存，通常，访问直接内存的速度会优于java堆，即读写性能高，因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存，java的NIO库允许java程序使用直接内存，用于数据缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoH</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer BUFFER=<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(BUFFER);</span><br><span class="line">        sc.next();</span><br><span class="line">        byteBuffer=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可能导致OOM异常，由于直接内存在java堆外，因此它的大小不会受限于-Xmx指定的最大堆的大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><p>缺点：分配回收成本高，不受JVM内存回收管理，直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致，简单理解java进程内存=java堆+本地内存。</p><h2 id="86-静态变量放在哪里"><a href="#86-静态变量放在哪里" class="headerlink" title="86.静态变量放在哪里"></a>86.静态变量放在哪里</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-15:38</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 1.new出来的结构，也就是对象实例都在堆空间</span></span><br><span class="line"><span class="comment"> * 2.1.6：obj1随着DemoG的类型信息放在方法区；1.7：放在堆空间</span></span><br><span class="line"><span class="comment"> * 3.obj2是实例变量，在堆空间</span></span><br><span class="line"><span class="comment"> * 4.obj3在foo方法对应的栈帧的局部变量表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Order obj1=<span class="keyword">new</span> Order(); <span class="comment">//jdk7以前放在永久代，7开始放在堆空间</span></span><br><span class="line">        Order obj2=<span class="keyword">new</span> Order(); <span class="comment">//实例变量  堆空间</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; </span><br><span class="line">            Order obj3=<span class="keyword">new</span> Order();  <span class="comment">//方法内部局部变量   栈帧里面的局部变量表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="87-执行引擎"><a href="#87-执行引擎" class="headerlink" title="87.执行引擎"></a>87.执行引擎</h2><p>1.虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面的，而虚拟机的执行引擎是由软件自行实现的，因此可以不受物理条件制约的定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/wEYnMw.jpeg" alt="img"></p><p>2.jvm的主要作用负责装在字节码到其内部，但是字节码不能直接运行在操作系统之上，执行引擎就是将字节码指令编译为对应平台上的本地机器指令。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/h585Do.png" alt="image-20241224161931765"></p><p>3.外观上看：jvm的执行引擎输入输出都是一致的，输入的是字节码二进制流，处理过程是字节码解析执行的过程，输出的是执行结果。</p><h2 id="88-java代码的编译和执行过程"><a href="#88-java代码的编译和执行过程" class="headerlink" title="88.java代码的编译和执行过程"></a>88.java代码的编译和执行过程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/xi9Pyw.png" alt="image-20241224161725266"></p><p>大部分的程序代码转换为物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的步骤。</p><p>为什么java称为半解释型半编译型语言？</p><p>因为jvm的执行引擎是解释器和jit即时编译器交互工作的。</p><p>什么是解释器？什么是JIT编译器？</p><p>解释器：将字节码指令逐行翻译成机器指令并执行</p><p>编译器：将源代码直接编译成对应的机器指令。</p><h2 id="89-JIT即时编译器"><a href="#89-JIT即时编译器" class="headerlink" title="89.JIT即时编译器"></a>89.JIT即时编译器</h2><p><strong>HotSpot采用解释器与即时编译器共存的架构。由JVM决定何时使用哪种方式执行。</strong></p><p>解释器可以边解释边执行，这样程序启动时间就会变快，及时编译器是都编译好了在执行，程序启动时间慢。但是一旦jit编译器把越来越多的代码编译成本地代码，执行效率立马起飞。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/wVpbli.png" alt="image-20241224161838775"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/rlYdQt.jpeg" alt="img"></p><p>1）热点代码以及探测方式</p><p>判断是否启动jit编译器将字节码直接编译为对应平台的本地机器指令，需要根据执行的频率而定。热点代码就是需要被编译为本地代码的字节码，jit在运行时会针对频繁调用的热点代码直接编译为对应平台的本地机器指令，提升性能。</p><p>2）OSR编译</p><p>一个方法被多次调用，或者一个方法体内部循环次数较多的循环体都可以被称为热点代码，因此都可以通过jit编译器编译为本地机器指令，也就是栈上替换.hotspot采用的热点探测方式是基于计数器的热点探测。</p><p>为每个方法建立2个不同类型的计数器，分别为方法调用计数器和回边计数器</p><p>1.方法调用计数器：统计方法调用次数，默认client模式下1500，server模式下100002.回边计数器：统计循环执行次数</p><p>当一个方法被调用时，先判断有没有jit编译过，有的话直接使用jit编译后的机器指令，没有的话计数器+1，然后判断两个计数器之和是否超过方法调用计数器的阈值。如果超过，就会向jit发出即时编译申请。</p><p>热度衰减是在虚拟机进行垃圾回收的时候顺便进行的，也就是在一段时间方法一直没有执行，计数器的计数就会减半。</p><p>可以自己手动设置虚拟机采用哪种编译模式</p><p>3）JDK9引入了AOT编译器</p><p>aot编译器在程序执行之前，就将字节码转换为机器码过程。</p><p>好处：可以直接运行，不必预热。</p><p>坏处：由于提前编译成了机器指令，无法实现java一次编译到处运行。</p><p>4）JDK10的Graal编译器</p><p>全新的即时编译器，实验阶段，需要手动开启，前景大好</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2024/08/22/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2024/08/22/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/LOQBWm.png" alt="tabAt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/rmZ04d.png" alt="concurrenthashmap扩容图解"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/ky3qW7.png" alt="concurrenthashmap迁移高低位原理1"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/8iLYmL.png" alt="ffb2efa924944e02b25e97a2b90bf6f5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Z4wQG3.png" alt="3914c7b94d2843b985ea10e5c23a04b0"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/vNlWfH.png" alt="e7e01e24e3e844c7b31c4d73da2fffed"><br>2)为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/0UPxr0.png" alt="db389ed8b874494ca1f5a8723e8a6973"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql执行流程</title>
      <link href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、MySQL的内部组件结构"><a href="#一、MySQL的内部组件结构" class="headerlink" title="一、MySQL的内部组件结构"></a>一、MySQL的内部组件结构</h1><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/hSm139.png" alt="image-20220402112243233"></p><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 </p><p><strong>Server层</strong> </p><p>主要包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数 </p><p>（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 </p><p><strong>Store层</strong></p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在 </p><p>最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。也就是说如果我们在create table时不指定 </p><p>表的存储引擎类型,默认会给你设置存储引擎为InnoDB。</p><p>本节课演示表的DDL： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` ( </span><br><span class="line"></span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line"></span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line"></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line"></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">9</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8; </span><br></pre></td></tr></table></figure><p>下面我们重点来分析连接器、查询缓存、分析器、优化器、执行器分别主要干了哪些事情。 </p><h1 id="二、连接器"><a href="#二、连接器" class="headerlink" title="二、连接器"></a>二、连接器</h1><p>我们知道由于MySQL是开源的，他有非常多种类的客户端：navicat,mysql front,jdbc,SQLyog等非常丰富的客户端,这些 </p><p>客户端要向mysql发起通信都必须先跟Server端建立通信连接，而建立连接的工作就是有连接器完成的。 </p><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管 </p><p>理连接。连接命令一般是这么写的： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]# mysql ‐h host[数据库地址] ‐u root[用户] ‐p root[密码] ‐P 3306 </span><br></pre></td></tr></table></figure><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份， </p><p>这个时候用的就是你输入的用户名和密码。 </p><p>1、如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 </p><p>2、如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权 </p><p>限。</p><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权 </p><p>限。修改完成后，只有再新建的连接才会使用新的权限设置。用户的权限表在系统表空间的mysql的user表中。 </p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/U5vVfM.png" alt="image-20220402112554489"></p><p>修改user密码 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;; //创建新用户 </span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges on *.* to &#x27;username&#x27;@&#x27;%&#x27;; //赋权限,%表示所有(host) </span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges //刷新数据库 </span><br><span class="line"></span><br><span class="line">mysql&gt; update user set password=password(”123456″) where user=’root’;(设置用户名密码) </span><br><span class="line"></span><br><span class="line">mysql&gt; show grants for root@&quot;%&quot;; 查看当前用户的权限 </span><br></pre></td></tr></table></figure><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个 </p><p>图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。 </p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/gdu3Zi.png" alt="image-20220402112614161"></p><p>客户端如果长时间不发送command到Server端，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值 </p><p>是 8 小时。 </p><p>查看wait_timeout </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;wait_timeout&quot;; </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">set</span> <span class="keyword">global</span> wait_timeout<span class="operator">=</span><span class="number">28800</span>; 设置全局服务器关闭非交互连接之前等待活动的秒数 </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/7LjNIT.png" alt="image-20220402112633745"></p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during </p><p>query。这时候如果你要继续，就需要重连，然后再执行请求了。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次 </p><p>查询就断开连接，下次查询再重新建立一个。 </p><p>开发当中我们大多数时候用的都是长连接,把连接放在Pool内进行管理，但是长连接有些时候会导致 MySQL 占用内存涨得特别 </p><p>快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如 </p><p>果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。 </p><p>怎么解决这类问题呢？ </p><p>1、定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 </p><p>2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资 </p><p>源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 </p><h1 id="三、查询缓存"><a href="#三、查询缓存" class="headerlink" title="三、查询缓存"></a>三、查询缓存</h1><p>常用的一些操作 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">show</span> databases; 显示所有数据库 </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>use dbname； 打开数据库： </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">show</span> tables; 显示数据库mysql中所有的表； </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">describe</span> <span class="keyword">user</span>; 显示表mysql数据库中<span class="keyword">user</span>表的列信息）； </span><br></pre></td></tr></table></figure><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。 </p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 </p><p>key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找 </p><p>到 key，那么这个 value 就会被直接返回给客户端。 </p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查 </p><p>询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。 </p><p><strong>大多数情况查询缓存就是个鸡肋，为什么呢？</strong> </p><p>因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。 </p><p>因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率 </p><p>会非常低。 </p><p>一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典 </p><p>表，那这张表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将my.cnf参数 </p><p>query_cache_type 设置成 DEMAND。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> my.cnf </span><br><span class="line"></span><br><span class="line"> #query_cache_type有<span class="number">3</span>个值 <span class="number">0</span>代表关闭查询缓存OFF，<span class="number">1</span>代表开启<span class="keyword">ON</span>，<span class="number">2</span>（DEMAND）代表当<span class="keyword">sql</span>语句中有SQL_CACHE </span><br><span class="line"></span><br><span class="line">关键词时才缓存 </span><br><span class="line"></span><br><span class="line"> query_cache_type<span class="operator">=</span><span class="number">2</span> </span><br></pre></td></tr></table></figure><p>这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下 </p><p>面这个语句一样： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>查看当前mysql实例是否开启缓存机制 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> &quot;%query_cache_type%&quot;; </span><br></pre></td></tr></table></figure><p>监控查询缓存的命中率: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span><span class="string">&#x27;%Qcache%&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>查看运行的缓存信息</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/GtvVcf.png" alt="image-20220402112708121"></p><p>Qcache_free_blocks:表示查询缓存中目前还有多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内存碎片 </p><p>过多了，可能在一定的时间进行整理。 </p><p>Qcache_free_memory:查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，是多 </p><p>了，还是不够用，DBA可以根据实际情况做出调整。 </p><p>Qcache_hits:表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越 </p><p>理想。</p><p>Qcache_inserts: 表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行 </p><p>查询处理后把结果insert到查询缓存中。这样的情况的次数，次数越多，表示查询缓存应用到的比较少，效果也就不理 </p><p>想。当然系统刚启动后，查询缓存是空的，这很正常。 </p><p>Qcache_lowmem_prunes:该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的 </p><p>调整缓存大小。 </p><p>Qcache_not_cached: 表示因为query_cache_type的设置而没有被缓存的查询数量。 </p><p>Qcache_queries_in_cache:当前缓存中缓存的查询数量。 </p><p>Qcache_total_blocks:当前缓存的block数量。 </p><p><strong>mysql8.0已经移除了查询缓存功能</strong> </p><h1 id="四、分析器"><a href="#四、分析器" class="headerlink" title="四、分析器"></a>四、分析器</h1><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。 </p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是 </p><p>什么，代表什么。 </p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符 </p><p>串“ID”识别成“列 ID”。 </p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句 </p><p>是否满足 MySQL 语法。 </p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 from 写成了 </p><p>“rom”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> fro test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"> ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds t </span><br><span class="line"></span><br><span class="line">o your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;fro test where id=1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span> </span><br></pre></td></tr></table></figure><p><strong>词法分析器原理</strong> </p><p>词法分析器分成6个主要步骤完成对sql语句的分析 </p><p>1、词法分析 </p><p>2、语法分析 </p><p>3、语义分析 </p><p>4、构造执行树 </p><p>5、生成执行计划 </p><p>6、计划的执行 </p><p>下图是SQL词法分析的过程步骤：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/fnigtN.png" alt="image-20220402112744984"></p><p>SQL语句的分析分为词法分析与语法分析，mysql的词法分析由MySQLLex[MySQL自己实现的]完成，语法分析由Bison生 </p><p>成。关于语法树大家如果想要深入研究可以参考这篇wiki文章：<a href="https://en.wikipedia.org/wiki/LR_parser%E3%80%82%E9%82%A3%E4%B9%88%E9%99%A4%E4%BA%86Bison">https://en.wikipedia.org/wiki/LR_parser。那么除了Bison</a> </p><p>外，Java当中也有开源的词法结构分析工具例如Antlr4，ANTLR从语法生成一个解析器，可以构建和遍历解析树，可以在IDEA </p><p>工具当中安装插件：<strong>antlr v4 grammar plugin。插件使用详见课程</strong> </p><p>经过bison语法分析之后，会生成一个这样的语法树 </p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/N8lcCT.png" alt="image-20220402112759795"></p><p>至此我们分析器的工作任务也基本圆满了。接下来进入到优化器 </p><h1 id="五、优化器"><a href="#五、优化器" class="headerlink" title="五、优化器"></a>五、优化器</h1><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。 </p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接 </p><p>顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1 <span class="keyword">join</span> test2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> test1.name<span class="operator">=</span>yangguo <span class="keyword">and</span> test2.name<span class="operator">=</span>xiaol </span><br><span class="line"></span><br><span class="line">ongnv; </span><br></pre></td></tr></table></figure><p>既可以先从表 test1 里面取出 name=yangguo的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的 </p><p>值是否等于 yangguo。 </p><p>也可以先从表 test2 里面取出 name=xiaolongnv 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name </p><p>的值是否等于 yangguo。 </p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段 </p><p>完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有 </p><p>没有可能选择错等等。 </p><h1 id="六、执行器"><a href="#六、执行器" class="headerlink" title="六、执行器"></a>六、执行器</h1><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在 </p><p>工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权 </p><p>限)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; </span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 </p><p>比如我们这个例子中的表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的： </p><p>\1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； </p><p>\2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 </p><p>\3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 </p><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接 </p><p>口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个 </p><p>rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加 </p><p>的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识点总结</title>
      <link href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h2><p><a href="../../1.基础知识/ConcurrentHashMap" target="_blank">ConcurrentHashMap</a></p><h2 id="2-Set-List-Map有什么区别"><a href="#2-Set-List-Map有什么区别" class="headerlink" title="2.Set,List,Map有什么区别"></a>2.Set,List,Map有什么区别</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/abkwex.png" alt="image-20220331111150319"></p><ul><li>结构特点<ol><li>List 和 Set 是存储单列数据的集合， Map 是存储键和值这样的双列数据的集合;</li><li>List中存储的数据是有顺序，并且允许重复; Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的， Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的hashcode决定，位置是固定的(Set集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的);</li></ol></li></ul><h2 id="3-HashMap和HashTable有什么区别？"><a href="#3-HashMap和HashTable有什么区别？" class="headerlink" title="3.HashMap和HashTable有什么区别？"></a>3.HashMap和HashTable有什么区别？</h2><p>区别：</p><ol><li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li><li>HashMap允许key和value为null，而HashTable不允许</li></ol><h2 id="4-HashMap底层实现"><a href="#4-HashMap底层实现" class="headerlink" title="4.HashMap底层实现"></a>4.HashMap底层实现</h2><ol><li>jdk1.7底层采用的是数组+链表实现；jdk1.8底层采用数组+链表+红黑树实现，相对于1.7提升了查询的性能</li><li>链表过度到红黑树的阈值为8，红黑树退化为链表的阈值是6，原因在源码中332行给了明确解释(Poisson distribution)泊松分布，这是数学里面类似于正态分布的一个问题，这是统计学里面的一些东西</li><li>HashMap初始化的数组长度为16(算法导论中的除法散列法讲到 K取模m得到一个对应的位置，根据具体位置插入一个数据值，假如长度是16，长度范围就是0<del>15，取模之后我的余数为0</del>15之间，而算法导论中指出，一个不太接近2的整数幂的素数（质数：只能被1和它本身整出的数），常常是m的最好选择。但是hashMap中未采用素数，而是采用2的n次方(合数)作为数组长度)，原因为：1、更便于位置计算；2、方便做数据迁移。</li><li>为了保证存入的数据均匀的散列分布在数组中，需要设计良好的hash散列算法(hashMap中采用扰动函数来做的：移位和异或相关操作ConcurrentHashMap源码中684行spread方法，即：让int的高16位异或它本身)，尽可能的避免hash冲突(概率问题)，具体落到数组哪个节点并非是通过取模运算得出，而是通过与上数组长度-1即可(只需要int类型数32位的后四位参与运算)，即可得到0~15之间的数，因为取模运算效率远低于位运算，所以这也是hashMap要求底层数组长度必须为2的n次方的原因之一（ConcurrentHashMap源码中514行规定）。</li></ol><h2 id="5-HashMap-put流程"><a href="#5-HashMap-put流程" class="headerlink" title="5.HashMap put流程"></a>5.HashMap put流程</h2><ol><li>HashMap/ConcurrentHashMap 并不是通过构造函数创建默认空间的，而是通过put数据的时候获取到对应的数据空间的，如果数组长度是0，则通过CAS操作后初始化数组，如果有线程正在做初始化数组操作，其他线程则让出时间片</li><li></li></ol><h2 id="6-HashMap扩容流程"><a href="#6-HashMap扩容流程" class="headerlink" title="6.HashMap扩容流程"></a>6.HashMap扩容流程</h2><ol><li>hashMap规定了当我的数组快放满的时候就要开始扩容了，什么时候算是快放满？HashMap是通过扩容因子来规定的</li><li>HashMap规定扩容因子是0.75，如果默认长度是16，也就是说当HashMap底层数组的容量达到12的时候进行扩容操作。0.75则是根据统计学得来的。<code>private static final float LOAD_FACTOR = 0.75f;</code></li><li>扩容首先要创建新的数组（原来大小左移1位）ConcurrentHaspMap源码2367行开始扩容操作</li><li>转移旧数据到新的数组中去（怎么计算扩容后数据下标位置？）原来：h&amp;(n-1)计算下标位置，扩容后 h$(31)，原来占用4个二进制位，扩容后占用5个二进制位，所以只需要看第五位即可，如果第五位是0，扩容后的的下标跟原位置一样，如果是1，新下标位置在原数组的位置的基础上加上原来数组长度即可，这也是数组长度采用2的N次方扩容的第二个原因</li><li>假设原来长度是128，扩容后是256，整体扩容方式是通过多线程方式运行的，但是要保证数据不能乱，将原来数组分段，规定每个线程最少负责16个桶的迁移工作，8个线程可以并行执行，如果小于16个桶，直接单线程执行</li></ol><h2 id="7-为什么选择用红黑树"><a href="#7-为什么选择用红黑树" class="headerlink" title="7.为什么选择用红黑树"></a>7.为什么选择用红黑树</h2><p>二叉树在极端情况下会退化为链表，查询时间复杂度跟链表相似，而AVL树，SB树，红黑树，都属于平衡二叉树，尽量保持左子树和右子树的高度差不要相差太大，而这三种树的差别就在于左树和右树的高度规则不同。</p><ul><li>AVL树：严格意义平衡树，的要求左子树和右子树的高度差不能超过1，损失了部分插入性能，带来了高效的查询</li><li>SB树：</li><li>红黑树：要求最长子树不能超过最短子树的2倍即可，损失了部分查询性能，使得查询效率高于链表的同时，相比于其他树提升了插入性能，尽量做到了插入和查询的一个平衡点，而HashMap则是查多，插入少(这里的插入指的是产生Hash冲突下的插入)，所以红黑树更适合HashMap来做底层的存储结构。</li></ul><h2 id="8-面向对象的特征"><a href="#8-面向对象的特征" class="headerlink" title="8.面向对象的特征?"></a>8.面向对象的特征?</h2><p>面向对象的特征:封装、继承、多态、抽象。 封装:就是把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内 部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。 继承:子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代 码的复用性。 多态:指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采 用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备 的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。 抽象:表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类(接口)就是为了继承而存在的。</p><h2 id="9-常见的RuntimeException"><a href="#9-常见的RuntimeException" class="headerlink" title="9.常见的RuntimeException"></a>9.常见的RuntimeException</h2><ol><li>java.lang.NullPointerException 空指针异常;出现原因:调用了未经初始化的对象或者是不存在 的对象。</li><li>java.lang.ClassNotFoundException 指定的类找不到;出现原因:类的名称和路径加载错误;通常 都是程序试图通过字符串来加载某个类时可能引发异常。</li><li>java.lang.NumberFormatException 字符串转换为数字异常;出现原因:字符型数据中包含非数 字型字符。</li><li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</li><li>java.lang.IllegalArgumentException 方法传递参数错误。</li><li>java.lang.ClassCastException 数据类型转换异常。 </li><li>java.lang.NoClassDefFoundException 未找到类定义错误。</li><li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。</li><li>java.lang.InstantiationException实例化异常。</li><li>java.lang.NoSuchMethodException方法不存在异常。</li></ol><h2 id="10-常见的引用类型"><a href="#10-常见的引用类型" class="headerlink" title="10.常见的引用类型"></a>10.常见的引用类型</h2><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p><ul><li><strong>强引用</strong>：普通的变量引用</li><li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li><li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li><li><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li></ul><h1 id="四、缓存-Redis"><a href="#四、缓存-Redis" class="headerlink" title="四、缓存:Redis"></a>四、缓存:Redis</h1><h1 id="五、MQ"><a href="#五、MQ" class="headerlink" title="五、MQ"></a>五、MQ</h1><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/dvvBBU.png" /><h3 id="Rabbitmq生产高可用怎么实现的"><a href="#Rabbitmq生产高可用怎么实现的" class="headerlink" title="Rabbitmq生产高可用怎么实现的"></a>Rabbitmq生产高可用怎么实现的</h3><ol><li>生产部署为集群模式：避免单机模式下MQ服务器挂了导致服务不可用，还可以承载更高的并发量，但是集群模式有个问题，就是在哪个节点上创建队列，该队列只会存在该节点上，其他集群节点不会备份该队列，一旦该节点宕机，该队列中的消息就会丢失(亲测设置持久化也丢失)</li><li>使用镜像队列：可以解决集群模式下，每个机器上只有一个队列的问题，让消息在其他节点再备份一份。开启方式：任何节点添加policy策略即可，该集群就具有镜像队列能力，可设置备份的份数和备份队列规则，即使其中一个节点宕机，也会保证整个集群中保存2份</li><li>高可用负载均衡：haproxy+keepalive，nginx，lvs等实现高可用负载均衡</li><li>其他：Federation Exchange联邦交换机插件解决两地接受消息确认消息延迟问题，也可以用Shovel来做数据同步，需要安装插件</li></ol><h1 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h1><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>死锁：是指一组互相竞争资源的线程，因为互相等待，导致永久阻塞的现象。</p></li><li><p>原因：必须同时满足以下四个条件</p><ol><li>共享互斥条件：共享资源x和y只能被一个线程占用</li><li>占有且等待：线程t1已经占有共享资源x，在等待共享资源y的时候不释放共享资源x</li><li>不可抢占：其他线程不能强行抢占线程t1占有的资源</li><li>循环等待：线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源</li></ol></li><li><p>如何避免死锁：</p><ol><li>既然产生死锁必然满足四个条件，那我们只要打破四个条件中的一个就可以避免，第一个互斥条件是无法被破坏的，因为锁本身就是通过互斥来解决线程安全的</li><li>针对后三个条件，我们逐一分析，占有且等待这个条件我们可以一次性申请所有资源，不存在等待；</li><li>不可抢占这个条件：占有部分资源的线程进一步申请其他资源的时候如果申请不到，可以主动释放已占有的资源，这样不可抢占这条件就破坏了；</li><li>循环等待这个条件：可以按照顺序去申请资源进行预防，就是说资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，线性化之后，就不存在循环等待了</li></ol></li></ul><h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol><li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法</li><li>sleep方法不会释放锁，但是wait会释放，而且会加入到等待队列中</li><li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li><li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li><li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信</li><li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li></ol><p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</p><p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p><h3 id="Volitile作用"><a href="#Volitile作用" class="headerlink" title="Volitile作用"></a>Volitile作用</h3><ol><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。内存屏障-&gt;汇编Lock关键字-&gt;缓存一致性协议</li><li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li><li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性</li></ol><h3 id="Volitile如何保证可见性"><a href="#Volitile如何保证可见性" class="headerlink" title="Volitile如何保证可见性"></a>Volitile如何保证可见性</h3><ol><li><strong>缓存一致性：</strong>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据在主内存和各处理器私有缓存同时存在。当数据的一个副本发生更改，其他副本需要感知到最新修改数据。缓存一致性的手段主要有：</li><li>总线锁定：总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li><li>总线窥探(Bus snooping)：是缓存中的一致性控制器窥探总线事务的一种方案（该方案由Ravishankar和Goodman于1983年提出）当数据被多个缓存共享时，一个处理器修改了共享数据的值，可以是刷新缓存块或使缓存块失效还可以通过缓存块状态的改变，来达到缓存一致性的目的，主要取决于窥探协议类型：<ol><li>写失效（Write-invalidate） ：当一个处理器写入共享缓存时，其他缓存中的所有共享副本都会通过总线窥探失效。确保处理器只能读写一个数据副本，其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</li><li>写更新（Write-update）：当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比写失效协议引起更大的总线流量，因此这种方法不常见。Dragon和firefly协议属于此类别。</li></ol></li></ol><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>Java语言规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义：：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><ol><li>NEW（初始化状态）</li><li>RUNNABLE（可运行状态+运行状态）</li><li>BLOCKED（阻塞状态）</li><li>WAITING（无时限等待）</li><li>TIMED_WAITING（有时限等待）</li><li>TERMINATED（终止状态）</li></ol><p>在操作系统层面，有五种状态，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p><h3 id="linux查看线程命令"><a href="#linux查看线程命令" class="headerlink" title="linux查看线程命令"></a>linux查看线程命令</h3><ul><li><p>ps  - fe 查看所有进程</p></li><li><p>ps  - fT  - p <PID> 查看某个进程（ PID ）的所有线程</p></li><li><p>kill 杀死进程</p></li><li><p>top 按大写  H  切换是否显示线程</p></li><li><p>top  - H  - p <PID> 查看某个进程（ PID ）的所有线程</p></li><li><p>jps 命令查看所有  Java  进程</p></li><li><p>jstack <PID> 查看某个  Java  进程（ PID ）的所有线程状态</p></li><li><p>jconsole 来查看某个  Java  进程中线程的运行情况（图形界面）</p></li></ul><h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><ol><li>方式1：使用 Thread类或继承Thread类</li><li>实现 Runnable 接口配合Thread</li><li>使用有返回值的 Callable，借助线程池使用</li><li>使用 lambda</li></ol><p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><p><strong>sleep方法</strong></p><ul><li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态，不会释放对象锁</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并且会清除中断标志</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>sleep当传入参数为0时，和yield相同</li></ul><p><strong>yield方法</strong></p><ul><li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li><li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li><li>具体的实现依赖于操作系统的任务调度器</li></ul><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal<br>实例，value为线程变量的副本</p><h3 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h3><ol><li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>线程间数据隔离</li><li>进行事务操作，用于存储线程事务信息。</li><li>数据库连接，Session会话管理。<ul><li>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</li></ul></li></ol><h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><ol><li>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li><li>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</li><li>ThreadLocal正确的使用方法<ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任<br>何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul></li></ol><h3 id="synchronized和ReentranLock区别？"><a href="#synchronized和ReentranLock区别？" class="headerlink" title="synchronized和ReentranLock区别？"></a>synchronized和ReentranLock区别？</h3><p>synchronized是jvm层面的关键字，底层是通过monitor对象来完成，monitor对象底层依赖于操作系统的Mutex互斥量，底层调用的是操作系统的Pthread库，是由操作系统来维护的，而操作系统分为用户空间和内核空间的，JVM运行在用户空间，调用底层操作系统cpu会进行一轮状态切换，这个状态切换是比较重型操作，wait/notify等方法也依赖monitor对象只有在同步块或方法中才能调wait/notify等方法。</p><p>Lock是具体类（java.util.concurrent.Locks.Lock)是api层面的锁，是从jdk1.5开始引入的，那个时候synchronized性能还比较差，ReentranLock的出现是为了解决当时性能差的问题</p><ul><li><p>使用方法：synchronized不需要手动释放锁，ReentranLock则需要用户手动释放锁(需要lock()和unlock()配合try/finally使用)</p></li><li><p>等待是否可中断：synchronized不可中断，除非抛出异常或者执行完成，ReentranLock可中断</p></li></ul><ol><li>设置超时方法tryLock(long timeout, timeUnit unit)</li><li>lockInterruptibly()放代码块忠，调用interrupt()方法可中断</li></ol><ul><li><p>加锁是否公平：synchronized非公平锁；ReentranLock 两者都可以，默认非公平锁，构造方法传入true为公平锁，false为非公平锁</p></li><li><p>锁绑定多个条件Condition：synchronized 没有；ReentranLock  用来实现分组唤醒需要唤醒的线程，可以精确唤醒，不像synchronized要么随机唤醒一个线程，要么全部唤醒</p></li></ul><h3 id="线程池参数有，核心线程配置，原因？"><a href="#线程池参数有，核心线程配置，原因？" class="headerlink" title="线程池参数有，核心线程配置，原因？"></a>线程池参数有，核心线程配置，原因？</h3><ol><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务</li><li>keepAliveTime：核心线程外的线程存活超时时间</li><li>unit：时间单位</li><li>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口</li><li>threadFactory：用来创建新线程</li><li>线程池的饱和策略：( AbortPolicy：直接抛出异常，默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务)</li></ol><p><strong>CPU密集型（CPU-bound）</strong></p><p>CPU密集型也叫计算密集型，在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p><p><font color=red face="黑体">线程数 = CPU核数+1 (现代CPU支持超线程)</font> </p><p><strong>IO密集型（I/O bound）</strong></p><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</p><p> <font color=red face="黑体">线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</font> </p><h1 id="七、spring"><a href="#七、spring" class="headerlink" title="七、spring"></a>七、spring</h1><p>spring是一个框架，更像是一个生态环境，在我们的开发流程中，所有的框架基本上都依赖于spring，spring起到了一个IOC容器的作用，用来承载我们整体的bean对象，它帮我们处理了bean对象从创建到销毁的整个生命周期的管理，我们在使用spring的时候，可以使用配置文件，也可以使用注解的方式进行相关开发。spring框架的工作主要流程是，当我们程序开始启动之后，spring把注解或者配置文件定义好的bean对象转化成为BeanDefinitionran，然后通BeanFactoryPostProcessor完成整个的BeanDefinitionran的解析和加载过程，然后根据BeanDefinitionran通过反射的方式创建bean对象，然后进行对象初始化，包括：aware接口相关操作，BeanPostProcessor操作，Init-methord操作完成整个bean的创建过程，之后我们就可以使用了。</p><h3 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uEApmP.png"  /><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uyP4Yq.png"/><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="AOP的顺序"><a href="#AOP的顺序" class="headerlink" title="AOP的顺序"></a>AOP的顺序</h3><p>  spring4和spring5是不一样的</p><h3 id="springMVC处理请求流程"><a href="#springMVC处理请求流程" class="headerlink" title="springMVC处理请求流程"></a>springMVC处理请求流程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/ig6fc0.png" /><h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><ol><li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：支持当前事务，如果没有事务会创建一个新的事务</li><li>TransactionDefinition.PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果没有事务的话以非事务方式执行</li><li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：支持当前事务，如果没有事务抛出异常</li><li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：创建一个新的事务并挂起当前事务</li><li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务则将当前事务挂起</li><li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：以非事务方式进行，如果存在事务则抛出异常</li><li>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ol><h1 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h1><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul><li>第一层：物理层</li><li>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY </li><li>第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP </li><li>第四层：传输层 TCP、UDP、SPX </li><li>第五层：会话层 <strong>RPC</strong>、SQL、NFS 、X WINDOWS、ASP</li><li>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG </li><li>第七层：应用层 HTTP,FTP,SNMP等</li></ul><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/jafyuK.png"/><ol><li>物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；</li><li>数据链路层：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控。可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</li><li>网络层：网络层负责在源和终点之间建立连接。可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</li><li>传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</li><li>会话层：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;</li><li>表示层：表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</li><li>应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;</li></ol><h3 id="http1-0和http1-1区别"><a href="#http1-0和http1-1区别" class="headerlink" title="http1.0和http1.1区别"></a>http1.0和http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ol><h3 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><h3 id="http三次握手四次挥手"><a href="#http三次握手四次挥手" class="headerlink" title="http三次握手四次挥手"></a>http三次握手四次挥手</h3><p>其实这么说是不太准确的，应该说是tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说，tcp可以提供全双工的数据流传输服务</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li><li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li><li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li></ol><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h1 id="十、Dubbo"><a href="#十、Dubbo" class="headerlink" title="十、Dubbo"></a>十、Dubbo</h1><h3 id="你知道的json序列化方式？"><a href="#你知道的json序列化方式？" class="headerlink" title="你知道的json序列化方式？"></a>你知道的json序列化方式？</h3><ol><li>谷歌的Gson</li><li>json-smart：号称是速度最快的JSON解析器</li><li>Common Lang3(3.1)的SerializationUtils</li><li>阿里巴巴的 FastJson、以及 Jackson</li></ol><h3 id="两个系统之间怎么交互的？"><a href="#两个系统之间怎么交互的？" class="headerlink" title="两个系统之间怎么交互的？"></a>两个系统之间怎么交互的？</h3><ol><li> 套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li><li> 可以通过RPC框架（dubbo、feign等）进行远程调用</li><li> 也可以引入消息队列等消息中间件作为系统之间信息交互的桥梁</li><li> 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更</li></ol><h3 id="dubbo的序列化？"><a href="#dubbo的序列化？" class="headerlink" title="dubbo的序列化？"></a>dubbo的序列化？</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。 hessian 是其默认的序列化协议</p><p>dubbo</p><ul><li>提供者(Provider)启动时，会向注册中心写入自己的元数据信息(调用方式)。</li><li>消费者(Consumer)启动时，也会在注册中心写入自己的元数据信息，并且订阅服务提供者，路由和配置元数据的信息。</li><li>服务治理中心(duubo-admin)启动时，会同时订阅所有消费者，提供者，路由和配置元数据的信息。</li><li>当提供者离开或者新提供者加入时，注册中心发现变化会通知消费者和服务治理中心。</li></ul><h1 id="十一、Netty"><a href="#十一、Netty" class="headerlink" title="十一、Netty"></a>十一、Netty</h1><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p> <strong>Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</strong></p><ol><li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li><li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li><li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li></ol><h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现boss和work两个线程池，其中boss的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，交由对应的Handler处理。</p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5cJC8M.png" /><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5N67yC.png"/> <ol><li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</li><li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li><li>NioEventLoopGroup 相当于一个事件循环<strong>线程组</strong>, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</li><li>每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</li><li> 每个BossNioEventLoop线程内部循环执行的步骤有 3 步</li><li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li><li>将NioSocketChannel注册到某个worker  NIOEventLoop上的selector</li><li>处理任务队列的任务 ， 即runAllTasks</li><li>每个workerNIOEventLoop线程循环执行的步骤<ol><li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件</li><li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务</li><li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处理，这样不影响数据在 pipeline 中的流动处理</li></ol></li></ol><h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul><li><p><strong>Bootstrap、ServerBootstrap</strong>：Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p></li><li><p><strong>Future、ChannelFuture</strong>：正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p></li><li><p><strong>Channel</strong>：Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p><ol><li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p></li><li><p>网络连接的配置参数 （例如接收缓冲区大小）</p></li><li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p></li><li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p></li><li><p>支持关联 I/O 操作与对应的处理程序。</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p></li><li><pre><code>NioSocketChannel，异步的客户端 TCP Socket 连接。NioServerSocketChannel，异步的服务器端 TCP Socket 连接。NioDatagramChannel，异步的 UDP 连接。NioSctpChannel，异步的客户端 Sctp 连接。NioSctpServerChannel，异步的 Sctp 服务器端连接。这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</code></pre></li></ol></li><li><p><strong>Selector</strong>：Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p></li><li><p><strong>NioEventLoop</strong>：NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p></li><li><p><strong>NioEventLoopGroup</strong>：NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p></li><li><p><strong>ChannelHandler</strong>：ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p></li><li><p><strong>ChannelHandlerContext</strong>：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p></li><li><p><strong>ChannelPipline</strong>：保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p></li></ul><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/OnweVR.png"/> <p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p><h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。</p><p><strong>解决方案</strong></p><ol><li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p></li><li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</p></li><li><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p><p>Netty提供了多个解码器，可以进行分包的操作，如下：</p><ol><li>LineBasedFrameDecoder （回车换行分包）</li><li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li><li>FixedLengthFrameDecoder（固定长度报文来分包）</li></ol></li></ol><h1 id="十二、zookeeper"><a href="#十二、zookeeper" class="headerlink" title="十二、zookeeper"></a>十二、zookeeper</h1><h4 id="zookeeper的理解"><a href="#zookeeper的理解" class="headerlink" title="zookeeper的理解"></a>zookeeper的理解</h4><ol><li>集群管理：提供了CP模型来保证集群中每个节点的数据一致性</li><li>分布式锁</li><li>集群选举</li></ol><h4 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h4><ul><li>LeaderElection  </li><li>AuthFastLeaderElection</li><li>FastLeaderElection （最新默认）</li></ul><p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p><ul><li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。</li><li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li><li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li><li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li><li>服务器5启动，后面的逻辑同服务器4成为小弟。</li></ul><h1 id="十三、理论"><a href="#十三、理论" class="headerlink" title="十三、理论"></a>十三、理论</h1><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>​        CAP 理论又叫 Brewer 理论，这是加州大学伯克利分校的埃里克 · 布鲁尔（Eric Brewer）教授，在 2000 年 7 月“ACM 分布式计算原理研讨会（PODC）”上提出的一个猜想。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~brewer%2Fcs262b-2004%2FPODC-keynote.pdf">CAP理论原稿</a>（那时候还只是猜想）然后到了 2002 年，麻省理工学院的赛斯 · 吉尔伯特（Seth Gilbert）和南希 · 林奇（Nancy Lynch）就以严谨的数学推理证明了这个 CAP 猜想。在这之后，CAP 理论就正式成为了分布式计算领域公认的著名定理。这个定理里，描述了一个分布式的系统中，当涉及到共享数据问题时，以下三个特性最多只能满足其中两个：</p><ol><li>一致性（Consistency）：代表在任何时刻、任何分布式节点中，我们所看到的数据都是没有矛盾的。这与 ACID 中的 C 是相同的单词，但它们又有不同的定义（分别指 Replication 的一致性和数据库状态的一致性）。在分布式事务中，ACID 的 C 要以满足 CAP 中的 C 为前提。</li><li>可用性（Availability）：代表系统不间断地提供服务的能力。</li><li>分区容忍性（Partition Tolerance）：代表分布式环境中，当部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</li></ol><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3MTQwNDEyMg==&amp;mid=2247483680&amp;idx=1&amp;sn=a844dc83df3316ac0102ea11511b8b46&amp;chksm=fce1fb15cb9672032e98857a74f4e971a1ff833a6e353cafee655587c70a93e730a652daf5a2&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3MTQwNDEyMg==&amp;mid=2247483680&amp;idx=1&amp;sn=a844dc83df3316ac0102ea11511b8b46&amp;chksm=fce1fb15cb9672032e98857a74f4e971a1ff833a6e353cafee655587c70a93e730a652daf5a2&amp;scene=21#wechat_redirect</a></p><h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>ddd不是一种架构风格，而是一种方法论，什么是方法论，每个人按照自己的想法来设计就是一套方法论；ddd是一种业务比较认可，对于微服务拆分的一种方法论。</p><h1 id="十四、项目"><a href="#十四、项目" class="headerlink" title="十四、项目"></a>十四、项目</h1><ol><li>最近做的比较熟悉的项目是哪个？画一下项目技术架构图</li><li>写两个类，能够实现堆内存溢出和栈内存溢出</li><li>写一个线程安全的单例。</li><li>两个可变有序链表放到新数组中，有序</li></ol><h3 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h3><p>ES他是建立在全文搜索引擎库ApacheLucene基础上的一个开源搜索和分析引擎，ES本身具有一个分布式存储，检索速度快的特性，所以我们经常用它去实现全文检索这一类的场景，比如像网站搜索，公司内部用ELK做日志聚集和检索，来去快速查找服务器的日志记录，去定位问题，基本上涉及到TB级别的数据场景，用ES是一个比较好的选择</p><h4 id="ES查询快的原因"><a href="#ES查询快的原因" class="headerlink" title="ES查询快的原因"></a>ES查询快的原因</h4><ol><li>第一、Lucene是擅长管理大量的索引数据的，另一方面他会对数据进行分词以后在保存索引，这样能搞提升数据的检索效率</li><li>第二、ES采用倒排索引，所谓倒排索引，就是通过属性值来确定数据记录的位置的索引，来避免全表扫描这样一个问题，</li><li>第三、ES采用分片存储机制</li><li>第四、ES扩展性好，我们可以水平扩展增加服务器，提升ES处理性能，可以达到百台服务器节点扩展</li><li>第五、ES内部提供了数据汇总和索引生命周期管理的一些功能，可以方便我们更加高效的存储和搜索数据</li></ol><h4 id="使用ES注意事项"><a href="#使用ES注意事项" class="headerlink" title="使用ES注意事项"></a>使用ES注意事项</h4><ol><li>ES里面不建议使用复杂的关联查询，会对性能影响很大</li><li>避免深度分页查询，因为ES分页是支持front和size参数，在查询的时候，每个分片必须构造一个长度为front加size的优先队列，然后回传到网关节点，网关节点再对这些队列进行排序再找到正确的size文档。而当front足够大的时候容易造成OOM以及网络传输性能差的一些问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql面试</title>
      <link href="/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/"/>
      <url>/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="1-索引底层结构-amp-行格式-amp-页格式"><a href="#1-索引底层结构-amp-行格式-amp-页格式" class="headerlink" title="1.索引底层结构&amp;行格式&amp;页格式"></a>1.索引底层结构&amp;行格式&amp;页格式</h2><p>文章内容包含索引结构，联合索引结构，聚簇索引、非聚簇索引区别，在页上如何搜索具体数据过程，一次完成的索引检索过程</p><p>地址：<a href="/2022/01/05/7.mysql/行页索引底层结构" target="_blank">行页索引底层结构</a></p><h2 id="2-一条-SQL-的执行过程详解"><a href="#2-一条-SQL-的执行过程详解" class="headerlink" title="2.一条 SQL 的执行过程详解"></a>2.一条 SQL 的执行过程详解</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/jK9nFC.png" alt="image-20220402151247405"></p><p>从准备更新一条数据到事务的提交的流程描述</p><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li><li>将本次操作记录写入到 bin log文件中</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li></ul><p>至此表示整个更新事务已经完成</p><p><strong>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</strong></p><p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。</p><p>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是<strong>更新内存BufferPool</strong>，然后<strong>顺序写日志文件</strong>，同时还能</p><p>保证各种异常情况下的数据一致性。</p><p>更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。</p><p>正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干的读写请求。</p><p>细节介绍server层连接器、词法分析器、优化器、执行器、查询缓存功能见单独文章</p><p>地址：<a href="/2022/04/02/7.mysql/mysql执行流程" target="_blank">mysql执行流程</a></p><h2 id="3-ACID及实现原理"><a href="#3-ACID及实现原理" class="headerlink" title="3.ACID及实现原理"></a>3.ACID及实现原理</h2><ul><li>（Atomicity）原子性： 事务是最小的执行单位，不允许分割。要么全都执行,要么全都不执行；——-&gt;原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时，撤销已经执行成功的sql</li><li>（Consistency）一致性： 执行事务前后，数据保持一致；——-&gt;原子性、隔离性、持久性就是为了来保证一致性</li><li>（Isolation）隔离性： 并发访问数据库时，一个事务不被其他事务所干扰，数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行；——-&gt;锁机制和MVCC共同实现</li><li>（Durability）持久性: 一个事务被提交之后。对数据库中数据的改变是持久的，即使数据库发生故障也不会受到影响。——-&gt;持久性由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。</li></ul><h2 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h2><p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p><p>MVCC主要解决三个问题：</p><p>第一、通过MVCC可以解决读写并发阻塞问题，从而提高数据库的并发处理能力；</p><p>第二、MVCC采用的是乐观锁的方式实现，降低了死锁的概率；</p><p>第三、解决了一致性读的问题，也就是事务启动的时候，根据某个条件去读取到的数据，知道事务结束的时候再去执行相同条件，还是读到同一份数据，不会发生变化变化。</p><p><strong>MVCC用于读已提交（RC）和可重复读级别（RR）的控制，主要通过undo log日志版本链和read view来实现，</strong></p><p>InnoDB中MVCC的实现依赖四个条件: 隐藏字段, 事务链表，read view, undo log</p><p>数据表额外字段</p><p><strong>DB_TRX_ID(6字节)</strong>: 在innoDB中, 会为每个事物分配一个事务ID. 而该字段表示的就是插入或更新该行的最后一个事务的事务标识符.</p><p><strong>DB_ROLL_PTR(7字节)</strong>: 这个字段称为回滚指针, 指向了回滚段的撤销日志. (undo log)</p><p><strong>DB_ROW_ID(6字节)</strong>:  这个字段包含了一个行ID. 该ID在插入新行时会单调增加. 这个字段是为了在表里没有主键ID的时候, 生成聚簇索引使用的.</p><p>rowid存的是什么？</p><p>rowid默认是主键，如果没有主键，会选择唯一键，如果没有唯一键，会生成6字节的rowid</p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/7Syg8j.png" alt="聚簇索引行结构" style="zoom: 67%;" /><p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚</p><p>日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kP6kYm.png" alt="image-20220407160145376"></p><p>在<strong>可重复读隔离级别（RR）</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束</p><p>之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>)，这个视图由执行查询时所有未提交事</p><p>务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应</p><p>版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p><p><strong>版本链比对规则：</strong></p><ol><li><p>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的；</p></li><li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若</p></li></ol><p>row 的 trx_id 就是当前自己的事务是可见的）；3. 如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况</p><p>​        a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自</p><p>己的事务是可见的)；</p><p>​        b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</p><p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的</p><p>trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被</p><p>删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数</p><p>据。</p><p><strong>注意：</strong>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句，</p><p>事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。</p><p><strong>总结：</strong></p><p>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取</p><p>同一条数据在版本链上的不同版本数据。</p><h2 id="5-mysql三大日志"><a href="#5-mysql三大日志" class="headerlink" title="5.mysql三大日志"></a>5.mysql三大日志</h2><p>地址：<a href="/2021/12/27/7.mysql/mysql三大日志" target="_blank">mysql三大日志</a></p><h2 id="6-redo日志"><a href="#6-redo日志" class="headerlink" title="6.redo日志"></a>6.redo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/redo日志" target="_blank">redo日志</a></p><h2 id="7-undo日志"><a href="#7-undo日志" class="headerlink" title="7.undo日志"></a>7.undo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/undo日志" target="_blank">undo日志</a></p><h2 id="8-能说下myisam-和-innodb的区别吗"><a href="#8-能说下myisam-和-innodb的区别吗" class="headerlink" title="8.能说下myisam 和 innodb的区别吗"></a>8.能说下myisam 和 innodb的区别吗</h2><table><thead><tr><th>区别</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>索引</td><td>聚簇索引和非聚簇索引</td><td>非聚簇索引</td></tr><tr><td>行锁</td><td>支持</td><td>不支持</td></tr><tr><td>表锁</td><td>支持</td><td>支持</td></tr><tr><td>存储文件</td><td>frm(表结构)，ibd(数据和索引)</td><td>frm，myi(索引文件)，myd(数据文件)</td></tr><tr><td>具体行数</td><td>全表扫描统计行数</td><td>通过变量保存行数</td></tr></tbody></table><ul><li>MyISAM不支持事务，在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li><li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，(因为有mvcc机制)不会加锁。但是update、insert、delete操作会加行锁。简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</li></ul><h2 id="9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"><a href="#9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别" class="headerlink" title="9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"></a>9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别</h2><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p><h2 id="10-什么是覆盖索引和回表"><a href="#10-什么是覆盖索引和回表" class="headerlink" title="10.什么是覆盖索引和回表"></a>10.什么是覆盖索引和回表</h2><p>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。</p><p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助 索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为回表。也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树—-一次辅助索引，一次聚集索引。</p><h2 id="11-mysql的各种锁。-间隙锁"><a href="#11-mysql的各种锁。-间隙锁" class="headerlink" title="11.mysql的各种锁。  间隙锁"></a>11.mysql的各种锁。  间隙锁</h2><p>锁分类图解</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/SNv09f.png" alt="image-20220407172447222"></p><p><strong>按照兼容性分类</strong></p><p>InnoDB实现了以下两种类型的行锁。</p><p><strong>「共享锁（S)」</strong>：又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据， 但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p><p><strong>「排他锁（X)」</strong>：exclusive lock（也叫writer lock）又称写锁。 若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前， 其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。 <strong>「排它锁是悲观锁的一种实现」</strong>。</p><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），<code>这两种意向锁都是表锁</code>。</p><p><strong>「意向共享锁（IS）」</strong>：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p><p><strong>「意向排他锁（IX）」</strong>：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p><p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p><strong>「InnoDB行锁模式兼容性列表」</strong></p><table><thead><tr><th>请求锁模式 是否兼容当前锁模式</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT写操作，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p><p>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p><p>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在， 并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作， 则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p><p>InnoDB在事务执行过程中，使用<code>两阶段锁协议</code>：</p><p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p><p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p><p><strong>按算法分类</strong></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/acUCbj.jpg" alt="img"></p><p><strong>「Record Lock」</strong>： 单个行记录上的锁</p><p>锁总会锁住索引记录，锁住的是key。</p><p>如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB会使用隐式的主键进行锁定。</p><p>如果要锁的没有索引，则会进行全表记录加锁。</p><p><strong>「Gap Lock」</strong> ：间隙锁，锁定一个范围，但不包含记录本身</p><p>锁定索引记录间隙，确保索引记录的间隙不变</p><p>间隙锁时针对事务隔离级别为可重复读或以上级别而配的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读</span><br></pre></td></tr></table></figure><p><strong>「Next-Key Lock」</strong>：临键锁，Gap Lock + Record Lock，锁定一个范围，并且包含记录本身</p><p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p><p>当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。</p><h2 id="12-MRR"><a href="#12-MRR" class="headerlink" title="12.MRR"></a>12.MRR</h2><p>每次从二级索引中读取到一条记录后，就会根据该记录的主键值 执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些</p><p>二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。 每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的 性能开销比较大。MySQL中提出了一个名为Disk-Sweep Multi-Range Read (MRR，多范围 读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执 行回表操作。</p><p>相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个 MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。</p><h2 id="13-分库分表"><a href="#13-分库分表" class="headerlink" title="13.分库分表"></a>13.分库分表</h2><h2 id="14-分布式唯一id"><a href="#14-分布式唯一id" class="headerlink" title="14.分布式唯一id"></a>14.分布式唯一id</h2><h2 id="15-数据库三大范式是什么"><a href="#15-数据库三大范式是什么" class="headerlink" title="15.数据库三大范式是什么"></a>15.数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="16-InnoDB引擎的4大特性"><a href="#16-InnoDB引擎的4大特性" class="headerlink" title="16.InnoDB引擎的4大特性"></a>16.InnoDB引擎的4大特性</h2><p>插入缓冲（insert buffer)</p><p>二次写(double write)</p><p>自适应哈希索引(ahi)</p><p>预读(read ahead)</p><h2 id="17-索引失效的情况"><a href="#17-索引失效的情况" class="headerlink" title="17.索引失效的情况"></a>17.索引失效的情况</h2><p>谈到索引主要从两方面来分析：IO 和数据结构：不管索引数据还是行数据，都是存在磁盘里面的，我们尽可能少的取出数据</p><ul><li>IO—–&gt;读取次数少、量少——&gt;分块读取——&gt;局部性原理、磁盘预读</li><li>数据结构——&gt;B+树——&gt;二叉树、AVL树、红黑树、B树</li></ul><ol><li>组合索引不遵循最左匹配原则</li><li>组合索引前面索引列使用范围查询(&lt;,&gt;,like),会导致后续索引失效；</li><li>不要在索引上做任何操作（计算，函数，类型转换）</li><li>is null和is not null 无法使用索引</li><li>尽量少使用or操作符，否则连接时索引会失效</li><li>字符串不添加引号会导致索引失效（隐式类型转换）</li><li>两表关联使用的条件字段中字段的长度，编码不一致会导致索引失效</li><li>like语句中，以%开头的模糊查询会导致索引失效</li><li>如果mysql中使用全表扫描比索引快，也会导致索引失效 （force index:强制使用索引）</li></ol><h2 id="18-最左前缀原则。-联合索引使用分析实战"><a href="#18-最左前缀原则。-联合索引使用分析实战" class="headerlink" title="18.最左前缀原则。 联合索引使用分析实战"></a>18.最左前缀原则。 联合索引使用分析实战</h2><p>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>实战？？</p><h2 id="19-sql优化之explain-详解"><a href="#19-sql优化之explain-详解" class="headerlink" title="19.sql优化之explain 详解"></a>19.sql优化之explain 详解</h2><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL</p><p>接下来我们将展示 explain 中每个列的信息</p><p><strong>19.1. id列</strong></p><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。</p><p>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><p><strong>19.2. select_type列</strong></p><p>select_type 表示对应行是简单还是复杂的查询。</p><p>1）simple：</p><p>简单查询。查询不包含子查询和union</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film where id = 2; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/T5Cula.png" alt="image-20220407160800996"></p><p>2）primary：</p><p>复杂查询中最外层的 select</p><p>3）subquery：</p><p>包含在 select 中的子查询（不在 from 子句中）</p><p>4）derived：</p><p>包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p><p>用这个例子来了解 primary、subquery 和 derived 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 </span><br><span class="line"></span><br><span class="line">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/q2w4D3.png" alt="image-20220407161247159"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置 </span><br></pre></td></tr></table></figure><p>5）union：</p><p>在 union 中的第二个和随后的 select</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kCABNr.png" alt="image-20220407161256284"></p><p><strong>19.3. table列</strong></p><p>这一列表示 explain 的一行正在访问哪个表。</p><p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查</p><p>询。</p><p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p><p><strong>19.4. type列</strong></p><p>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。</p><p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p><p>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong></p><p><strong>NULL</strong>：</p><p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可</p><p>以单独查找索引来完成，不需要在执行时访问表</p><p>1 mysql&gt; explain select min(id) from film;</p><p><strong>const, system</strong>：</p><p>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于</p><p>primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是</strong></p><p><strong>const的特例</strong>，表里只有一条元组匹配时为system</p><p>1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</p><p>1 mysql&gt; show warnings;</p><p><strong>eq_ref</strong>：</p><p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在</p><p>const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><p>1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</p><p><strong>ref</strong>：</p><p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会</p><p>找到多个符合条件的行。</p><ol><li>简单 select 查询，name是普通索引（非唯一索引）</li></ol><p>1 mysql&gt; explain select * from film where name = ‘film1’;</p><p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</p><p>1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.fi</p><p>lm_id;</p><p><strong>range</strong>：</p><p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p><p>1 mysql&gt; explain select * from actor where id &gt; 1;<strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接</p><p>对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这</p><p>种通常比ALL快一些。</p><p>1 mysql&gt; explain select * from film;</p><p><strong>ALL</strong>：</p><p>即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p><p>1 mysql&gt; explain select * from actor;</p><p><strong>19.5. possible_keys列</strong></p><p>这一列显示查询可能使用哪些索引来查找。</p><p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引</p><p>对此查询帮助不大，选择了全表查询。</p><p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提</p><p>高查询性能，然后用 explain 查看效果。</p><p><strong>19.6. key列</strong></p><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p><p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force</p><p>index、ignore index。</p><p><strong>19.7. key_len列</strong></p><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p><p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通</p><p>过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id = 2; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/euMjk1.png" alt="image-20220407162337179"></p><p>key_len计算规则如下：</p><p><strong>字符串</strong>，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数，</strong>如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节</p><p>​            char(n)：如果存汉字长度就是 3n 字节</p><p>​            varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</p><p><strong>数值类型</strong></p><p>​            tinyint：1字节</p><p>​            smallint：2字节</p><p>​            int：4字节</p><p>​            bigint：8字节</p><p><strong>时间类型</strong></p><p>​            date：3字节timestamp：4字节</p><p>​            datetime：8字节</p><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><p><strong>19.8. ref列</strong></p><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p><p><strong>19.9. rows列</strong></p><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p><p><strong>19.10. Extra列</strong></p><p>这一列展示的是额外信息。常见的重要值如下：</p><p>1）<strong>Using index</strong>：使用覆盖索引</p><p><strong>覆盖索引定义</strong>：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select film_id from film_actor where film_id = 1; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/HDa0QJ.png" alt="image-20220407162614921"></p><p>2）<strong>Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor where name = &#x27;a&#x27;; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TCOus4.png" alt="image-20220407162649995"></p><p>3）<strong>Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id &gt; 1; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/R67z2o.png" alt="image-20220407162726922"></p><p>4）<strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索</p><p>引来优化。</p><ol><li>actor.name没有索引，此时创建了张临时表来distinct</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from actor; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/zN1qNX.png" alt="image-20220407162748356"></p><ol start="2"><li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from film; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TJBQvc.png" alt="image-20220407162804564"></p><p>5）<strong>Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/bvNR53.png" alt="image-20220407162837176"></p><ol start="2"><li>film.name建立了idx_name索引,此时查询时extra是using index</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film order by name; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/LmfAA3.png" alt="image-20220407162904215"></p><p>6）<strong>Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select min(id) from film; </span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/XKI9h9.png" alt="image-20220407162921288"></p><h2 id="20-mysql主从复制原理"><a href="#20-mysql主从复制原理" class="headerlink" title="20.mysql主从复制原理"></a>20.mysql主从复制原理</h2><ol><li><p>master提交完事务后，写入binlog</p></li><li><p>slave连接到master，获取binlog</p></li><li><p>master创建dump线程，推送binglog到slave</p></li><li><p>slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中</p></li><li><p>slave再开启一个sql线程读取relay log事件并在slave执行，完成同步</p></li><li><p>slave记录自己的binglog</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/yEQbgw.jpeg" alt="图片"></p></li></ol><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/wfHRhP.png"/><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="21-主从同步延时如何解决"><a href="#21-主从同步延时如何解决" class="headerlink" title="21.主从同步延时如何解决"></a>21.主从同步延时如何解决</h2><h2 id="22-隔离级别"><a href="#22-隔离级别" class="headerlink" title="22.隔离级别"></a>22.隔离级别</h2><p>首先回忆四种mysql隔离级别</p><table><thead><tr><th align="left">隔离级别</th><th>说明</th></tr></thead><tbody><tr><td align="left">读未提交（Read uncommitted）</td><td>一个事务还没提交时，它做的变更就能被别的事务看到</td></tr><tr><td align="left">读提交（Read committed）</td><td>一个事务提交之后，它做的变更才会被其他事务看到。出 于性能考虑互联网公司会使用RC+乐观锁</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td>一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。<strong>InnoDB默认级别</strong>。</td></tr><tr><td align="left">串行化（Serializable ）</td><td>事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，隔离级别最高，牺牲系统并发性。</td></tr></tbody></table><p>查看当前数据库的事务隔离级别:show variables like ‘%tx_isolation%’;</p><p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p><p>不同的隔离级别是为了解决不同的问题。也就是脏读、幻读、不可重复读。</p><p><strong>脏读</strong>：事务A读取到了事务B已经修改但尚未提交的数据，。</p><p><strong>不可重复读</strong>：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。</p><p><strong>幻读</strong>：事务A读取到了事务B提交的新增数据，不符合隔离性</p><p><strong>不可重复读&amp;&amp;幻读区别</strong></p><p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p><p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>读未提交</td><td>可以出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>读提交</td><td>不允许出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>可重复读</td><td>不允许出现</td><td>不允许出现</td><td>可以出现</td></tr><tr><td>序列化</td><td>不允许出现</td><td>不允许出现</td><td>不允许出现</td></tr></tbody></table><p><strong>不同的隔离级别下，隔离性是靠锁机制和MVCC共同实现的。</strong></p><h2 id="23-RC和RR的本质区别。readview层面"><a href="#23-RC和RR的本质区别。readview层面" class="headerlink" title="23.RC和RR的本质区别。readview层面"></a>23.RC和RR的本质区别。readview层面</h2><p><strong>RC级别下每次都是重新生成read view，而在RR级别下则是一直使用事务内第一次查询时产生的read view。</strong></p><h2 id="24-什么是readview"><a href="#24-什么是readview" class="headerlink" title="24.什么是readview"></a>24.什么是readview</h2><p>ReadView可以理解为一个数据结构，在事务开始的时候会根据事务链表构造一个ReadView,初始化方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// readview 初始化</span><br><span class="line">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span><br><span class="line">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::memset(&amp;m_view_list, 0x0, sizeof(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trx_ids</code>: 表示事务开启的时候, 其它未提交的活跃的事务ID. 这个集合中的事务对于当前事务来说, 一直都是不可见的.</p><p><code>low_limit_id</code>: 表示在生成ReadView时当前系统中最大事务id.</p><p><code>up_limit_id</code>: 表示未提交活跃事务Id(trx_ids)的最大值. 如果trx_ids为空, 则up_limit_id=low_limit_id.</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/vsg7bA.png" alt="readview"></p><p>通过该ReadView，新的事务可以根据查询到的所有活跃事务记录的事务ID来匹配能够看见该记录，从而实现数据库的事务隔离，主要逻辑如下：</p><p>通过聚簇索引的行结构中DB_TRX_ID隐藏字段可以知道最近被哪个事务ID修改过。一个新的事务开始时会根据事务链表构造一个ReadView。当前事务根据ReadView中的数据去跟检索到的每一条数据去校验,看看当前事务是不是能看到这条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 判断数据对应的聚簇索引中的事务id在这个readview中是否可见</span><br><span class="line">bool changes_visible(</span><br><span class="line">        trx_id_t        id, // 记录的id</span><br><span class="line">    const table_name_t&amp; name) const</span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id &gt; 0);</span><br><span class="line">    // 如果当前记录id &lt; 事务链表的最小值或者等于创建该readview的id就是它自己,那么是可见的</span><br><span class="line">    if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    // 如果该记录的事务id大于事务链表中的最大值,那么不可见</span><br><span class="line">    if (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">        return(false);</span><br><span class="line">        // 如果事务链表是空的,那也是可见的</span><br><span class="line">    &#125; else if (m_ids.empty()) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ids_t::value_type*    p = m_ids.data();</span><br><span class="line"></span><br><span class="line">    //判断是否在ReadView中，如果在说明在创建ReadView时 此条记录还处于活跃状态则不应该查询到，否则说明创建ReadView是此条记录已经是不活跃状态则可以查询到</span><br><span class="line">    return(!std::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见性算法逻辑总结：</p><ol><li>当检索到的数据的事务ID小于事务链表中的最小值(数据行的DB_TRX_ID &lt; m_up_limit_id)表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li><li>当检索到的数据的事务ID表示的是当前事务自己修改的数据(数据行的DB_TRX_ID = m_creator_trx_id) 时，数据可见。</li><li>当检索到的数据的事务ID大于事务链表中的最大值(数据行的DB_TRX_ID &gt;= m_low_limit_id) 表示这个数据在当前事务开启后到下一次查询之间又被其他的事务修改过,那么就是不可见的。</li><li>如果事务链表为空,那么也是可见的,也就是当前事务开始的时候,没有其他任意一个事务在执行。</li><li>当检索到的数据的事务ID在事务链表中的最小值和最大值之间，从m_low_limit_id到m_up_limit_id进行遍历，取出DB_ROLL_PTR指针所指向的回滚段的事务ID，把它赋值给 trx_id_current ，然后从步骤1重新开始判断，这样总能最后找到一个可用的记录。</li></ol><h2 id="25-快照读与当前读的区别"><a href="#25-快照读与当前读的区别" class="headerlink" title="25.快照读与当前读的区别"></a>25.快照读与当前读的区别</h2><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><p><strong>快照读</strong>：就是select</p><ul><li>select * from table ….;</li></ul><p><strong>当前读</strong>：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert;</li><li>update ;</li><li>delete;</li></ul><h2 id="26-幻读和不可重复读区别"><a href="#26-幻读和不可重复读区别" class="headerlink" title="26.幻读和不可重复读区别"></a>26.幻读和不可重复读区别</h2><p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p><p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p><h2 id="27-MySQL在RR级别中完全解决了幻读的问题么？"><a href="#27-MySQL在RR级别中完全解决了幻读的问题么？" class="headerlink" title="27.MySQL在RR级别中完全解决了幻读的问题么？"></a>27.MySQL在RR级别中完全解决了幻读的问题么？</h2><h2 id="28-脏页是什么，刷脏页时机"><a href="#28-脏页是什么，刷脏页时机" class="headerlink" title="28.脏页是什么，刷脏页时机"></a>28.脏页是什么，刷脏页时机</h2><h2 id="29-bufferpool"><a href="#29-bufferpool" class="headerlink" title="29.bufferpool"></a>29.bufferpool</h2><h2 id="30-几大核心线程"><a href="#30-几大核心线程" class="headerlink" title="30.几大核心线程"></a>30.几大核心线程</h2><p><strong>purge线程</strong></p><p>对于一条delete语句 delete from t where a = 1，如果列a有聚集索引，则不会进行真正的删除，而只是在主键列等于1的记录delete flag设置为1，即记录还是存在在B+树中。而对于update操作，不是直接对记录进行更新，而是标识旧记录为删除状态，然后新产生一条记录。那这些旧版本标识位删除的记录何时真正的删除？怎么删除？</p><p>其实InnoDB是通过undo日志来进行旧版本的删除操作的，在InnoDB内部，这个操作被称之为purge操作，原来在srv_master_thread主线程中完成，后来进行优化，开辟了purge线程进行purge操作，并且可以设置purge线程的数量。purge操作每10s进行一次。</p><p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行连接，如下面的一种情况：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Zxv9V3.png" alt="purge"></p><p>在执行purge过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1所在的Undo page中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故再去history list中取查找，发现最尾端的记录时trx2，接着找到trx2所在的Undo page，依次把trx6、trx4清理，由于Undo page2中所有的记录都被清理了，因此该Undo page可以进行重用。</p><p>InnoDB存储引擎这种先从history list中找undo log，然后再从Undo page中找undo log的设计模式是为了避免大量随机读操作，从而提高purge的效率。</p><h2 id="31-事务传播机制"><a href="#31-事务传播机制" class="headerlink" title="31.事务传播机制"></a>31.事务传播机制</h2><h2 id="32-分布式事务通用方案"><a href="#32-分布式事务通用方案" class="headerlink" title="32.分布式事务通用方案"></a>32.分布式事务通用方案</h2><h2 id="33-成本分析"><a href="#33-成本分析" class="headerlink" title="33.成本分析"></a>33.成本分析</h2><h2 id="34-表中数据量如何计算总量"><a href="#34-表中数据量如何计算总量" class="headerlink" title="34.表中数据量如何计算总量"></a>34.表中数据量如何计算总量</h2><h2 id="35-count-1-count-count-id-count-字段-性能对比分析"><a href="#35-count-1-count-count-id-count-字段-性能对比分析" class="headerlink" title="35.count(1) count(*) count(id) count(字段) 性能对比分析"></a>35.count(1) count(*) count(id) count(字段) 性能对比分析</h2><p><strong>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</strong></p><p><strong>字段有索引：count(*)≈count(1)&gt;count(字段)&gt;count(主键 id) //字段有索引，count(字段)统计走二级索引，二</strong></p><p><strong>级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</strong></p><p><strong>字段无索引：count(*)≈count(1)&gt;count(主键 id)&gt;count(字段) //字段没有索引count(字段)统计走不了索引，</strong></p><p><strong>count(主键 id)还可以走主键索引，所以count(主键 id)&gt;count(字段)</strong></p><p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出</p><p>字段，所以理论上count(1)比count(字段)会快一点。</p><p>count(*) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用</p><p>count(列名)或count(常量)来替代 count(*)。</p><p>为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引？因为二级索引相对主键索引存储数据更少，检索</p><p>性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)。</p><h2 id="36-mysql中in-和exists-区别"><a href="#36-mysql中in-和exists-区别" class="headerlink" title="36.mysql中in 和exists 区别"></a>36.mysql中in 和exists 区别</h2><h2 id="37-join查询原理"><a href="#37-join查询原理" class="headerlink" title="37.join查询原理"></a>37.join查询原理</h2><h2 id="38-索引下推"><a href="#38-索引下推" class="headerlink" title="38.索引下推"></a>38.索引下推</h2><p><strong>索引下推</strong>（Index Condition Pushdown，<strong>ICP</strong>), like KK%其实就是用到了索引下推优化</p><p><strong>什么是索引下推了？</strong></p><p>对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，<strong>SELECT * FROM employees WHERE name like ‘LiLei%’</strong></p><p><strong>AND age = 22 AND position =’manager’</strong> 这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和</p><p>position是无序的，无法很好的利用索引。</p><p>在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索</p><p>引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。</p><p>MySQL 5.6引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可</strong></p><p><strong>以有效的减少回表次数</strong>。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过</p><p>滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</p><p>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全</p><p>行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p><p><strong>个人理解升华：</strong></p><p>我觉得like是这样，用到索引下推的场景，直接利用三个索引都过滤玩，然后回表查数据;</p><p>关闭索引下推，利用的第一个索引完成过滤，直接回表，然后继续在server层对第二三字段过滤,都是用到了三个字段，但是第二三个字段用的地方不一样</p><p><strong>为什么范围查找Mysql没有用索引下推优化？</strong></p><p>然后理论上like和大于小于都是range类型，只不过大于小于这种有点正负无穷的感觉，所以mysql没有特殊处理，like ‘xx%’ mysql默认认为范围可控，就使用刚才的逻辑来处理，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p><h2 id="39-两种排序方式"><a href="#39-两种排序方式" class="headerlink" title="39.两种排序方式"></a>39.两种排序方式</h2><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</p><h2 id="40-filesort排序原理"><a href="#40-filesort排序原理" class="headerlink" title="40.filesort排序原理"></a>40.filesort排序原理</h2><p><strong>Using filesort文件排序原理详解</strong></p><p><strong>filesort文件排序方式</strong></p><p>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可</p><p>以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key,</p><p>packed_additional_fields &gt;</p><p>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong></p><p><strong>数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具</p><p>可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</p><p>MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来</p><h2 id="41-filesort判断使用哪种排序模式。-（单路or双路）"><a href="#41-filesort判断使用哪种排序模式。-（单路or双路）" class="headerlink" title="41.filesort判断使用哪种排序模式。 （单路or双路）"></a>41.filesort判断使用哪种排序模式。 （单路or双路）</h2><p>如果 字段的总长度小于max_length_for_sort_data ，那么使用 单路排序模式；</p><p>如果 字段的总长度大于max_length_for_sort_data ，那么使用 双路排序模∙式。</p><h2 id="40-单路排序、双路排序详细过程"><a href="#40-单路排序、双路排序详细过程" class="headerlink" title="40.单路排序、双路排序详细过程"></a>40.单路排序、双路排序详细过程</h2><p>我们先看<strong>单路排序</strong>的详细过程：</p><ol><li><p>从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id</p></li><li><p>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中</p></li><li><p>从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id</p></li><li><p>重复步骤 2、3 直到不满足 name = ‘zhuge’</p></li><li><p>对 sort_buffer 中的数据按照字段 position 进行排序</p></li><li><p>返回结果给客户端</p></li></ol><p>我们再看下<strong>双路排序</strong>的详细过程：</p><ol><li><p>从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id</p></li><li><p>根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中</p></li><li><p>从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id</p></li><li><p>重复 3、4 直到不满足 name = ‘zhuge’</p></li><li><p>对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序</p></li><li><p>遍历排序好的 id 和字段 position，按照 id 的值<strong>回到原表</strong>中取出 所有字段的值返回给客户端</p></li></ol><p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p><h2 id="41-三星索引"><a href="#41-三星索引" class="headerlink" title="41.三星索引"></a>41.三星索引</h2><p>对于一个查询而言，一个三星索引，可能是其最好的索引。</p><p>索引将相关的记录放到一起则获得一星；</p><p>如果索引中的数据顺序和查找中的排列顺序一致则获得二星；</p><p>如果索引中的列包含了查询中需要的全部列则获得三星。</p><h2 id="42-场景题"><a href="#42-场景题" class="headerlink" title="42.场景题"></a>42.场景题</h2><p>新建一张数据表user，后续所有操作都依托于初始化的这三条数据。</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr></tbody></table><hr><p>操作1：</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td></td><td>update user set name=’zhangsan2’ where age=1;<br>commit;</td></tr><tr><td>3</td><td>select * from user where age=1;</td><td></td></tr></tbody></table><p>此时不管是RC还是RR，t1的select都能够读取到t2update的值</p><p>因为在t1select的时刻才会去生成read view，根据可见性算法得出能看到最新的t2数据</p><hr><p>操作2:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td>select * from user where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>update user set name=’zhangsan2’ where age=1;<br/>commit;</td></tr><tr><td>4</td><td>select * from user where age=1;</td><td></td></tr></tbody></table><p>此时RC级别下，t1的 第二次select能够查看到t2update的值，因为RC级别下每次select都会生成新的read view</p><p>在RR级别下，t1的 第二次不能查询到t2update的值，因为RR级别下的后面查询都是使用的第一次select生成的read view</p><p>同理，t2语句为insert时也是一样的情况。</p><hr><p>操作3:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td></td><td>update user set name=’zhangsan2’ where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>insert into user values (4,’haha’,3);<br/>waiting~~~</td></tr><tr><td>5</td><td>commit;</td><td></td></tr><tr><td>6</td><td></td><td>插入成功<br>commit;</td></tr></tbody></table><p>RR级别下，t1进行当前读时，会对数据加锁，具体是间隙锁｜行锁｜next-key，后面细说，此时t2的插入会waiting，直到t1释提交事务，来解决insert情况下的幻读问题</p><hr><p>那么，感觉RR就已经解决了幻读，为啥还需要串行化（Serializable ）？？？</p><p>操作4:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td></td><td>select * from user where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>insert into user values (4,’haha’,1);<br/>commit;</td></tr><tr><td>5</td><td>update user set name=’zhangsan2’ where age=1;</td><td></td></tr><tr><td>6</td><td>commit;</td><td></td></tr></tbody></table><p>RR级别下，此时想象中的结果为下面，因为实际上在第五行如果不是update而是select，是肯定差不到新数据的</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan2</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr><tr><td>4</td><td>haha</td><td>1</td></tr></tbody></table><p>但是实际的数据库中结果为：</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan2</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr><tr><td>4</td><td>zhangsan2</td><td>1</td></tr></tbody></table><p>其实在 MySQL在RR级别中并不是完全解决了幻读的问题，对照操作2中t2使用insert、操作3、以及操作4可以看出某些场景下RR解决了幻读，但是MVCC 对于幻读的解决是不彻底的。（快照读和当前读的混合使用会产生幻读问题）</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/31/2.%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="高效交换算法-异或"><a href="#高效交换算法-异或" class="headerlink" title="高效交换算法(异或^)"></a>高效交换算法(异或^)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>0^N = N  ; N^N = 0 </li><li>相同为0，不同为1，也可以叫做无进位相加，这么做的前提：需要交换的两个数指向的内存是两位位置</li><li>异或运算满足交换律和结合律</li><li>不用额外变量交换两个数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换arr的i和j位置上的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一种数出现奇数次"><a href="#一种数出现奇数次" class="headerlink" title="一种数出现奇数次"></a>一种数出现奇数次</h4><p>一个数组中有一个数出现奇数次，其他数都出现偶数次，怎么找到这一个数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种数出现奇数次"><a href="#两种数出现奇数次" class="headerlink" title="两种数出现奇数次"></a>两种数出现奇数次</h4><p>一个数组中有两个数出现奇数次，其他数都出现了偶数次，怎么找到这两个数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a 和 b是两种数</span></span><br><span class="line">    <span class="comment">// eor != 0</span></span><br><span class="line">    <span class="comment">// eor最右侧的1，提取出来</span></span><br><span class="line">    <span class="comment">// eor :     00110010110111000</span></span><br><span class="line">    <span class="comment">// rightOne :00000000000001000</span></span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">// 提取出最右的1</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line">      <span class="comment">//  arr[1] =  111100011110000</span></span><br><span class="line">      <span class="comment">// rightOne=  000000000010000</span></span><br><span class="line">      <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">        onlyOne ^= arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>基本冒泡排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0 ~ N-1</span></span><br><span class="line">    <span class="comment">// 0 ~ N-2</span></span><br><span class="line">    <span class="comment">// 0 ~ N-3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>冒泡排序算法优化</li></ul><p>在一趟排序过程中如果一次都没有交换过，那说明后续的数都是有序的，不需要在进行后续的排序了，如果元素本来就是有序的，就只比较一次就结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>0 ~ N-1  找到最小值，在哪，放到0位置上</li><li>1 ~ n-1  找到最小值，在哪，放到1 位置上</li><li>2 ~ n-1  找到最小值，在哪，放到2 位置上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// i ~ N-1 上找最小值的下标 </span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>0~1单范围有序</li><li>0~2范围有序</li><li>0~3范围有序</li><li>0~N范围有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不只1个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分法的详解与扩展</p><ol><li>在一个有序数组中，查找某个数是否存在</li><li>在一个有序数组中，找&gt;=某个数最左侧的位置</li><li>局部最小值问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// L..R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">// L..R 至少两个数的时候</span></span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组范围上求最大值"><a href="#数组范围上求最大值" class="headerlink" title="数组范围上求最大值"></a>数组范围上求最大值</h3><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arr[L..R]范围上只有一个数，直接返回，base case</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; </span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L...R 不只一个数</span></span><br><span class="line">    <span class="comment">// mid = (L + R) / 2</span></span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">// 中点</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = process(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightMax = process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数器的概念"><a href="#对数器的概念" class="headerlink" title="对数器的概念"></a>对数器的概念</h2><ol><li>有一个你想要测试的方法a</li><li>实现复杂度不好但是容易实现的方法b</li><li>实现一个随机样本产生器</li><li>把方法a和方法b跑相同的随机样本，看看得到的结果是否一样</li><li>如果有一个随机样本时的比对结果不一致，打印样本进行人工干预，改对方法a或者方法b</li><li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="ab数组合并到a"><a href="#ab数组合并到a" class="headerlink" title="ab数组合并到a"></a>ab数组合并到a</h3><ul><li><p>题目：给出两个有序的整数数组A和B，请将数组B合并到数组A中，变成一个有序的数组。注意：可以假设A数组有足够的空间存放B数组的元素，A和B中初始的元素数目分别为m和n。</p></li><li><p>题解：最优解：从后往前处理,不需要开辟额外空间。从后往前，这样不需要进行冗余处理。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 数组a，有足够的空间合并数组b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 数组a里面的元素个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 数组b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组b里面的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> m, <span class="keyword">int</span>[] b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[j] )&#123;</span><br><span class="line">            a[index--] = a[i--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[index--] = b[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果A的数字比B多，则不会进入后续处理；如果B的数字比A多，则进入后续处理，将B剩余数字添加到数组A中。</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        a[index--] = b[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ab数组合并到c"><a href="#ab数组合并到c" class="headerlink" title="ab数组合并到c"></a>ab数组合并到c</h3><ul><li>题目： 合并两个有序整型数据（入参两个需要合并的数组，返回值合并好的新数组）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] margeArr(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + b.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//比较指针i,j指向的值，小的值存入指针index指向的结果数组中，当有一个指针（i或j）先到达数组末尾时，比较结束；</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j]) &#123;</span><br><span class="line">            c[index++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[index++] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="comment">//将指针（i或j）没有到达数组末尾的数组复制到指针index指向的结果数组中</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; a.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = i; l &lt; a.length; l++) &#123;</span><br><span class="line">            c[index++] = a[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针（i或j）没有到达数组末尾的数组复制到指针index指向的结果数组中</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = j; l &lt; b.length; l++) &#123;</span><br><span class="line">            c[index++] = b[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找两数之和等于目标数"><a href="#查找两数之和等于目标数" class="headerlink" title="查找两数之和等于目标数"></a>查找两数之和等于目标数</h3><ul><li>题目：给定一个数组和一个目标数，从数组中找到两个数，是这两个数之和等于目标数。返回其在数组中的编号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋打印二维数组"><a href="#螺旋打印二维数组" class="headerlink" title="螺旋打印二维数组"></a>螺旋打印二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tR == dR) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tC; i &lt;= dC; i++) &#123;</span><br><span class="line">            System.out.print(m[tR][i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tR; i &lt;= dR; i++) &#123;</span><br><span class="line">            System.out.print(m[i][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> curC = tC;</span><br><span class="line">        <span class="keyword">int</span> curR = tR;</span><br><span class="line">        <span class="keyword">while</span> (curC != dC) &#123;</span><br><span class="line">            System.out.print(m[tR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != dR) &#123;</span><br><span class="line">            System.out.print(m[curR][dC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">            System.out.print(m[dR][curC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curC--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != tR) &#123;</span><br><span class="line">            System.out.print(m[curR][tC] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;</span><br><span class="line">        printEdge(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;,</span><br><span class="line">                      &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">    spiralOrderPrint(matrix);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度</li><li>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法</li></ol><ul><li>重要技巧<ul><li>额外数据结构记录（哈希表等）</li><li>快慢指针</li></ul></li></ul><h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><h4 id="单向链表反转"><a href="#单向链表反转" class="headerlink" title="单向链表反转"></a>单向链表反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  head 单向链表反转算法</span></span><br><span class="line"><span class="comment">//   a    -&gt;   b    -&gt;  c  -&gt;  null</span></span><br><span class="line"><span class="comment">//   c    -&gt;   b    -&gt;  a  -&gt;  null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归反转方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = reverseLinkedList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表反转"><a href="#双向链表反转" class="headerlink" title="双向链表反转"></a>双向链表反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表反转算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">    DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">    DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.last = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找链表中点"><a href="#查找链表中点" class="headerlink" title="查找链表中点"></a>查找链表中点</h3><p>快慢指针应用</p><h4 id="查找链表中点或中点上一个"><a href="#查找链表中点或中点上一个" class="headerlink" title="查找链表中点或中点上一个"></a>查找链表中点或中点上一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 头  解：查找链表中点或者中点前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表有3个点或以上</span></span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找链表中点或中点下一个"><a href="#查找链表中点或中点下一个" class="headerlink" title="查找链表中点或中点下一个"></a>查找链表中点或中点下一个</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找链表中点或者中点下一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个链表是否是回文结构"><a href="#判断一个链表是否是回文结构" class="headerlink" title="判断一个链表是否是回文结构"></a>判断一个链表是否是回文结构</h3><p>【题目】给定一个单向链表的头节点head，请判断该链表是否为回文结构。【例子】1-&gt;2-&gt;1,返回true;1-&gt;2-&gt;2-&gt;1,返回true；15-&gt;6-&gt;15，返回true；1-&gt;2-&gt;3，返回false。如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。</p><ol><li><font color=red>解题思路1：</font> 1：遍历链表，把每个元素放到栈里面；2：从栈里面依次弹出元素和原来链表挨个元素比对。</li><li><font color=red>解题思路2：</font> 1：通过快慢指针找到中点和结束点，只把右侧部分放到栈里面去；2：从栈里面依次弹出元素和原来链表挨个元素比对。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：遍历链表，把每个元素放到栈里面；2：从栈里面依次弹出元素和原来链表挨个元素比对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：通过快慢指针找到中点和结束点，只把右侧部分放到栈里面去；2：从栈里面依次弹出元素和原来链表挨个元素比对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h3><h4 id="单向链表分左中右"><a href="#单向链表分左中右" class="headerlink" title="单向链表分左中右"></a>单向链表分左中右</h4><p>【题目】 将单向链表按照某值划分成左边小，中间相等，右边大的形式：给定一个单链表头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为做部分都是值小于pivot的节点，中间部分都是值等于piovt的节点，有部分都是值大于piovt的节点。【进阶】在实现原问题功能的基础上增加要求：小于，等于，大于pivot节点之间顺序和之前一样，时间复杂度O(N)，额外空间复杂度O(1)。</p><p><font color=red>解题思路1：</font> 将链表放入数组，排序，再转成链表</p><p><font color=red>解题思路2：</font> 左中右分别准备两个指针(共6个变量)，然后遍历原链表，排序之后分别插入相应位置(考虑边界问题)</p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20210917001438.png" style="zoom: 67%;" />  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将链表放入数组，排序，再转成链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[i];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[i - <span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> small = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index != big) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++small, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(nodeArr, --big, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node tmp = nodeArr[a];</span><br><span class="line">    nodeArr[a] = nodeArr[b];</span><br><span class="line">    nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左中右分别准备两个指针(共6个变量)，然后遍历原链表，排序之后分别插入相应位置(考虑边界问题)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node mH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node mT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node next = <span class="keyword">null</span>; <span class="comment">// save next node</span></span><br><span class="line">    <span class="comment">// every node distributed to three lists</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mH = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mT.next = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有小于区域</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下一步，一定是需要用eT 去接 大于区域的头</span></span><br><span class="line">    <span class="comment">// 有等于区域，eT -&gt; 等于区域的尾结点</span></span><br><span class="line">    <span class="comment">// 无等于区域，eT -&gt; 小于区域的尾结点</span></span><br><span class="line">    <span class="comment">// eT 尽量不为空的尾巴节点</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">        eT.next = mH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : (eH != <span class="keyword">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表闭环及相交问题"><a href="#链表闭环及相交问题" class="headerlink" title="链表闭环及相交问题"></a>链表闭环及相交问题</h3><h4 id="单链表查找闭环位置"><a href="#单链表查找闭环位置" class="headerlink" title="单链表查找闭环位置"></a>单链表查找闭环位置</h4><p>注：单链表闭环只能有一个环，如果产生环，必然会出现闭环</p><p><strong>解法1：额外空间解决</strong></p><ol><li>申请一个set集合，从头节点遍历链表，每遍历一个元素就查询该节点是否在集合中，如果没有就把该节点放进去，如果有，该节点就是环位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>解法2：有限几个变量解决</strong></p><ol><li>快慢指针从单链表头节点开始走，直至两个节点相遇，说明有环，最后指向null，说明无环</li><li>相遇之后快指针回到头节点，之后一次走一步，慢指针停在原地，再次相遇的位置即是环节点位置(记住结论，不要问为什么)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n1 慢  n2 快</span></span><br><span class="line">    Node slow = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">    Node fast = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow fast  相遇</span></span><br><span class="line">    fast = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个无环链表交点位置"><a href="#两个无环链表交点位置" class="headerlink" title="两个无环链表交点位置"></a>两个无环链表交点位置</h4><p><strong>注：</strong></p><ul><li>如果两个单向链表相交，相交后面的部分必然是共有的，那么两个链表最后的那个节点必然是同一个节点</li><li>长链表先走两个链表差值的步数，然后短链表在开始走，他俩一定会在第一个相交的位置相遇</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n  :  链表1长度减去链表2长度的值</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两条有环链表查找交点"><a href="#两条有环链表查找交点" class="headerlink" title="两条有环链表查找交点"></a>两条有环链表查找交点</h4><p>分为两种情况：入环节点可能是同一个节点，也可能不是同一个节点，如图</p><img src="https://raw.githubusercontent.com/lizejiao/img_bed/master/images/20211112225209.png" style="zoom:80%;" /><p>情况1：入环节点可能是同一个节点，就是求单链表的第一个环节点问题，只不过从相交位置开始走</p><p>情况2：如果链表1在转回到自己的过程中没有遇到链表2，就说明是各自成环的，相交节点返回空就醒来，如果遇到，就是情况2，返回两个节点，都对，都属于第一个相交的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找两个链表相交节点"><a href="#查找两个链表相交节点" class="headerlink" title="查找两个链表相交节点"></a>查找两个链表相交节点</h4><p>注：难点为考虑是否有环，有环链表相交以及无环链表相交问题，没有用到额外数据结构，只用到有限几个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分别找到两个链表的环位置</span></span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 无环链表相交问题</span></span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 两条有环链表相交问题</span></span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li>先序遍历：头-&gt;左-&gt;右</li><li>中序遍历：左-&gt;头-&gt;右</li><li>后序遍历：左-&gt;右-&gt;头</li></ul><h4 id="递归遍历二叉树"><a href="#递归遍历二叉树" class="headerlink" title="递归遍历二叉树"></a>递归遍历二叉树</h4><p><strong>遍历说明</strong></p><p>递归通过打印时机不同，实现先，中，后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 前序</span></span><br><span class="line">    f(head.left);</span><br><span class="line">    <span class="comment">// 2 中序</span></span><br><span class="line">    f(head.right);</span><br><span class="line">    <span class="comment">// 3 后序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h4><ul><li>先序遍历(深度性遍历)</li></ul><ol><li>准备一个栈，根节点入栈弹出，打印，然后先压右，再压左</li><li>弹出打印，先压右再压左，周而复始</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pre-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历</li></ul><ol><li>在先序遍历的基础之上，增加一个收集栈，弹出来就放到收集栈中(不打印)，然后<strong>先压左，再压右</strong></li><li>把收集栈中的元素依次出栈，打印</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop(); <span class="comment">// 头 右 左</span></span><br><span class="line">            s2.push(head);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左 右 头</span></span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><ol><li>整棵树左边界进栈，依次弹出的过程中，打印，对弹出节点的右树周而复始</li></ol><p>为什么？ 因为整个树都会被他的左边界分解掉，我们把头和左边界压栈，然后再右，出栈的时候就是左，头，右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;in-order: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="宽度遍历"><a href="#宽度遍历" class="headerlink" title="宽度遍历"></a>宽度遍历</h4><p>宽度遍历就是横着遍历，也是层次遍历</p><ol><li>用队列，头节点放队列，每一次弹出就打印，然后先放左再放右，每一个元素出队列都是先放左再放右</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">width</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的最大宽度-难"><a href="#求二叉树的最大宽度-难" class="headerlink" title="求二叉树的最大宽度(难)"></a>求二叉树的最大宽度(难)</h3><p>分析：宽度性遍历的时候要知道每一层的节点个数</p><p>解：遍历每个节点的时候，知道他在第几层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用hash表的解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevel++;</span><br><span class="line">            curLevelNodes = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, curLevelNodes);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用hash表的方法 (难度高)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    Node curEnd = head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line">    Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            nextEnd = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            nextEnd = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        curLevelNodes++;</span><br><span class="line">        <span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevelNodes = <span class="number">0</span>;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h3><ol><li>结果可看做头节点是凹，所有的左子树头节点都是凹，所有右子树头肩点都是凸的二叉树</li><li>中序遍历即可打印出从上到下的所有结构</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">    process(<span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个节点在第i层，一共有N层，N固定不变的</span></span><br><span class="line"><span class="comment">// 这个节点如果是凹的话，down = T</span></span><br><span class="line"><span class="comment">// 这个节点如果是凸的话，down = F</span></span><br><span class="line"><span class="comment">// 函数的功能：中序打印以你想象的节点为头的整棵树！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    System.out.print(down ? <span class="string">&quot;凹 &quot;</span> : <span class="string">&quot;凸 &quot;</span>);</span><br><span class="line">    process(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索二叉树-递归套路"><a href="#搜索二叉树-递归套路" class="headerlink" title="搜索二叉树(递归套路)"></a>搜索二叉树(递归套路)</h3><ul><li><strong>题目：</strong>如何判断一颗二叉树是搜索二叉树？</li><li><strong>搜索二叉树的特点：</strong>任何一个节点，左子树的节点一定比它小，右子树的节点一定比它大</li><li><strong>解题：</strong> 中序遍历一定是升序，如果某个位置有降序，一定不是搜索二叉树</li><li><font color=red>递归套路题解</font > :向我左树要信息，右树要信息，左树必须是搜索二叉树且左树最大值小于我，右树是搜索二叉树并且最小值大于我；左树信息：1.是否是搜索二叉树，2.最大值，3.最小值；右树也是</li><li><strong>注意：</strong>递归套路，可以解决一切树形DP 问题，无非是可能性的罗列有难度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1： 额外引入数组</span></span><br><span class="line"><span class="comment">// 节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历到一个数组中，然后判断数组是不是升序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Node&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    in(head, arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.get(i).value &lt;= arr.get(i - <span class="number">1</span>).value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head, ArrayList&lt;Node&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in(head.left, arr);</span><br><span class="line">    arr.add(head);</span><br><span class="line">    in(head.right, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法2：递归方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> preValue = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> checkLeft = checkBST(head.left);</span><br><span class="line">    <span class="keyword">if</span> (!checkLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序打印的时机，换成了中序比较的时机</span></span><br><span class="line">    <span class="keyword">if</span> (head.value &lt;= preValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preValue = head.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkBST(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法3：递归套路</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBST; <span class="comment">// 是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max; <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min; <span class="comment">// 最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">        isBST = i;</span><br><span class="line">        max = ma;</span><br><span class="line">        min = mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = x.value;</span><br><span class="line">    <span class="keyword">int</span> max = x.value;</span><br><span class="line">    <span class="comment">// 最小值和最大值就是我当前节点的值和它比较得出的最小值和最大值</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">boolean</span> isBST = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 左边有信息并且左边不是搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; !leftInfo.isBST) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; !rightInfo.isBST) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边有信息，但是左边的最大值大于等于我的值</span></span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.max &gt;= x.value) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边有信息，右边的最小值小于等于我当前值</span></span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; rightInfo.min &lt;= x.value) &#123;</span><br><span class="line">        isBST = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBST, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li>如何判断一个二叉树是完全二叉树</li><li>完全二叉树：一颗二叉树从左到右是依次变满的，即使不满，也是变满的样子</li><li>解题：二叉树宽度遍历，1.任何一个节点如果有有节点，没左节点，false；2.在第一个条件不违规情况，如果遇到第一个左右两个节点不双全情况，接下来遇到的所有节点，必须是叶子节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 是否遇到过左右两个孩子不双全的节点</span></span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span></span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到左右两个节点不双全的情况，修改标记</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul><li>如何判断一棵树是平衡二叉树</li><li><strong>平衡二叉树特性：</strong>对于任何一个子树来说，左树的高度和右树的高度差，都不超过1</li><li><strong>解决思路：</strong>假设我可以向我的左树要信息，可以向右树要信息，如果我整棵树是平衡二叉树，我左树得是平的，右树得是平的，对于X节点来说，左树-右树高度差&lt;=1；我向左树要信息：1.是否是平的；2.高度是多少，右树要信息：1.是否是平的；2.高度是多少</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        isBalanced = i;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(x.left);</span><br><span class="line">    Info rightInfo = process(x.right);</span><br><span class="line">    <span class="comment">// x为头的节点的高度：左树和右树较大的那个高度再加上我自己(+1)</span></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否是平衡树：我左树得是平衡，右树得是平衡树，并且我左树和右树的高度差的绝对值得小于2</span></span><br><span class="line">    <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!leftInfo.isBalanced) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!rightInfo.isBalanced) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul><li>如何判断一棵树是满二叉树</li><li>树最大深度L，节点个数N，满足N=2(L次方)-1</li><li><strong>解法(递归套路)：</strong>先求二叉树最大深度L，再求节点个数N，满足N=2(L次方)-1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 满二叉树解法：递归套路</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">        nodes = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info all = process(head);</span><br><span class="line">    <span class="comment">// N=2(L次方)-1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; all.height) - <span class="number">1</span> == all.nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(head.left);</span><br><span class="line">    Info rightInfo = process(head.right);</span><br><span class="line">    <span class="comment">// 高度等于左树和右树最高的高度+1</span></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 总个数等于左边的个数加上右边的个数加1</span></span><br><span class="line">    <span class="keyword">int</span> nodes = leftInfo.nodes + rightInfo.nodes + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(height, nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最低公共祖先"><a href="#二叉树最低公共祖先" class="headerlink" title="二叉树最低公共祖先"></a>二叉树最低公共祖先</h3><ul><li>给定两个二叉树节点node1和node2，找到他们的最低公共祖先节点</li><li>解法1：遍历整棵树，把所有节点的父节点都维护到一个Map中，然后找到node1的所有父节点维护到set中，再遍历node2的所有的父，第一个在set中遇到的节点就是最低公共祖先</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lca</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Node, Node&gt; parentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    parentMap.put(head, <span class="keyword">null</span>);</span><br><span class="line">    fillParentMap(head, parentMap);</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node cur = o1;</span><br><span class="line">    set.add(cur);</span><br><span class="line">    <span class="comment">// 只有头节点才等于自己的父，如果当前节点不等于自己的父，就可以往上走</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">null</span> != parentMap.get(cur)) &#123;</span><br><span class="line">        cur = parentMap.get(cur);</span><br><span class="line">        set.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// o1往上所有节点都在这个set里面，只有最初的head不在里面</span></span><br><span class="line">    cur = o2;</span><br><span class="line">    <span class="keyword">while</span> (!set.contains(cur)) &#123;</span><br><span class="line">        cur = parentMap.get(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护整棵树的所有父节点到Map中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillParentMap</span><span class="params">(Node head, HashMap&lt;Node, Node&gt; fatherMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fatherMap.put(head.left, head);</span><br><span class="line">        fillParentMap(head.left, fatherMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fatherMap.put(head.right, head);</span><br><span class="line">        fillParentMap(head.right, fatherMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解法2(非常抽象)：可能的情况有1：node1和node2互为公共祖先；2：node1和node2不互为公共祖先；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法2：可能的情况有1：node1和node2互为公共祖先；2：node1和node2不互为公共祖先；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node left = lowestCommonAncestor(head.left, o1, o2);</span><br><span class="line">    Node right = lowestCommonAncestor(head.right, o1, o2);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>常见的表示图的方法：临接表法，和临接矩阵法，数组等</li><li>做模板，然后把所有的图的问题转化为自己熟悉的数据结构，带着模板上考场</li></ul><h3 id="图的宽度优先遍历"><a href="#图的宽度优先遍历" class="headerlink" title="图的宽度优先遍历"></a>图的宽度优先遍历</h3><h3 id="约瑟夫圆环问题"><a href="#约瑟夫圆环问题" class="headerlink" title="约瑟夫圆环问题"></a>约瑟夫圆环问题</h3><h2 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h2><ul><li>实现一个计算器，只有加减乘除法，没有括号，输入是一个字符串如10+2+3*5</li><li>解题：表达式转化为后缀表达式（逆波兰表达式）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;10+2+3*5&quot;</span>;</span><br><span class="line">    <span class="comment">// 表达式转换为操作数和操作符的中缀表达式数组</span></span><br><span class="line">    String[] strArr = changeStrArr(str);</span><br><span class="line">    <span class="comment">// 中缀表达式转化为后缀表达式</span></span><br><span class="line">    List&lt;String&gt; polandList = polandNotation(strArr);</span><br><span class="line">    System.out.println(polandList);</span><br><span class="line">    <span class="comment">// 后缀表达式计算</span></span><br><span class="line">    System.out.println(calculate(polandList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串转成中缀的数组</span></span><br><span class="line"><span class="comment"> * 只有加减乘除，没有扩号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] changeStrArr(String str) &#123;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(String.valueOf(c))) &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stringBuilder.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString().split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中缀表达式转化为后缀表达式</span></span><br><span class="line"><span class="comment"> * 1.初始化两个栈，运算符栈s1和储存中间结果的栈s2</span></span><br><span class="line"><span class="comment"> * 2.从左到右扫描中缀表达式</span></span><br><span class="line"><span class="comment"> * 3.遇到操作数，入栈s2</span></span><br><span class="line"><span class="comment"> * 4.遇到运算符，比较其与s1栈顶运算符的优先级：</span></span><br><span class="line"><span class="comment"> * (1).如果s1为空，或者栈顶运算符为左括号&quot;(&quot;,直接将运算符入栈；</span></span><br><span class="line"><span class="comment"> * (2).否则，若优先级比栈顶运算符高，也将运算符入栈s1;</span></span><br><span class="line"><span class="comment"> * (3).否则，将s1栈顶运算符弹出入栈s2中，再次转到(4-1) 与s1中新的栈顶运算符比较；</span></span><br><span class="line"><span class="comment"> * 本方法只考虑到加减乘除操作，不考虑扩号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">polandNotation</span><span class="params">(String[] str)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String itm : str) &#123;</span><br><span class="line">        <span class="comment">// 遇到操作数，直接入栈s2</span></span><br><span class="line">        <span class="keyword">if</span> (itm.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            s2.add(itm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果栈不为空，并且栈顶优先级比我目前运算符优先级高，就把栈顶运算符如s2，然后吧当前运算符如s1</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty() &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(itm)) &#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            s1.push(itm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">        s2.add(s1.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算符比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰表达式计算</span></span><br><span class="line"><span class="comment"> * 1.定义一个栈，匹配到非运算符就入栈</span></span><br><span class="line"><span class="comment"> * 2.遇到运算符就把栈顶两个数字出栈，用后出栈的数和先出栈的数做运算，把运算结果再入栈</span></span><br><span class="line"><span class="comment"> * 3.直到最后，栈顶结果即为计算结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; polandList)</span> </span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String itm : polandList) &#123;</span><br><span class="line">        <span class="comment">// 匹配的是多位数</span></span><br><span class="line">        <span class="keyword">if</span> (itm.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">            stack.push(itm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 弹出两个数，并运算，再入栈</span></span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (itm.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                res = num1 - num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itm.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                res = num1 / num2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(String.valueOf(res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀树数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> Node1[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char tmp = &#x27;b&#x27;  (tmp - &#x27;a&#x27;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pass = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0    a</span></span><br><span class="line">        <span class="comment">// 1    b</span></span><br><span class="line">        <span class="comment">// 2    c</span></span><br><span class="line">        <span class="comment">// ..   ..</span></span><br><span class="line">        <span class="comment">// 25   z</span></span><br><span class="line">        <span class="comment">// nexts[i] == null   i方向的路不存在</span></span><br><span class="line">        <span class="comment">// nexts[i] != null   i方向的路存在</span></span><br><span class="line">        nexts = <span class="keyword">new</span> Node1[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = word.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    node.pass++;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">        path = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line">        <span class="keyword">if</span> (node.nexts[path] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.nexts[path] = <span class="keyword">new</span> Node1();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[path];</span><br><span class="line">        node.pass++;</span><br><span class="line">    &#125;</span><br><span class="line">    node.end++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// word这个单词之前加入过几次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">    Node1 node = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        Node1 node = root;</span><br><span class="line">        node.pass--;</span><br><span class="line">        <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            path = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">                node.nexts[path] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">        node.end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫做贪心算法。也就是说，不从整体最优上加以考虑，所做出的是某种意义上的局部最优解。</p><h3 id="会议室占用问题"><a href="#会议室占用问题" class="headerlink" title="会议室占用问题"></a>会议室占用问题</h3><p>问题：只有一个会议室，多个会议占用会议室的时间有冲突，如何让会议室进行的会议最多，返回最多的会议场次</p><p>解：哪个会议结束时间早，就优先安排，然后接下来继续找下一个会议结束时间早的会议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会议开始时间和结束时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Program</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Program o1, Program o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议的开始时间和结束时间，都是数值，不会 &lt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange2</span><span class="params">(Program[] programs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line">    <span class="keyword">int</span> timeLine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次遍历每一个会议，结束时间早的会议先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeLine &lt;= programs[i].start) &#123;</span><br><span class="line">            result++;</span><br><span class="line">            timeLine = programs[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><h2 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h2><h3 id="三个线程交替打印"><a href="#三个线程交替打印" class="headerlink" title="三个线程交替打印"></a>三个线程交替打印</h3><ul><li>三个线程交替打印，1线程打印1；2线程打印2；3线程打印3；1线程打印4……一直打印到100</li><li>解题方式由很多，无非就是涉及到线程通信问题以及修改共享变量问题</li></ul><p><strong>题解1：</strong>不加锁，利用线程可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread3());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t3=&quot;</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解2</strong>：LockSupport 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread thread1, thread2,thread3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        thread1 = <span class="keyword">new</span> Thread(ThreadPrint2::thread1, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread2 = <span class="keyword">new</span> Thread(ThreadPrint2::thread2, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread3 = <span class="keyword">new</span> Thread(ThreadPrint2::thread3, <span class="string">&quot;thread3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread2);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ThreadPrint2.number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread3:&quot;</span> + ThreadPrint2.number);</span><br><span class="line">            ThreadPrint2.number++;</span><br><span class="line">            LockSupport.unpark(thread1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解3</strong>：经典实现 实现wait-&gt;notifyAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (count % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + count);</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解4</strong>：Lock实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPrint4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition c1 = lock.newCondition();</span><br><span class="line">        Condition c2 = lock.newCondition();</span><br><span class="line">        Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c2.signal();</span><br><span class="line">                    c1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c3.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c3.signal();</span><br><span class="line">                    c2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnt &lt;= <span class="number">100</span> &amp;&amp; cnt % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + cnt);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    c1.signal();</span><br><span class="line">                    c3.await();</span><br><span class="line">                &#125;</span><br><span class="line">                c2.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他算法题"><a href="#其他算法题" class="headerlink" title="其他算法题"></a>其他算法题</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务架构-稳定性建设方法论</title>
      <link href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>先介绍几个概念，同步一下认知：</p><p>容灾：是指系统冗余部署，当一处由于意外停止工作，整个系统应用还可以正常工作。</p><p>容错：是指在运行中出现错误（如上下游故障或概率性失败）仍可正常提供服务。</p><p>可用性：描述的是系统可提供服务的时间长短。用公式来说就是正常工作时间/(正常工作时间+故障时间)。</p><p>可靠性：描述的是系统指定时间单位内无故障的次数。比如：一年365天，以天为单位来衡量。有天发生了故障，哪怕只有1秒，这天算不可靠。其他没有故障的是可靠的。</p><p>稳定性：这个业界没有明确的定义，我的理解是：在受到各种干扰时仍然能够提供符合预期的服务的能力。</p><h1 id="一、容灾建设"><a href="#一、容灾建设" class="headerlink" title="一、容灾建设"></a>一、容灾建设</h1><h2 id="1-代码容灾"><a href="#1-代码容灾" class="headerlink" title="1.代码容灾"></a>1.代码容灾</h2><p> 现代互联网公司最值钱的就是程序员写出来的代码啦，所以我们需要对代码进行容灾备份，防止放代码的服务器哪天一不高兴宕机异或爆炸啦数据都丢了就完蛋了，现在代码同步的方案比较多，是在不行运维人员写个脚本，每天或者几个小时自动同步一下全量代码到另一个机房还是可以做到滴。</p><h2 id="2-服务容灾"><a href="#2-服务容灾" class="headerlink" title="2.服务容灾"></a>2.服务容灾</h2><p>服务容灾的解决方案就是冗余。多几个备份来切换。</p><h3 id="2-1同城容灾"><a href="#2-1同城容灾" class="headerlink" title="2.1同城容灾"></a>2.1同城容灾</h3><p>同城 容灾 是在同城或相近区域内 （ ≤ 200K M ）建立两个数据中心 : 一个为数据中心，负责日常生产运行 ; 另一个为灾难备份中心，负责在灾难发生后的应用系统运行。同城灾难备份的数据中心与灾难备份中心的距离比较近，通信线路质量较好，比较容易实现数据的同步 复制 ，保证高度的数据完整性和数据零丢失。同城灾难备份一般用于防范火灾、建筑物破坏、供电故障、计算机系统及人为破坏引起的灾难</p><h3 id="2-2异地-跨洋容灾"><a href="#2-2异地-跨洋容灾" class="headerlink" title="2.2异地/跨洋容灾"></a>2.2异地/跨洋容灾</h3><p>异地 容灾 主备中心之间的距离较远 （＞ 200KM ) ， 因此一般采用异步镜像，会有少量的数据丢失。异地灾难备份不仅可以防范火灾、建筑物破坏等可能遇到的风险隐患，还能够防范战争、地震、水灾等风险。由于同城灾难备份和异地灾难备份各有所长，为达到最理想的防灾效果，数据中心应考虑采用同城和异地各建立一个灾难备份中心的方式解决。</p><h3 id="2-3两地三中心"><a href="#2-3两地三中心" class="headerlink" title="2.3两地三中心"></a>2.3两地三中心</h3><p><strong>两地三中心</strong> ： 是指 <strong>同城双中心</strong> 加 <strong>异地灾备</strong> 一种商用容灾备份解决方案；</p><p><strong>两地</strong> 是指同城、异地；</p><p><strong>三中心</strong> 是指生产中心、同城容灾中心、异地容灾中心。（ 生产中心、同城灾备中心、异地 灾备 中心 ）</p><p>结合近年国内出现的大范围自然灾害，以同城双中心加异地灾备中心的 “两地三中心”的灾备模式也随之出现，这一方案兼具高可用性和灾难备份的能力。</p><p><strong>同城双中心</strong> 是指在同城或邻近城市建立两个可独立承担关键系统运行的数据中心，双中心具备基本等同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。与异地灾备模式相比较，同城双中心具有投资成本低、建设速度快、运维管理相对简单、可靠性更高等优点。</p><p><strong>异地灾备中心</strong> 是指在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。</p><h1 id="二、服务治理"><a href="#二、服务治理" class="headerlink" title="二、服务治理"></a>二、服务治理</h1><h2 id="1-链路梳理"><a href="#1-链路梳理" class="headerlink" title="1.链路梳理"></a>1.链路梳理</h2><p>需要梳理核心接口服务的血缘依赖关系、相关干系人及联系方式，做到心中有数，关键接口调用链路流程尽量短，下游依赖接口tp999尽量越快越好。</p><h2 id="2-强弱依赖分析"><a href="#2-强弱依赖分析" class="headerlink" title="2.强弱依赖分析"></a>2.强弱依赖分析</h2><p>强依赖：假定服务A依赖于服务B，服务B出现故障不可用时，服务A也不可用，通常服务A会返回错误信息，我们称这种依赖为强依赖。</p><p>弱依赖：假定服务A依赖于服务B，服务B出现故障不可用时，服务A仍然可用，通常服务A会返回正确信息，只是与服务B相关的信息会不返回或者做默认处理，我们称这种依赖为弱依赖。</p><p>通过下面的流程图，我们来分析一下强弱依赖。从图中可以看到，在服务A中调用了服务B和服务C，但是他们的处理逻辑是不一样的。</p><p>1、调用服务B：如果调用成功，则接着调用服务C；如果调用失败，则服务A直接结束。这种场景我们称之为服务A强依赖于服务B。</p><p>2、调用服务C：不管调用成功还是失败，服务A会接续执行后续逻辑处理。这种场景我们称之为服务A弱依赖于服务C。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/17/Exztom.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;it`s serviceA&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// serviceA 强依赖于 serviceB</span></span><br><span class="line">            serviceB();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/// serviceA 弱依赖于 serviceC</span></span><br><span class="line">                serviceC();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;xxxxxxx&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在代码的处理上，可以分为一下三种模式：<br>1、弱依赖：服务A的主流程不依赖服务B的返回结果。<br>该场景可以有两种解决方式：<br>1）可以启动单独的线程进行服务B调用。<br>2）在当前线程中发消息，在消息消费线程中访问服务B。</p><p>2、弱依赖：服务A的主流程依赖服务B的返回结果。<br>与强依赖处理有些类似，一般建议对服务B做降级处理，根据请求超时时间、并发请求数、请求失败数、请求返回的错误码做降级(或者熔断)处理。同时使用默认值来代替服务B的返回结果，默认值的设置需要根据具体的业务场景进行分析。</p><p>3、强依赖：服务A的主流程依赖服务B的返回结果。<br>一般建议对服务A整体做降级处理，请求返回的错误码。</p><p>在系统设计时一定要考虑系统的强弱依赖关系，根据需要采用不同的处理方案。</p><h2 id="3-异步化建设"><a href="#3-异步化建设" class="headerlink" title="3.异步化建设"></a>3.异步化建设</h2><p>普通流量下的接口流程设计上可以一个接口，做了好多好多事情，之后接口同步实时返回处理成功或者处理失败。在高并发场景下是非常糟糕的设计，接口一方面业务逻辑非常的重，另一方面，同步接口依赖的很多的三方接口，也可能会多次的操作数据库，一个点出问题都会造成整个业务的瘫痪。此时可以把整个流程异步化，同步接口里面只做一些校验工作以及数据的保存，之后发送mq触发后续流程的执行，此时实时接口返回处理中，异步流程中处理完毕后通过回调的方式通知调用方结果，同时提供查询接口供调用方主动获取结果。</p><p>需要注意的是因为是通过发mq的方式触发后续流程，那么就要保证mq一定发送成功，此处牵扯到分布式事务相关的方案，不同的业务逻辑可能会使用不同的解决办法。（本地事务表或者依靠状态来驱动都可以）</p><h2 id="4-切量-降级-限流-熔断"><a href="#4-切量-降级-限流-熔断" class="headerlink" title="4.切量/降级/限流/熔断"></a>4.切量/降级/限流/熔断</h2><h3 id="4-1切量"><a href="#4-1切量" class="headerlink" title="4.1切量"></a>4.1切量</h3><p>切量是新业务上线初期，或者大版本更新的时候，会对用户进行切量开放xx功能，用少量的生产流量验证流程，如果没有问题慢慢切量剩余用户，如果有问题，也会将问题影响面降到最低。</p><h3 id="4-2降级"><a href="#4-2降级" class="headerlink" title="4.2降级"></a>4.2降级</h3><p>降级是通过开关配置将某些不重要的业务功能屏蔽掉，以提高服务处理能力。</p><p>在大促场景中经常会对某些服务进行降级处理，大促结束之后再进行复原。</p><p>本系统或者下游系统出现问题时，当前系统可以手动对服务进行降级操作，问题修复后关闭降级。</p><p>大促场景时会对日志打印进行降级，防止磁盘io对系统造成影响，另外也会避免正好大促时磁盘空间满了，系统没来得及回收日志造成服务不可用。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/17/8E547O.png" alt="在这里插入图片描述"></p><p>为什么要降级<br>在不影响业务核心链路的情况下，屏蔽某些不重要的业务功能，可以节省系统的处理时间，提供系统的响应能力，在服务器资源固定的前提下处理更多的请求。</p><h3 id="4-3限流"><a href="#4-3限流" class="headerlink" title="4.3限流"></a>4.3限流</h3><p>限流是针对服务请求数量的一种自我保护机制，当请求数量超出服务的处理能力时，会自动丢弃新来的请求。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/17/6OD5FS.png" alt="在这里插入图片描述"></p><p>为什么要限流<br>任何一个系统的处理能力都是有极限的，假定服务A的处理能力为TPS=100，当TPS&lt;100时服务A可以提供正常的服务。当TPS&gt;100时，由于请求量增大，会出现争抢服务资源的情况（数据库连接、CPU、内存等），导致服务A处理缓慢；当TPS继续增大时，可能会造成服务A响应更加缓慢甚至奔溃。如果不进行限流控制，服务A始终会面临着被大流量冲击的风险。所以我们需要做好系统请求流量的评估，制定合理的限流策略。</p><h3 id="4-4熔断"><a href="#4-4熔断" class="headerlink" title="4.4熔断"></a>4.4熔断</h3><p>在服务的依赖调用中，被调用方出现故障时，出于自我保护的目的，调用方会主动停止调用，并根据业务需要进行相应处理。调用方这种主动停止调用的行为我们称之为熔断。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/17/V3TjCt.png" alt="在这里插入图片描述"></p><p>为什么要熔断<br>假定服务A依赖服务B，当服务B处于正常状态，整个调用是健康的，服务A可以得到服务B的正常响应。当服务B出现故障时，比如响应缓慢或者响应超时，如果服务A继续请求服务B，那么服务A的响应时间也会增加，进而导致服务A响应缓慢。如果服务A不进行熔断处理，服务B的故障会传导至服务A，最终导致服务A也不可用。</p><h2 id="5-traceid"><a href="#5-traceid" class="headerlink" title="5.traceid"></a>5.traceid</h2><p>日志中串一次请求的id，系统并发的时候，多次请求的日志会交叉打印，排查问题会比较难受，可以在代码中加入traceid，可以串起来一次完整请求，有条件的可以把traceid进行传递，这样就能用traceid把一起完整的请求在各应用系统中一起串起来，也就实现了链路追踪功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Constant中的TRACE_ID定义</span></span><br><span class="line"><span class="comment">//日志中的traceid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRACE_ID = <span class="string">&quot;traceId&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//traceidInterceptor</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIDInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        String traceID = request.getHeader(Constant.TRACE_ID);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(traceID)) &#123;</span><br><span class="line">            traceID = UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        MDC.put(Constant.TRACE_ID, traceID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry interceptorRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多个拦截器组成一个拦截器链</span></span><br><span class="line">        <span class="comment">// addPathPatterns 用于添加拦截规则</span></span><br><span class="line">        <span class="comment">// excludePathPatterns 用户排除拦截</span></span><br><span class="line">        interceptorRegistry.addInterceptor(<span class="keyword">new</span> TraceIDInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果feign方式调用往下游传递的可以加上下面的Interceptor</span></span><br><span class="line"><span class="keyword">import</span> feign.RequestInterceptor;</span><br><span class="line"><span class="keyword">import</span> feign.RequestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span><br><span class="line">        String traceID = MDC.get(Constant.TRACE_ID);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(traceID)) &#123;</span><br><span class="line">            traceID = UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        requestTemplate.header(Constant.HEADER_TRACE_ID, traceID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志配置文件中加入</span></span><br><span class="line">[%X&#123;traceId&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时接口调用的traceid加完了，但是例如mq、调度之类的可能不行，需要在此类代码入口手动设置traceid</span></span><br><span class="line">MDC.put(Constant.TRACE_ID, UUID.randomUUID().toString());</span><br></pre></td></tr></table></figure><h2 id="6-方法执行时间注解"><a href="#6-方法执行时间注解" class="headerlink" title="6.方法执行时间注解"></a>6.方法执行时间注解</h2><p>一个接口调用了一次数据库查询，一次数据库保存，两次rpc。某一天上游反馈接口慢，该如何进行排查呢？</p><p>优化接口慢，那就得找到影响接口耗时的关键点，我们如果知道了数据库查询耗时，数据库保存耗时，两次rpc的分别耗时，是否问题就迎刃而解了呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义Timer注解</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标注需要记录时间消耗的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Timer &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aop环绕获取方法执行耗时</span></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间记录切面，收集接口的运行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修正Timer注解的全局唯一限定符</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.renrenche.pricing.process.annotation.Timer)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 获取目标类名称</span></span><br><span class="line">        String clazzName = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">// 获取目标类方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        log.info(&quot;================================&#123;&#125;: &#123;&#125;: start...&quot;, clazzName, methodName);</span></span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        log.info(<span class="string">&quot;耗时统计:clazzName:&#123;&#125;,methodName:&#123;&#125;,time:&#123;&#125; ms&quot;</span>, clazzName, methodName, time);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用法，在需要监控耗时的方法上添加@Timer注解即可</span></span><br><span class="line">耗时统计:clazzName:com.xx.xx.XX,methodName:queryXX,time:<span class="number">10</span> ms</span><br><span class="line">耗时统计:clazzName:com.xx.xx.XX,methodName:saveXX,time:<span class="number">20</span> ms</span><br><span class="line">耗时统计:clazzName:com.xx.xx.YY,methodName:queryYY,time:<span class="number">50</span> ms</span><br><span class="line">耗时统计:clazzName:com.xx.xx.ZZ,methodName:queryZZ,time:<span class="number">500</span> ms</span><br><span class="line">我们只需要去找下游zz系统负责人沟通接口耗时问题即可</span><br></pre></td></tr></table></figure><h2 id="7-业务自定义异常优化"><a href="#7-业务自定义异常优化" class="headerlink" title="7.业务自定义异常优化"></a>7.业务自定义异常优化</h2><p>关于系统内部自定义业务异常，单系统内部定义一个即可，另外需要重写Throwable中fillInStackTrace方法，原因有二，一方面原fillInStackTrace方法被synchronized修饰，另一方面fillInStackTrace方法中设置了很多堆栈信息，对于自定义业务异常来说是不太需要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String errorCode, String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(String errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMessage</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写以提高性能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AppRuntimeException&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;errorCode=&#x27;&quot;</span> + errorCode + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, errorMessage=&#x27;&quot;</span> + errorMessage + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-错误文案转换器"><a href="#8-错误文案转换器" class="headerlink" title="8.错误文案转换器"></a>8.错误文案转换器</h2><p>提供给app前端或者web管理后台相关的写接口，接口返回错误码的时候，前端同学一般会tost提示用户错误信息，一般情况下前端同学要么全部提示系统太火爆了，要么会跟后端同学要接口的错误码列表，然后跟产品一起确认每个错误码该tost什么信息，之后if else 错误码和tost文案一一映射，如果后端新加了错误码，需要前端一起更改，没有及时通知，可能前端页面会弹出技术性文案。</p><p>如果所有的友好性提示统一是后端下发呢？是不是就可以规避类似的问题，前端同学只需关心如果正常返回，提示成功，接口没有成功，直接tost后端返回的错误msg提示即可，你好我好大家好～</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">###############yml文件配置###############</span><br><span class="line">#错误信息转换，给前端以友好提示</span><br><span class="line">errormsgconfig:</span><br><span class="line">  errorMsgConvertMap:</span><br><span class="line">    #key以controller_method命名</span><br><span class="line">    PricingController_setPricing:</span><br><span class="line">      <span class="keyword">default</span>: 系统太火爆了，请您稍后再试~</span><br><span class="line">      <span class="number">0</span>: 定价成功</span><br><span class="line">      <span class="number">1</span>: 系统太火爆了，请您稍后再试~</span><br><span class="line">      <span class="number">5</span>: 请刷新后重试</span><br><span class="line">    PricingController_getPricingOrderDetail:</span><br><span class="line">      <span class="keyword">default</span>: 系统太火爆了，请您稍后再试~</span><br><span class="line">      -<span class="number">42</span>: 没有权限！</span><br><span class="line"></span><br><span class="line">###############config文件###############</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;errormsgconfig&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMsgConvertConf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String,String&gt;&gt; errorMsgConvertMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###############错误文案转换Adapter###############</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误信息转换，给前端以友好提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMsgAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ErrorMsgConvertConf errorMsgConvertConf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息转换，给前端以友好提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Timer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerErrorMsg</span><span class="params">(String convertKey, Response res)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, String&gt;&gt; errorMsgConvertMap = errorMsgConvertConf.getErrorMsgConvertMap();</span><br><span class="line">        Map&lt;String, String&gt; convertMap = errorMsgConvertMap.get(convertKey);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(convertKey) || Objects.isNull(res)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;ErrorMsgAdapter.handlerErrorMsg,参数为空，直接返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;出参返回信息转换开始，convertKey:&#123;&#125;,oldRes:&#123;&#125;&quot;</span>, convertKey, JSONObject.toJSONString(res));</span><br><span class="line">        <span class="keyword">if</span> (ErrorCode.OK.getCode() == res.getStatus() &amp;&amp; !CollectionUtils.isEmpty(convertMap)) &#123;</span><br><span class="line">            String codeMsg = convertMap.get(Integer.toString(ErrorCode.OK.getCode()));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(codeMsg)) &#123;</span><br><span class="line">                res.setErrMsg(codeMsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ErrorCode.OK.getCode() != res.getStatus() &amp;&amp; !CollectionUtils.isEmpty(convertMap)) &#123;</span><br><span class="line">            String defaultMsg = convertMap.get(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(defaultMsg)) &#123;</span><br><span class="line">                defaultMsg = <span class="string">&quot;系统太火爆了，请您稍后再试~&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String codeMsg = convertMap.get(Integer.toString(res.getStatus()));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(codeMsg)) &#123;</span><br><span class="line">                res.setErrMsg(codeMsg);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.setErrMsg(defaultMsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;出参返回信息转换结束，convertKey:&#123;&#125;,oldRes:&#123;&#125;&quot;</span>, convertKey, JSONObject.toJSONString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###############使用方法###############</span><br><span class="line">##controller出参前调用即可，convertKey建议使用controllerName_methodName</span><br><span class="line"><span class="comment">//错误码转换</span></span><br><span class="line">errorMsgAdapter.handlerErrorMsg(<span class="string">&quot;PricingController_setPricing&quot;</span>, ret);</span><br></pre></td></tr></table></figure><h2 id="9-validationutil"><a href="#9-validationutil" class="headerlink" title="9.validationutil"></a>9.validationutil</h2><p>很多人喜欢在controller层的req前面增加 @Validated，直接对入参进行格式校验，但是这样做如果字段格式不符合要求，不会进行入参打印，不利于问题排查，另一方面抛出的异常也不是我们指定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.renrenche.pricing.process.exception.BizException;</span><br><span class="line"><span class="keyword">import</span> com.renrenche.rest.protocol.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidatorFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        Validator validator = factory.getValidator();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;T&gt;&gt; constraintViolations = validator.validate(t);</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(constraintViolations))&#123;</span><br><span class="line">            StringBuilder errMsg=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;参数校验失败&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConstraintViolation&lt;T&gt; constraintViolation : constraintViolations) &#123;</span><br><span class="line">                errMsg.append(<span class="string">&quot;,&quot;</span>).append(constraintViolation.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;ValidationUtil校验参数失败&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BizException(ErrorCode.PARAM_INVALID, errMsg.toString());</span><br><span class="line">          <span class="comment">//此处可以定义一个专门的业务异常码值来代表参数异常，msg放的是全量信息，可以for循环返回全量未通过原因，也可以只返回单条，不过多次请求返回的信息会有不同。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用法  代码显示调用</span></span><br><span class="line">ValidationUtil.validate(xxx);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.renrenche.pricing.process.validation.ValidationUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoReq</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;name不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 30, message = &quot;name应该在6-30字符之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;年龄必须大于等于18&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 20, message = &quot;年龄必须小于等于20&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;nameList不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nameList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^(.+)@(.+)$&quot;, message = &quot;邮箱的格式不合法&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Byte type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer type2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;aaaaa|bbbbb|ccccc&quot;, message = &quot;type3不在枚举范围内&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String type3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DecimalMin(value = &quot;150&quot;, message = &quot;必须大于等于150&quot;)</span></span><br><span class="line">    <span class="meta">@DecimalMax(value = &quot;300&quot;, message = &quot;必须小于等于300&quot;)</span></span><br><span class="line">    <span class="meta">@Digits(integer=3,fraction = 2,message = &quot;整数位上限为3位，小数位上限为2位&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoReq demoReq=<span class="keyword">new</span> DemoReq();</span><br><span class="line">        demoReq.setName(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line"><span class="comment">//        demoReq.setType3(&quot;222&quot;);</span></span><br><span class="line">        ValidationUtil.validate(demoReq);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果有对象实体，需要深入校验对象内部字段格式的，需要在实体上增加@valid注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-统一日志打印"><a href="#10-统一日志打印" class="headerlink" title="10.统一日志打印"></a>10.统一日志打印</h2><p>各公司内部应该针对于日志打印格式形成一个统一的规范，方便日志采集，不管是最终收集到公司内部自建日志平台，还是elk，格式还是得统一的。</p><p>抛砖引玉：</p><p>log4j2 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern: &quot;[%X&#123;trace_id&#125;] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; - [%p] [%C&#123;1&#125; %M] %m%n&quot; </span><br></pre></td></tr></table></figure><p>logback配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%X&#123;trace_id&#125;] %d&#123;yyyy-MM-dd HH:mm:ss&#125; - [%level] [%class&#123;0&#125; %method] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>日志示例：</p><p>[ed02f4ae5f18415b8a0143100b585f0e] 2019-03-14 18:32:08 - [INFO] [LogController test] this is my log!!!</p><p>另外很关键的日志打印必不可少，包括自己接口的入参&amp;返回，以及调用三方rpc接口的入参&amp;返回，用于查询线上问题，跟三方扯皮 ，屡试不爽。</p><h2 id="11-接入统一日志平台"><a href="#11-接入统一日志平台" class="headerlink" title="11.接入统一日志平台"></a>11.接入统一日志平台</h2><p>之前服务是单体架构，一个服务就对应一台服务器，排插生产问题时，登陆服务器即可。</p><p>现在都是微服务架构，一个服务一般对应多台服务器，jd、阿里之类的核心系统服务器一个项目都是上千上万台，此时排查问题如果一台一台登陆去查找就根本没法处理了。</p><p>所以一般公司内部都会有自建日志平台或者elk来支持生产日志的存储及查询。</p><p>一般的一个查询流程：根据关键词查询到单条日志，获取到traceid，然后继续根据traceid查询出来本次请求的全量日志进行排查。</p><h2 id="12-日志级别动态变更"><a href="#12-日志级别动态变更" class="headerlink" title="12.日志级别动态变更"></a>12.日志级别动态变更</h2><p>一般有三个很实际的场景会使用，一个是大促（双十一、618），一个是秒杀，另一个是线上出问题但是还未定位到问题时。</p><p>前两种是因为用户合法请求非常多，打印的日志非常多，最后一种是用户会频繁点击，流量激增且错误日志打印非常多。此时都会造成机器io压力非常大。再介绍一下一般情况下运维清理服务器日志的流程，一般是定时每隔xx时间去扫描服务器磁盘空间剩余百分比，到达阈值会进行日志备份，之后删除服务器上日志。但是上面三种情况下，会有两个问题，首先是磁盘io会非常高，会影响接口性能，另外在运维同学脚本扫描的间隙，磁盘满了，此时服务就废了，这种关键时间点出事情，P0少不了，轻则个人拜拜，重则部门解散，后果很严重。</p><p>一般会对日志进行级别的动态调整，平时线上为info，大促时降到error，线上大流量服务出问题时，可以关闭error日志。更优化的一个解决方案时不按照项目级别统一对日志级别进行调整，还是针对单个的logger类来进行调整，这样会更有针对性一些，因为日志降级是个双刃剑，会提升系统性能，但是同样会丢失日志。</p><h2 id="13-丝滑上线"><a href="#13-丝滑上线" class="headerlink" title="13.丝滑上线"></a>13.丝滑上线</h2><p>三个方面。 技术层面。  业务层面。发版经验 。</p><ul><li>技术层面：</li></ul><p>以Nacos注册中心为例，服务a有两台服务器，一般上线的时候大家就直接先部署服务器1，启动成功后再部署服务器2，此时会有什么问题呢，直接重启服务器1的时候，Nacos是不知道服务器1下线了，还会把请求转发到服务器1上面，过一段时间Nacos心跳检测发现服务器1宕机了，此时才会停止转发请求到服务器1，但是上游来看已经有超时失败的请求了。</p><p>一个合理的上线流程是先在Nacos上对服务器1的机器进行下线，观察服务器1日志，确认无请求进入后，重启服务器1，此时Nacos会自动重新上线服务器1，之后观察服务器1有正常请求进入后，在Nacos上对服务器2的机器进行下线，观察服务器2的日志，确认无请求进入后，重启服务器2，确保服务器2请求正常进入，本次发版结束。</p><p>为啥需要Nacos上对服务器下线以后还要继续观察日志呢，因为在Nacos下线一台服务器后，实际生效会有一个短暂的间隔。</p><p>上面这样做对于一个服务就三五台服务器的机器来说，还算有可操作性，大厂里面服务器都是几十台起步，有的上千台，这样搞效率很低，所以一般每个公司都会有自建的发版平台（eg：devops），在对机器发版的时候，会自动进行服务流量下线、发版、上线这样的操作，对用户来讲就是选择几台机器，然后发版就ok了。</p><ul><li>业务层面：</li></ul><p>经常会有的一个需求是对某个接口的流程进行升级，而且还有可能是颠覆性的，此时如果直接上线，出点问题，整个流程都废了，P0怕是跑不了。</p><p>一般这种颠覆性或者重构性质的升级会保留老流程的逻辑，这就保证了有问题的快速流程切换，另外一方面会对新老流程进行切量，上线后都是100%老流程，之后1%新流量，观察，看请求是否符合预期，有问题，立马100%切老流程，没问题，接口逻辑正常，符合预期，继续5%，10%，直到100%新流程。</p><ul><li>发版经验：</li></ul><p>发版的时候一定要先只发一台，完了以后观察本次代码修改部分是否正常，然后也要观察error日志，看是否有影响其他流程，观察一段时间无问题，在批量对其他服务器进行发版。</p><p>有些公司服务器会分组，有的按机房分组，有的按调用方分组，此时不同分组的配置文件可能是会有些不同的，所以此时发版需要每个分组的机器各自发版一台，按上述流程进行观察，无问题后，对其他机器进行批量发版。配置文件的少配，配错经常发生，对线上操作一定要保持敬畏之心。</p><h2 id="14-服务隔离"><a href="#14-服务隔离" class="headerlink" title="14.服务隔离"></a>14.服务隔离</h2><p>核心服务需要分组部署提供服务，两种场景可以使用，服务是公共服务，其中一个业务方特别关键，公司黄金链路种的一环，另一个是多个业务方，其中一个量级特别大，其他的加起来也就一丢丢，此时可以进行服务隔离。</p><ul><li>类似于dubbo类型的服务可以分不同别名来供不同业务方使用来做到服务隔离</li><li>http类型的服务可以根据业务情况部署多套，举个例子：nginx A转发到服务器1和2，nginx B转发到服务器3和4，不用业务方调用不同的请求链接来进行服务隔离</li></ul><h2 id="15-远程rpc调用超时时间及重试控制"><a href="#15-远程rpc调用超时时间及重试控制" class="headerlink" title="15.远程rpc调用超时时间及重试控制"></a>15.远程rpc调用超时时间及重试控制</h2><p>为什么要进行超时设置呢？</p><p>由于下游服务响应过慢、线程死锁、线上BUG等一系列原因导致我们作为调用方调用之后一直没有响应。从而最终导致用户请求长时间得不到响应，同时长时间占有线程资源甚至会拖垮整个服务影响其他正常请求。所以我们应该进行超时设置，这是微服务中快速失败的一个基本手段。</p><p>第二个问题，我们该如何设置呢？</p><p>通常有两个层面的超时：服务级超时、接口级别的超时。服务级别的超时时间一般以最慢接口的耗时时间为基准。而且大部分框架都只会有服务级的超时设置，很少有接口级的超时设置。接口级的超时设置，没有必要所有接口都设置，仅针对流量极大、性能要求较高的接口进行单独设置就行。</p><p>第三个问题，服务超时时我们该如何处理呢？</p><p>基于这个这个问题，我们需要从上下游、流量、业务场景这三个维度进行考量。</p><p>超时的处理手段一般有两种：重试、异常快速返回。写场景通常不要重试（会有幂等相关问题，不同接口幂等实现方式不同）。流量较大的接口一般不适合重试，直接返回异常就好，最极端的场景下容易导致流量翻n倍，导致后面的链路奔溃。</p><p>具体超时时间和重试次数建议根据下游接口的压测TP999来进行设置。</p><p>eg：a服务依赖b（读）、c（读）、d（写）服务，b服务tp999为15ms，c服务tp999为100ms，d服务tp999为20ms，a服务要求tp999必须在200ms以内，那么我们可以这样设置：</p><p>b服务（超时时间20ms，重试一次）</p><p>C服务（超时时间120ms，不重试）</p><p>d服务（超时时间30ms，不重试）</p><p> b极端情况20*2+c极端120+d极端30=190ms&lt;200ms</p><h2 id="16-幂等处理"><a href="#16-幂等处理" class="headerlink" title="16.幂等处理"></a>16.幂等处理</h2><p>接口的幂等一般采用两层防护措施进行防重设计。</p><p>首先一般接口会加上调用请求流水号字段</p><p>1.Redis的分布式锁来解决同类型请求的并发（相同用户并发请求，看情况，有的业务也可以不需要，因为毕竟有数据看兜底）</p><p>2.1分布式锁中按照请求流水号查询数据，有记录则直接返回现有数据状态及数据，无记录继续往下执行业务逻辑</p><p>2.2分布式锁中执行业务逻辑，然后保存业务数据，通过抓取保存时数据库报唯一键值冲突错来达到幂等处理，返回数据现有情况</p><p>3.DB层，请求唯一流水号设置唯一索引，保证DB底层只有一条数据入库。</p><p>通常情况幂等操作会按照上述逻辑进行，相同流水号怎么请求，返回的都是当前时间点该条数据的真实情况，但是也有做的简单的情况，按照流水号查询，有数据，抛异常，直接返回上游错误码，但是需要注意如果用这种方式，一方面需要保证该接口幂等错误码唯一，不要其他校验失败也返回这个错误码，另一方面要暴露查询接口，让上游收到该错误码后可以继续进行查询来得到最新的状态等信息，一般建议用上面的方案，你好我好大家好，大家写代码都挺舒服对吧。</p><h1 id="三、数据治理"><a href="#三、数据治理" class="headerlink" title="三、数据治理"></a>三、数据治理</h1><h2 id="1-慢查询治理"><a href="#1-慢查询治理" class="headerlink" title="1.慢查询治理"></a>1.慢查询治理</h2><p>公司内部有慢sql相关自动报警最好，如果没有，尽量每隔一段时间主动找dba看看自己负责系统相关库表中是否有慢sql，然后在根据不同场景来决定优化业务流程或者修改增加索引。</p><h2 id="2-数据备份与恢复"><a href="#2-数据备份与恢复" class="headerlink" title="2.数据备份与恢复"></a>2.数据备份与恢复</h2><p>核心服务数据库主从同步还是需要有的，主库出问题的时候可以很快的进行主从切换，另一方面变相的做了数据备份，如果一些非实时查询逻辑也可以走从库。</p><h2 id="3-冷热数据分离"><a href="#3-冷热数据分离" class="headerlink" title="3.冷热数据分离"></a>3.冷热数据分离</h2><p>冷热数据分离可以有两个层面的分离，一个是把非常热点的数据放到缓存中，查询的时候热点数据从缓存中查询，非热点数据查询数据库；另一个层面冷热可以指比如近一年的数据相对经常查询，放到一张业务表中，一年前的数据在另一张表中，这样在查询正常业务的时候表中数据尽可能的少，性能相对就提高了，需要查询历史数据时查询另外的表或者库。</p><h2 id="4-历史数据归档"><a href="#4-历史数据归档" class="headerlink" title="4.历史数据归档"></a>4.历史数据归档</h2><p>跟冷热数据分离有些异曲同工之处，比如银行流水查询，可以在App内查询近一两年的数据，查询历史数据需要去营业厅查询，相当于业务库中只保留近一两年的数据，再往前之前的数据会做归档，放到比如ES或者hbase等大数据存储介质中</p><h1 id="四、变更管控"><a href="#四、变更管控" class="headerlink" title="四、变更管控"></a>四、变更管控</h1><h2 id="1-发布、资源变更"><a href="#1-发布、资源变更" class="headerlink" title="1.发布、资源变更"></a>1.发布、资源变更</h2><p>每次上线前，准备本次上线checklist，包含数据库变更，数据库初始化数据，配置文件，发版先后顺序，相关数据库、redis、mq等资源申请等</p><h2 id="2-数据变更"><a href="#2-数据变更" class="headerlink" title="2.数据变更"></a>2.数据变更</h2><p>数据库变更表结构，人工插入、修改、变更线上数据，需要经过评估。</p><p>eg：修改数据是否会对线上流程造成影响，增加索引时库中多少数据，大体需要多长时间等等</p><h2 id="3-流量灰度"><a href="#3-流量灰度" class="headerlink" title="3.流量灰度"></a>3.流量灰度</h2><p>线上有10台服务正在提供服务，发版的时候直接一股脑全都发版么，如果代码比如有些配置有问题，线上机器就全部完蛋了。</p><p>可以两个方面处理，一个是在启动10台服务，流量0，保证新的项目起来后，逐步10%、20%。。。100%把流量切过来，亦或是10台里面找一台先发布，并在启动后进行观察，是否有问题，在逐步启动其他机器。</p><h2 id="4-A-B-Testing"><a href="#4-A-B-Testing" class="headerlink" title="4.A/B Testing"></a>4.A/B Testing</h2><p>使用老版本，一部分用户开始用新版本，如果用户对新版本没有什么意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来</p><p>某些功能上线前后区别很大，此时可以后端两套逻辑，基于用户唯一id取模，保证相同的用户每次进来看到的都是相同的，不要每次进来一会新版，一会老版。</p><p>AB很大程度上是基于用户维度做一些事情，而流量灰度则不care这些，整体流量百分比来的，可能用户一会走到新代码里，一会老代码里</p><h1 id="五、容量评估"><a href="#五、容量评估" class="headerlink" title="五、容量评估"></a>五、容量评估</h1><h2 id="1-全链路压测"><a href="#1-全链路压测" class="headerlink" title="1.全链路压测"></a>1.全链路压测</h2><p>压测指的基于当前负责的系统为入口，而全链路指的是基于页面访问的接口作为入口。</p><p>类似于618，业务会根据往年流量来预估本次的流量，技术侧也同样会基于往年每次的增量来进行预估，看是否可以包住业务的预估数据，每个接口都会梳理进4-5次大促的流量峰值数据，以次进行推算，最终决定出来本年度全链路压测量级、每个接口的压测量级。之后压测量级同步下游，最外层压测接口比如要求tps10w/s，下游各接口根据实际情况进行数值调整，没有循环调用的可以定位11-12w/s，有循环调用的下游需要进行相应的翻倍操作，作为底层服务的需要沟通各上游调用方，汇总得出系统本次需要支持的tps量级。</p><p>接下来就是各业务系统压测各自接口，都达标后，进行多轮全链路压测（军演），还会在线上进行破坏性压测，量级达到目标后继续往上走，直到下游有服务扛不住为止，对系统设计、代码编写都有非常大的考验，下游系统挂了，如何尽可能的不影响自身业务，并且等待下游恢复后如何重试这段时间内的请求等等～</p><h2 id="2-容量规划"><a href="#2-容量规划" class="headerlink" title="2.容量规划"></a>2.容量规划</h2><p>服务上线申请多少台服务器？多少台服务器可以应对本次大促流量峰值？</p><p>eg：比如一个项目中只有一个普通的没有使用多线程的接口，接口tp999在200ms，可以预估一秒一个线程处理5个请求，容器（如tomcat）配置200线程，那么单机可以支撑1000tps，要求1w tps，最少需要10台机器，为了一些极端情况可以先申请12-15台进行压测，看服务器各项指标情况，在达标的时候cpu60-80%为宜，这样天然的微峰值留有一些余地。</p><p>使用多线程的接口，需要对线程进行编排，调整线程池的各项参数使性能达到最优，单服务器能够支持的并发肯定是低于上面这种情况，具体能够支持多少，需要压测来进行统计。</p><p>但是现实情况往往一个项目中有若干个接口，此时流量特别小的接口可以忽略，比如tps低于5的，之后统计各接口需要各自达到什么量级的目标，之后进行混压，要求各接口都要达标的情况下看需要多少机器。</p><h2 id="3-弹性能力建设"><a href="#3-弹性能力建设" class="headerlink" title="3.弹性能力建设"></a>3.弹性能力建设</h2><p>此处是类似于devops公司发版平台需要考虑的一些问题，配合流量预测和感知，发现目前服务承载不了请求了，动态对服务进行扩容</p><h1 id="六、风险感知"><a href="#六、风险感知" class="headerlink" title="六、风险感知"></a>六、风险感知</h1><h2 id="1-资源监控"><a href="#1-资源监控" class="headerlink" title="1.资源监控"></a>1.资源监控</h2><p>监控服务器，容器jvm，mysql，redis等相关资源的监控信息</p><p>eg 服务器内存、网络、io，mysql读/写tps、慢sql、内存、容量、连接数、网络流量等～</p><p>配上相关阈值报警，开发、运维能够及时知道相关资源问题</p><h2 id="2-业务监控"><a href="#2-业务监控" class="headerlink" title="2.业务监控"></a>2.业务监控</h2><p>针对业务数据制作实时数据报表、T+1数据报表，每日关注核心业务报表（统计图、统计表），观察同环比，是否有异常，及时发现问题</p><h2 id="3-安全监控"><a href="#3-安全监控" class="headerlink" title="3.安全监控"></a>3.安全监控</h2><p>运维团队针对网络攻击（eg：DDoS攻击）进行监控并进行防御及报警</p><h2 id="4-拨测"><a href="#4-拨测" class="headerlink" title="4.拨测"></a>4.拨测</h2><p>项目中提供类似于/health的接口，接口内无任何逻辑即可，拨测平台定时（eg：每分钟）调用后只需判定http状态码200即可基本断定服务还活着，没有hang住并且有节点在提供服务。</p><h2 id="5-系统巡检"><a href="#5-系统巡检" class="headerlink" title="5.系统巡检"></a>5.系统巡检</h2><p>资源类的有问题基本都会有相关报警，有些代码报错等等之类的也可以通过自定义报警实现，相对于来说比较不容易发现的是业务数据类的问题，可以通过系统巡检机制保证。</p><p>此处尽量是建立在业务监控报表已经完毕的基础上，每日安排值班同学查看业务监控报表，查看业务数据量是否处于不合理的区间或者是流量激增以及流量极具减少，及时发现并分析原因，同步业务同学。</p><h2 id="6-钉钉业务报警"><a href="#6-钉钉业务报警" class="headerlink" title="6.钉钉业务报警"></a>6.钉钉业务报警</h2><p>代码中关键的节点，需要增加报警机制，可以使用公司内部的报警控件亦或钉钉报警，在线上出现一些问题的时候，能够自动发出报警来通知开发、运维同学来及时解决问题。</p><h2 id="7-tps-tp999-max监控"><a href="#7-tps-tp999-max监控" class="headerlink" title="7.tps/tp999/max监控"></a>7.tps/tp999/max监控</h2><p>监控平台监控每一个接口的tps，tp99，tp999，max，根据tp999可以进行接口优化，max抖动可以进一进行调优，看是机器问题，抑或是gc的stw问题、网络问题、跨机房问题等等。</p><p>TP90就是满足90%的网络请求所需要的最低耗时(90%的请求耗时情况)。</p><p>TP99就是满足99%的网络请求所需要的最低耗时。TP99=10ms，标识这段时间99%的请求都在10毫秒以内。</p><p>TP999就是满足999‰的网络请求所需要的最低耗时。</p><p>MAX就是这段时间内耗时最大的，比如MAX=1000ms，表示这段时间最耗时的一次请求是1s，max高表示偶有一次请求，耗时很大。</p>]]></content>
      
      
      <categories>
          
          <category> 11.方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行页索引底层结构</title>
      <link href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先明确下什么是索引呢？假设我一张数据库的表存了10亿条数据，如果要查找出其中的10条数据，如果逐条遍历匹配的话，效率上肯定是无法容忍的。所以为了提高数据查询的效率，就需要对数据进行一些格式化的存储，来方便我们更快的查找，这就是索引。</p><p>索引其实是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】，为什么要有页呢？</p><p>如果我们在查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p><p>换句话讲，其实就是内存一次拉到磁盘的数据最少是16KB，内存写入磁盘的数据一次最少也是16KB。</p><p>上面解释清楚了索引和页，MySQL的InnoDB存储引擎是基于页来进行内存和磁盘的数据交互的。所以我们的数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。</p><p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/o9sjNL.png" alt="页行层级关系"></p><p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p><h1 id="一、行"><a href="#一、行" class="headerlink" title="一、行"></a>一、行</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p><h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><p>首先来看下，我们如何来指定行格式呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p>比如我们创建一张表来指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br></pre></td></tr></table></figure><h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/u1WZ5x.png" alt="行格式示意图"></p><h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>先来看额外的信息，其实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p><h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】</p><p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p><p>在Compact行格式中，会把所有的变长字段占用的真实长度全部逆序存储在记录的开头位置，形成一个变长字段长度列表。</p><p>比如我们刚才创建的那张表，我们来分析一下：</p><p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p><table><thead><tr><th>列名</th><th>储存内容</th><th>内容长度(十进制表示)</th><th>内容长度(十六进制表示)</th></tr></thead><tbody><tr><td>C1</td><td>‘aaaa’</td><td>4</td><td>0x04</td></tr><tr><td>C2</td><td>‘bbb’</td><td>3</td><td>0x03</td></tr><tr><td>C4</td><td>‘d’</td><td>1</td><td>0x01</td></tr></tbody></table><p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/GicNPe.png" alt="行记录demo"></p><p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p><p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p><p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p><p>【L】：真实占用的字节数</p><ol><li><ol><li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li></ol><p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p></li><li><p>如果M*W&gt;=255,这个时候再次分为两种情况： </p></li><li><ol><li>如果L&lt;=127，那就用1个字节表示</li><li>否则就用2个字节表示</li></ol></li></ol><p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p><p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p><p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p><p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p><p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p><h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p><p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p><p>看一下处理过程：</p><ol><li>首先统计出表中允许存储NULL的字段</li><li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li><li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li></ol><p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p><p>这个时候再来看我们上面创建的表中的记录。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Ar1SSA.png" alt="行记录null值列"></p><h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/DkHw2Y.png" alt="记录头信息"></p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p><p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p><p>在完善下我们开头创建的那张表的记录形象。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/hrhU7z.png" alt="行真实数据"></p><p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p><h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p><p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p><p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p><h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p><h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p><p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p><ol><li>真实数据</li><li>真实数据占用的字节长度</li><li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li></ol><p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p><p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p><h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Lx6rk0.png" alt="行溢出1"></p><p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/9Nx5jA.png" alt="行溢出2"></p><p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p><h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p><p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p><p>分析一下页空间是如何利用的</p><ol><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：</li></ol><table><thead><tr><th>内容</th><th>大小(字节)</th></tr></thead><tbody><tr><td>真实数据的长度</td><td>2</td></tr><tr><td>列是否是NULL值</td><td>1</td></tr><tr><td>头信息</td><td>5</td></tr><tr><td>row_id</td><td>6</td></tr><tr><td>transaction_id</td><td>6</td></tr><tr><td>roll_pointer</td><td>7</td></tr></tbody></table><p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p><h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/uUTNzw.png" alt="行格式"></p><p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p><h1 id="二、页"><a href="#二、页" class="headerlink" title="二、页"></a>二、页</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p><p>本节分析存放表中记录的页，官方称为索引页，为了分析方便，我们暂且叫做数据页。</p><p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p><p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/wGkd2K.png" alt="页1"></p><p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页专有的一些信息</td></tr><tr><td>Infifmum + Supremum</td><td>最小记录和最大记录</td><td>26</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/bHvkJU.png" alt="页2"></p><p>再次回顾下记录头中5个字节表示的数据。</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>针对当前这个表的行格式简化图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/GRkUos.png" alt="页3"></p><p>接下来我们往表中插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/iHTjzS.png" alt="页4"></p><p>分析一下头信息中的每个属性是什么意思。</p><h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p><p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p><p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p><h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p><h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p><p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p><p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p><p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/4PMBmm.png" alt="页5"></p><p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/XJNMeJ.png" alt="页6"></p><p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p><h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p><p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p><h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/EF4CbT.png" alt="页7"></p><p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>删除第二条记录以后：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/bDrm6E.png" alt="页8"></p><p>发生的变化：</p><ul><li><p>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</p></li><li><p>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</p></li><li><p>第一条记录的next record指向了第三条记录</p></li><li><p>最大记录的 n_owned 值从5 变成了4</p></li></ul><p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p><p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p><p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p><p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/zGw6Ie.png" alt="页9"></p><p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p><h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol><li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li><li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li><li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li></ol><p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/rHTXYE.png" alt="页10"></p><p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p><p>注意最大和最小记录的头信息的n_owned属性：</p><ol><li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li><li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li></ol><p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/D4ieuJ.png" alt="页11"></p><p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。所以分组是按照下边的步骤进行的：</p><ul><li><p> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </p></li><li><p> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </p></li><li><p> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </p></li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/M7MnRG.png" alt="页12"></p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol><h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p><p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p><h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p><p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p><ol><li><p>前四个字节代表校验和</p></li><li><p>后四个字节代表页面被最后修改时对应的日志序列位置</p></li></ol><p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p><p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p><h1 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h1><h2 id="1-索引结构"><a href="#1-索引结构" class="headerlink" title="1.索引结构"></a>1.索引结构</h2><h3 id="1-1-聚簇索引"><a href="#1-1-聚簇索引" class="headerlink" title="1.1 聚簇索引"></a>1.1 聚簇索引</h3><p>上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p></li></ol><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。另外，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/j76g6u.png" alt="聚簇索引"></p><h3 id="1-2-二级索引"><a href="#1-2-二级索引" class="headerlink" title="1.2 二级索引"></a>1.2 二级索引</h3><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p><p>我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/pup6Oo.png" alt="二级索引"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：</p><ol><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义： </p><p>a页内的记录是按照c2列的大小顺序排成一个单向链表。</p><p>b各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。</p><p>c存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。 </p></li><li><p>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。 </p></li></ol><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为4的记录为例，查找过程如下：</p><p>1确定目录项记录页</p><p>根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 &lt; 4 &lt; 9）。</p><p>2通过目录项记录页确定用户记录真实所在的页。</p><p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页34和页35中。</p><p>3在真实存储用户记录的页中定位到具体的记录.</p><p>到页34和页35中定位到具体的记录。</p><p>4但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程也被称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！！！</p><p>为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不就好了么？</p><p>如果把完整的用户记录放到叶子节点是可以不用回表，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为为c2列建立的索引。</p><p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p><p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p><h3 id="1-3-联合索引"><a href="#1-3-联合索引" class="headerlink" title="1.3 联合索引"></a>1.3 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p><p>●先把各个记录和页按照c2列进行排序。</p><p>●在记录的c2列相同的情况下，采用c3列进行排序</p><p>为c2和c3列建立的索引的示意图如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/h5xwiY.png" alt="联合索引"></p><h1 id="四、总结：一次通过聚簇索引定位数据的过程"><a href="#四、总结：一次通过聚簇索引定位数据的过程" class="headerlink" title="四、总结：一次通过聚簇索引定位数据的过程"></a>四、总结：一次通过聚簇索引定位数据的过程</h1><p>大家熟悉的三个版本索引结构图如下</p><p>普通索引</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/cCfg6Z.png" alt="总结1"></p><p>二级索引</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/qwXHhA.png" alt="总结2"></p><p>组合索引索引</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/MiAzWo.png" alt="总结3"></p><p>相对完整些的三种索引结构见（三、索引）</p><p>下图为聚簇索引完整版结构</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/gfMbZY.png" alt="聚簇索引数据结构完整版"></p><p>一次按照主键id查询id=5的数据的全流程</p><p>1.确定目录项记录页，找到页50</p><p>2.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页55</p><p>3.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页61</p><p>4.二分查找确定所属槽位2，然后遍历槽位2里的链表得到id为4的数据</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql三大日志</title>
      <link href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
      <url>/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>日志是 <code>mysql</code> 数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。</p><p>作为开发，我们重点需要关注的是二进制日志( <code>binlog</code> )和事务日志(包括<code>redo log</code> 和 <code>undo log</code> )，本文接下来会详细介绍这三种日志。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p><code>binlog</code> 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code> 是 <code>mysql</code>的逻辑日志，并且由 <code>Server</code> 层进行记录，使用任何存储引擎的 <code>mysql</code> 数据库都会记录 <code>binlog</code> 日志。</p><ul><li><strong>逻辑日志</strong>：可以简单理解为记录的就是sql语句 。</li><li><strong>物理日志</strong>：<code>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li></ul><p><code>binlog</code> 是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code> 参数设置每个 <code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><h3 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a><strong>binlog使用场景</strong></h3><p>在实际应用中， <code>binlog</code> 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p><ol><li><strong>主从复制</strong> ：在 <code>Master</code> 端开启 <code>binlog</code> ，然后将 <code>binlog</code>发送到各个 <code>Slave</code> 端， <code>Slave</code> 端重放 <code>binlog</code> 从而达到主从数据一致。</li><li><strong>数据恢复</strong> ：通过使用 <code>mysqlbinlog</code> 工具来恢复数据。</li></ol><h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a><strong>binlog刷盘时机</strong></h3><p>对于 <code>InnoDB</code> 存储引擎而言，只有在事务提交时才会记录<code>biglog</code> ，此时记录还在内存中，那么 <code>biglog</code>是什么时候刷到磁盘中的呢？</p><p><code>mysql</code> 通过 <code>sync_binlog</code> 参数控制 <code>biglog</code> 的刷盘时机，取值范围是 <code>0-N</code>：</p><ul><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：每次 <code>commit</code> 的时候都要将 <code>binlog</code> 写入磁盘；</li><li>N：每N个事务，才会将 <code>binlog</code> 写入磁盘。</li></ul><p>从上面可以看出， <code>sync_binlog</code> 最安全的是设置是 <code>1</code> ，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p><h3 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a><strong>binlog日志格式</strong></h3><p><code>binlog</code> 日志有三种格式，分别为 <code>STATMENT</code> 、 <code>ROW</code> 和 <code>MIXED</code>。</p><blockquote><p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code> ， <code>MySQL 5.7.7</code> 之后，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p></blockquote><ul><li><p><code>STATMENT</code>：基于<code>SQL</code> 语句的复制( <code>statement-based replication, SBR</code> )，每一条会修改数据的sql语句会记录到<code>binlog</code> 中  。</p></li><li><ul><li>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO  , 从而提高了性能；</li><li>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、  slepp()  等 。</li></ul></li><li><p><code>ROW</code>：基于行的复制(<code>row-based replication, RBR</code> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</p></li><li><ul><li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；</li><li>缺点：会产生大量的日志，尤其是<code>alter table</code> 的时候会让日志暴涨</li></ul></li><li><p><code>MIXED</code>：基于<code>STATMENT</code> 和 <code>ROW</code> 两种模式的混合复制(<code>mixed-based replication, MBR</code> )，一般的复制使用<code>STATEMENT</code> 模式保存 <code>binlog</code> ，对于 <code>STATEMENT</code> 模式无法复制的操作使用 <code>ROW</code> 模式保存 <code>binlog</code></p></li></ul><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a><strong>为什么需要redo log</strong></h3><p>我们都知道，事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。</p><p>那么 <code>mysql</code>是如何保证一致性的呢？</p><p>最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p><ol><li>因为 <code>Innodb</code> 是以 <code>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li></ol><p>因此 <code>mysql</code> 设计了 <code>redo log</code> ， <strong>具体来说就是只记录事务对数据页做了哪些****修改，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</strong></p><h3 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a><strong>redo log基本概念</strong></h3><p><code>redo log</code> 包括两部分：一个是内存中的日志缓冲( <code>redo log buffer</code> )，另一个是磁盘上的日志文件( <code>redo logfile</code>)。</p><p><code>mysql</code> 每执行一条 <code>DML</code> 语句，先将记录写入 <code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到 <code>redo log file</code>。这种 <strong>先写日志，再写磁盘</strong> 的技术就是 <code>MySQL</code>里经常说到的 <code>WAL(Write-Ahead Logging)</code> 技术。</p><p>在计算机操作系统中，用户空间( <code>user space</code> )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( <code>kernel space</code> )缓冲区( <code>OS Buffer</code> )。</p><p>因此， <code>redo log buffer</code> 写入 <code>redo logfile</code> 实际上是先写入 <code>OS Buffer</code> ，然后再通过系统调用 <code>fsync()</code> 将其刷到 <code>redo log file</code>中，过程如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/HPDG3n.png" alt="redolog刷盘"></p><p><code>mysql</code> 支持三种将 <code>redo log buffer</code> 写入 <code>redo log file</code> 的时机，可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数配置，各参数值含义如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/mV0ryb.png" alt="redolog参数"></p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/u45X6d.png" alt="redolog参数图"></p><h3 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a><strong>redo log记录形式</strong></h3><p>前面说过， <code>redo log</code> 实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 <code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。</p><p>如下图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/emmy0S.png" alt="redolog环"></p><p>同时我们很容易得知， 在innodb中，既有<code>redo log</code> 需要刷盘，还有 <code>数据页</code> 也需要刷盘， <code>redo log</code>存在的意义主要就是降低对 <code>数据页</code> 刷盘的要求。</p><p>在上图中， <code>write pos</code> 表示 <code>redo log</code> 当前记录的 <code>LSN</code> (逻辑序列号)位置， <code>check point</code> 表示 <strong>数据页更改记录</strong> 刷盘后对应 <code>redo log</code> 所处的 <code>LSN</code>(逻辑序列号)位置。</p><p><code>write pos</code> 到 <code>check point</code> 之间的部分是 <code>redo log</code> 空着的部分，用于记录新的记录；<code>check point</code> 到 <code>write pos</code> 之间是 <code>redo log</code> 待落盘的数据页更改记录。当 <code>write pos</code>追上<code>check point</code> 时，会先推动 <code>check point</code> 向前移动，空出位置再记录新的日志。</p><p>启动 <code>innodb</code> 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 <code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 <code>binlog</code> )要快很多。</p><p>重启<code>innodb</code> 时，首先会检查磁盘中数据页的 <code>LSN</code> ，如果数据页的<code>LSN</code> 小于日志中的 <code>LSN</code> ，则会从 <code>checkpoint</code> 开始恢复。</p><p>还有一种情况，在宕机前正处于<code>checkpoint</code> 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 <code>LSN</code> 大于日志中的 <code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p><h3 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a><strong>redo log与binlog区别</strong></h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/QSGujy.png" alt="redolog和binlog区别"></p><p>由 <code>binlog</code> 和 <code>redo log</code> 的区别可知：<code>binlog</code> 日志只用于归档，只依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的。</p><p>但只有 <code>redo log</code> 也不行，因为 <code>redo log</code> 是 <code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code>binlog</code>和 <code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。</p><p>实际上， <strong>原子性</strong> 底层就是通过 <code>undo log</code> 实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条 <code>INSERT</code> 语句，对应一条<code>DELETE</code> 的 <code>undo log</code> ，对于每个 <code>UPDATE</code> 语句，对应一条相反的 <code>UPDATE</code> 的 <code>undo log</code> ，这样在发生错误时，就能回滚到事务之前的数据状态。</p><p>同时， <code>undo log</code> 也是 <code>MVCC</code>(多版本并发控制)实现的关键。</p><p>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生Undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</p><p>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。</p><p><strong>Undo Log 格式</strong></p><p>在InnoDB引擎中，undo log分为：</p><p><strong>insert undo log</strong>：</p><p>insert undo log是指在insert操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><p><strong>update undo log</strong>：</p><p>update undo log记录的是delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入undo log链表，等待purge线程进行最后的删除。下面是两种undo log的结构图。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/zVqeou.png" alt="image-20220111180418341"></p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redolog</title>
      <link href="/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/"/>
      <url>/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一，什么是redo日志"><a href="#一，什么是redo日志" class="headerlink" title="一，什么是redo日志"></a>一，什么是redo日志</h1><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们的CRUD操作其实都是在访问页面。在真正访问页面之前，需要把磁盘中的页加载到内存的BufferPool，之后才能访问，但是因为事务要保持持久性，如果我们仅仅在内存的缓冲池修改了页面，假设事务提交后突然发生故障，导致内存的数据都消失了，那么这个已经提交的事务在数据库做的更改就丢失了。</p><p>如何保证持久性呢？可以在事务提交完成之前，把事务修改的所有页面都刷新到磁盘。不过这样做存在一些问题：</p><ol><li>刷新一个完整的数据页过于浪费</li><li>随机IO效率比较低</li></ol><p>事实上仅仅是为了保证事务的持久性，没有必要每次提交事务的时候就把该事务在内存修改过的全部页面刷新到磁盘，只需要把修改的内容记录一下就好，这样在事务提交的时候，就会把这个记录刷新到磁盘。即使系统因为崩溃而重启只需要按照记录的内容重新更新数据页即可恢复数据，上述记录修改的内容就叫做重做日志（redo log）。</p><p>相比于在事务提交的时候将所有修改过的内存中的页面刷新到磁盘，重做日志有以下好处：</p><ol><li>redo日志占用空间小：在存储表空间ID，页号，偏移量以及需要更新的值时，需要的存储空间很小。</li><li>redo日志是顺序写入磁盘的：在执行事务过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li></ol><h1 id="二，redo日志格式"><a href="#二，redo日志格式" class="headerlink" title="二，redo日志格式"></a>二，redo日志格式</h1><p>重做日志本质上仅仅是记录了一下事务对数据库进行了哪些修改。针对事务对数据库的不同修改场景MySQL定义了很多种重做日志，但是大部分类型的重做日志都有以下的通用结构。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/6tRQtF.png" alt="img"></p><table><thead><tr><th>type</th><th>重做日志的类型</th></tr></thead><tbody><tr><td>space ID</td><td>表空间ID</td></tr><tr><td>page number</td><td>页号</td></tr><tr><td>Data</td><td>日志的具体内容</td></tr></tbody></table><h2 id="1-简单的redo日志类型"><a href="#1-简单的redo日志类型" class="headerlink" title="1. 简单的redo日志类型"></a>1. 简单的redo日志类型</h2><p>行格式里面有一个隐藏列叫做row_id。为row_id进行赋值的方式如下：</p><ol><li>服务器会在内存中维护一个全局变量，每当像某个包含row_id隐藏列的表插入一条记录的时候，就会把这个全局变量的值当做新记录row_id的值，并且把这个全局变量自增1。</li><li>每当这个全局变量的值是256的整数倍的时候，就会把这个变量的值刷新到系统表空间页号为7的页面中一个叫做Max Row ID的属性中。</li><li>当系统启动的时候，会将Max Row ID属性加载到内存，并把这个值加上256之后赋值给前面提到的全局变量。</li></ol><p>这个Max Row ID占用的存储空间是8字节。当某个事务向某个包含row_id的表插入一条记录并且该记录分配的row_id值为256的整数倍的时候，就会像系统表空间页号为7的页面的相应偏移量处写入8字节的值。但是这个写入操作实际上是在内存缓冲区完成的，我们需要把这次修改以redo日志的形式记录下来，这样在事务提交之后，即使系统崩溃，也可以将该页面恢复成崩溃前的状态。在这种对页面的修改特别简单的时候，重做日志仅仅需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体修改后的内容是什么就可以了。这也叫做物理日志。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/Mpyn2l.png" alt="img"></p><p>offset表示页面中的偏移量。如果写入的是字节序列类型的重做日志，还需要有一个len属性记录实际写入的长度。</p><h2 id="2-复杂的redo日志类型"><a href="#2-复杂的redo日志类型" class="headerlink" title="2.复杂的redo日志类型"></a>2.复杂的redo日志类型</h2><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）</p><p>这时我们如果使用简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p><ul><li><p>方案一：在每个修改的地方都记录一条<code>redo</code>日志。<br>也就是有多少个修改的记录，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多。 </p></li><li><p>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。<br><code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中太浪费了。 </p></li></ul><p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，<code>InnoDB</code>提出了一些新的<code>redo</code>日志类型。</p><p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p><ul><li><p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</p></li><li><p>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</p></li></ul><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/xzCFc2.jpeg" alt="img"></p><p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了什么，<code>PAGE_HEAP_TOP</code>的值修改为了什么，<code>PAGE_N_HEAP</code>的值修改为了什么等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p><p>日志格式说了一堆核心其实就是：<strong>重做日志会把事务执行过程中对数据库所做的所有修改都记录下来，在之后系统因为崩溃而重启后可以把事务所做的任何修改都恢复过来。</strong> </p><p>为了节省重做日志占用的空间大小，InnoDB还对重做日志中的某些数据进行了压缩处理，比如表空间ID&amp;page number 一般占用4字节来存储，但是经过压缩之后占用的空间就更小了。</p><h1 id="三，Mini-Transcation"><a href="#三，Mini-Transcation" class="headerlink" title="三，Mini-Transcation"></a>三，Mini-Transcation</h1><h2 id="1-以组的形式写入redo日志"><a href="#1-以组的形式写入redo日志" class="headerlink" title="1.以组的形式写入redo日志"></a>1.以组的形式写入redo日志</h2><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被<code>InnoDB</code>人为的划分成了若干个不可分割的组，比如：</p><ul><li><p>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</p></li><li><p>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p></li><li><p>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p></li><li><p>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</p></li></ul><p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p><ul><li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/CghxTC.png" alt="img"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/89BUTu.png" alt="img"> </p></li><li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/S3ify8.png" alt="img"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/TRO5IS.png" alt="img"><br>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表等，我们在介绍表空间那一篇中介绍过的各种东西)，反正总共需要记录的<code>redo</code>日志有二、三十条。 </p></li></ul><p>其实不光是悲观插入一条记录会生成许多条redo日志，InnoDB为了其他的一些功能，在乐观插入时也可能产生多条redo日志。</p><p><code>InnoDB</code>认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统崩溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是<code>InnoDB</code>所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统崩溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p><ul><li><p>有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。<br>如何把这些<code>redo</code>日志划分到一个组里边儿呢？<code>InnoDB</code>做了一个很简单的操作，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/xN2THQ.png" alt="img"><br>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/TZs2x6.png" alt="img"><br>这样在系统崩溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。 </p></li><li><p>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。<br>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，<code>InnoDB</code>不想浪费一个比特位。虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/x6uXSv.png" alt="img"><br>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。 </p></li></ul><h2 id="2-Mini-Transaction"><a href="#2-Mini-Transaction" class="headerlink" title="2.Mini-Transaction"></a>2.Mini-Transaction</h2><p><code>MySQL</code>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ELTRk2.png" alt="img"></p><h1 id="四，redo日志的写入过程"><a href="#四，redo日志的写入过程" class="headerlink" title="四，redo日志的写入过程"></a>四，redo日志的写入过程</h1><h2 id="1-redo-log-block"><a href="#1-redo-log-block" class="headerlink" title="1.redo log block"></a>1.redo log block</h2><p><code>InnoDB</code>为了更好的进行系统崩溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>。一个<code>redo log block</code>的示意图如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/0VAC8Y.png" alt="img"></p><p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZSpuiJ.png" alt="img"></p><p>其中<code>log block header</code>的几个属性的意思分别如下：</p><ul><li><p><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</p></li><li><p><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</p></li><li><p><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</p></li><li><p><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</p></li></ul><p><code>log block trailer</code>中属性的意思如下：</p><ul><li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h2 id="2-redo-日志缓冲区"><a href="#2-redo-日志缓冲区" class="headerlink" title="2.redo 日志缓冲区"></a>2.redo 日志缓冲区</h2><p><code>InnoDB</code>为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/902AmQ.png" alt="img"></p><p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p><h2 id="3-redo-log-日志写入log-buffer"><a href="#3-redo-log-日志写入log-buffer" class="headerlink" title="3.redo log 日志写入log buffer"></a>3.redo log 日志写入log buffer</h2><p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/PRG2NZ.png" alt="img"></p><p>一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p><ul><li><p>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</p></li><li><p>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</p></li></ul><p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/tKw7Ja.png" alt="img"></p><p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p><h1 id="五，redo-日志文件"><a href="#五，redo-日志文件" class="headerlink" title="五，redo 日志文件"></a>五，redo 日志文件</h1><h2 id="1-redo日志刷盘时机"><a href="#1-redo日志刷盘时机" class="headerlink" title="1.redo日志刷盘时机"></a>1.redo日志刷盘时机</h2><p>mtr<code>运行过程中产生的一组</code>redo<code>日志在</code>mtr<code>结束时会被复制到</code>log buffer`中，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li><p><code>log buffer</code>空间不足时<br><code>log buffer</code>的大小是有限的（通过系统变量<code>innodb_log_buffer_size</code>指定），如果不停的往这个有限大小的<code>log buffer</code>里塞入日志，很快它就会被填满。<code>InnoDB</code>认为如果当前写入<code>log buffer</code>的<code>redo</code>日志量已经占满了<code>log buffer</code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。 </p></li><li><p>事务提交时<br>之所以使用<code>redo</code>日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的<code>Buffer Pool</code>页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的<code>redo</code>日志刷新到磁盘。 </p></li><li><p> 将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次 强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。 </p></li><li><p>后台线程不停的刷<br>后台有一个线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo</code>日志到磁盘。 </p></li><li><p> 正常关闭服务器时 </p></li><li><p> 做所谓的<code>checkpoint</code>时 </p></li><li><p> 其他的一些情况… </p></li></ul><h2 id="2-redo日志文件组"><a href="#2-redo日志文件组" class="headerlink" title="2.redo日志文件组"></a>2.redo日志文件组</h2><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<code>log buffer</code>中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的<code>redo</code>日志文件不满意，可以通过下边几个启动参数来调节：</p><ul><li><p><code>innodb_log_group_home_dir</code><br>该参数指定了<code>redo</code>日志文件所在的目录，默认值就是当前的数据目录。 </p></li><li><p><code>innodb_log_file_size</code><br>该参数指定了每个<code>redo</code>日志文件的大小，在<code>MySQL 5.7.21</code>这个版本中的默认值为<code>48MB</code>， </p></li><li><p><code>innodb_log_files_in_group</code><br>该参数指定<code>redo</code>日志文件的个数，默认值为2，最大值为100。 </p></li></ul><p>磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2</code>…）的形式进行命名。在将<code>redo</code>日志写入<code>日志文件组</code>时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/7AHjCL.png" alt="img"></p><p>总共的<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><p>如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志？当然可能了！所以InnoDB提出了checkpoint的概念。</p><h2 id="3-redo日志文件格式"><a href="#3-redo日志文件格式" class="headerlink" title="3.redo日志文件格式"></a>3.redo日志文件格式</h2><p><code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个<code>512</code>字节大小的<code>block</code>。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的block组成。</p><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li><p>前2048个字节，也就是前4个block是用来存储一些管理信息的。</p></li><li><p>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</p></li></ul><p>所以我们前边所说的<code>循环</code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/EIZbn0.png" alt="img"></p><p>普通block的格式我们在了解<code>log buffer</code>的时候都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分。这里需要介绍一下每个<code>redo</code>日志文件前2048个字节，也就是前4个特殊block的格式都是什么作用。</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZlTsiQ.png" alt="img"><br>从图中可以看出来，这4个block分别是：</p><ul><li><code>log file header</code>：描述该<code>redo</code>日志文件的一些整体属性<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/EfCLpt.jpeg" alt="img"><br>各个属性的具体释义如下：  </li></ul><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_HEADER_FORMAT</code></td><td><code>4</code></td><td><code>redo</code>日志的版本，在<code>MySQL 5.7.21</code>中该值永远为1</td></tr><tr><td><code>LOG_HEADER_PAD1</code></td><td><code>4</code></td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td><code>LOG_HEADER_START_LSN</code></td><td><code>8</code></td><td>标记本<code>redo</code>日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值。</td></tr><tr><td><code>LOG_HEADER_CREATOR</code></td><td><code>32</code></td><td>一个字符串，标记本<code>redo</code>日志文件的创建者是谁。正常运行时该值为<code>MySQL</code>的版本号，比如：<code>&quot;MySQL 5.7.21&quot;</code>，使用<code>mysqlbackup</code>命令创建的<code>redo</code>日志文件的该值为<code>&quot;ibbackup&quot;</code>和创建时间。</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li><code>checkpoint1</code>：记录关于<code>checkpoint</code>的一些属性，看一下它的结构：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/quxD7L.jpeg" alt="img"><br>各个属性的具体释义如下：  </li></ul><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_CHECKPOINT_NO</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>的编号，每做一次<code>checkpoint</code>，该值就加1。</td></tr><tr><td><code>LOG_CHECKPOINT_LSN</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>结束时对应的<code>LSN</code>值，系统崩溃恢复时将从该值开始。</td></tr><tr><td><code>LOG_CHECKPOINT_OFFSET</code></td><td><code>8</code></td><td>上个属性中的<code>LSN</code>值在<code>redo</code>日志文件组中的偏移量</td></tr><tr><td><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code></td><td><code>8</code></td><td>服务器在做<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><ul><li><p> 第三个block未使用，忽略 </p></li><li><p> <code>checkpoint2</code>：结构和<code>checkpoint1</code>一样。 </p></li></ul><h1 id="六，Log-Sequence-Number"><a href="#六，Log-Sequence-Number" class="headerlink" title="六，Log Sequence Number"></a>六，Log Sequence Number</h1><p>自系统开始运行，就不断的在修改页面，也就意味着会不断的生成<code>redo</code>日志。<code>redo</code>日志的量在不断的递增。<code>InnoDB</code>为记录已经写入的<code>redo</code>日志量，设计了一个称之为<code>Log Sequence Number</code>的全局变量，翻译过来就是：<code>日志序列号</code>，简称<code>lsn</code>。<code>InnoDB</code>规定初始的<code>lsn</code>值为<code>8704</code>（也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值为<code>8704</code>）。</p><p>在向<code>log buffer</code>中写入<code>redo</code>日志时不是一条一条写入的，而是以一个<code>mtr</code>生成的一组<code>redo</code>日志为单位进行写入的。而且实际上是把日志内容写在了<code>log block body</code>处。但是在统计<code>lsn</code>的增长量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子：</p><ul><li><p>系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>（就是标记下一条<code>redo</code>日志应该写入到<code>log buffer</code>的位置的变量）就会指向第一个<code>block</code>的偏移量为12字节（<code>log block header</code>的大小）的地方，那么<code>lsn</code>值也会跟着增加12：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/DugAF2.png" alt="img"> </p></li><li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/SQQJDG.png" alt="img"><br>我们假设上图中<code>mtr_1</code>产生的<code>redo</code>日志量为200字节，那么<code>lsn</code>就要在<code>8716</code>的基础上增加<code>200</code>，变为<code>8916</code>。 </p></li><li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/uIAzpF.png" alt="img"><br>我们假设上图中<code>mtr_2</code>产生的<code>redo</code>日志量为1000字节，为了将<code>mtr_2</code>产生的<code>redo</code>日志写入<code>log buffer</code>，我们不得不额外多分配两个block，所以<code>lsn</code>的值需要在<code>8916</code>的基础上增加<code>1000 + 12×2 + 4 × 2 = 1032</code>。 </p></li></ul><p>从上边的描述中可以看出来，每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p><h2 id="1-flushed-to-disk-lsn"><a href="#1-flushed-to-disk-lsn" class="headerlink" title="1.flushed_to_disk_lsn"></a>1.flushed_to_disk_lsn</h2><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。所以<code>InnoDB</code>提出了一个称之为<code>buf_next_to_write</code>的全局变量，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/YRg7uh.png" alt="img"></p><p><code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，<code>InnoDB</code>提出了一个表示刷新到磁盘中的<code>redo</code>日志量的全局变量，称之为<code>flushed_to_disk_lsn</code>。系统第一次启动时，该变量的值和初始的<code>lsn</code>值是相同的，都是<code>8704</code>。随着系统的运行，<code>redo</code>日志被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值就和<code>flushed_to_disk_lsn</code>的值拉开了差距。我们推理一下：</p><ul><li><p> 系统第一次启动后，向<code>log buffer</code>中写入了<code>mtr_1</code>、<code>mtr_2</code>、<code>mtr_3</code>这三个<code>mtr</code>产生的<code>redo</code>日志，假设这三个<code>mtr</code>开始和结束时对应的lsn值分别是： </p></li><li><ul><li><code>mtr_1</code>：8716 ～ 8916</li></ul></li><li><ul><li><code>mtr_2</code>：8916 ～ 9948</li></ul></li><li><ul><li><code>mtr_3</code>：9948 ～ 10000</li></ul></li></ul><p>此时的<code>lsn</code>已经增长到了10000，但是由于没有刷新操作，所以此时<code>flushed_to_disk_lsn</code>的值仍为<code>8704</code>，如图：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/C04p7l.png" alt="img"></p><ul><li>随后进行将<code>log buffer</code>中的block刷新到<code>redo</code>日志文件的操作，假设将<code>mtr_1</code>和<code>mtr_2</code>的日志刷新到磁盘，那么<code>flushed_to_disk_lsn</code>就应该增长<code>mtr_1</code>和<code>mtr_2</code>写入的日志量，所以<code>flushed_to_disk_lsn</code>的值增长到了<code>9948</code>，如图：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZonfyU.png" alt="img"> </li></ul><p>综上所述，当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p><p>应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的<code>fsync</code>函数。其实只有当系统执行了<code>fsync</code>函数后，<code>flushed_to_disk_lsn</code>的值才会跟着增长，当仅仅把<code>log buffer</code>中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为<code>write_lsn</code>的值跟着增长。</p><h2 id="2-lsn值和redo日志文件偏移量的对应关系"><a href="#2-lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="2.lsn值和redo日志文件偏移量的对应关系"></a>2.lsn值和redo日志文件偏移量的对应关系</h2><p>因为<code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（当然有时候要加上<code>log block header</code>和<code>log block trailer</code>的大小），这样<code>mtr</code>产生的日志写到磁盘中时，很容易计算某一个<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量，如图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/AeVfio.png" alt="img"></p><p>初始时的<code>LSN</code>值是<code>8704</code>，对应文件偏移量<code>2048</code>，之后每个<code>mtr</code>向磁盘中写入多少字节日志，<code>lsn</code>的值就增长多少。</p><h2 id="3-flush链表中的LSN"><a href="#3-flush链表中的LSN" class="headerlink" title="3.flush链表中的LSN"></a>3.flush链表中的LSN</h2><p>一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p><p>当第一次修改某个缓存在<code>Buffer Pool</code>中的页面时，就会把这个页面对应的控制块插入到<code>flush链表</code>的头部，之后再修改该页面时由于它已经在<code>flush</code>链表中了，就不再次插入了。也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p><ul><li><p><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</p></li><li><p><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</p></li></ul><p>接着上边<code>flushed_to_disk_lsn</code>的例子看一下：</p><ul><li><p>假设<code>mtr_1</code>执行过程中修改了<code>页a</code>，那么在<code>mtr_1</code>执行结束时，就会将<code>页a</code>对应的控制块加入到<code>flush链表</code>的头部。并且将<code>mtr_1</code>开始时对应的<code>lsn</code>，也就是<code>8716</code>写入<code>页a</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_1</code>结束时对应的<code>lsn</code>，也就是8916写入<code>页a</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下（<code>oldest_modification</code>缩写成了<code>o_m</code>，<code>newest_modification</code>缩写成了<code>n_m</code>）：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/PVhnzR.png" alt="img"> </p></li><li><p>接着假设<code>mtr_2</code>执行过程中又修改了<code>页b</code>和<code>页c</code>两个页面，那么在<code>mtr_2</code>执行结束时，就会将<code>页b</code>和<code>页c</code>对应的控制块都加入到<code>flush链表</code>的头部。并且将<code>mtr_2</code>开始时对应的<code>lsn</code>，也就是8916写入<code>页b</code>和<code>页c</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_2</code>结束时对应的<code>lsn</code>，也就是9948写入<code>页b</code>和<code>页c</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/tm7l11.png" alt="img"><br>从图中可以看出来，每次新插入到<code>flush链表</code>中的节点都是被放在了头部，也就是说<code>flush链表</code>中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早。 </p></li><li><p>接着假设<code>mtr_3</code>执行过程中修改了<code>页b</code>和<code>页d</code>，不过<code>页b</code>之前已经被修改过了，所以它对应的控制块已经被插入到了<code>flush</code>链表，所以在<code>mtr_3</code>执行结束时，只需要将<code>页d</code>对应的控制块都加入到<code>flush链表</code>的头部即可。所以需要将<code>mtr_3</code>开始时对应的<code>lsn</code>，也就是9948写入<code>页d</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_3</code>结束时对应的<code>lsn</code>，也就是10000写入<code>页d</code>对应的控制块的<code>newest_modification</code>属性中。另外，由于<code>页b</code>在<code>mtr_3</code>执行过程中又发生了一次修改，所以需要更新<code>页b</code>对应的控制块中<code>newest_modification</code>的值为10000。画个图表示一下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZPeEx4.png" alt="img"> </p></li></ul><p>总结一下上边说的，就是：<strong>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</strong></p><h1 id="七，checkpoint"><a href="#七，checkpoint" class="headerlink" title="七，checkpoint"></a>七，checkpoint</h1><p><code>redo</code>日志文件组容量是有限的，我们不得不选择循环使用<code>redo</code>日志文件组中的文件，但是这会造成最后写的<code>redo</code>日志与最开始写的<code>redo</code>日志<code>追尾</code>，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。我们看一下前边的那个例子：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/q7pck5.png" alt="img"></p><p>如图，虽然<code>mtr_1</code>和<code>mtr_2</code>生成的<code>redo</code>日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在<code>Buffer Pool</code>中，所以它们生成的<code>redo</code>日志在磁盘上的空间是不可以被覆盖的。之后随着系统的运行，如果<code>页a</code>被刷新到了磁盘，那么它对应的控制块就会从<code>flush链表</code>中移除，就像这样子：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/H77nNy.png" alt="img"></p><p>这样<code>mtr_1</code>生成的<code>redo</code>日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。<code>InnoDB</code>提出了一个全局变量<code>checkpoint_lsn</code>来代表当前系统中可以被覆盖的<code>redo</code>日志总量是多少，这个变量初始值也是<code>8704</code>。</p><p>比方说现在<code>页a</code>被刷新到了磁盘，<code>mtr_1</code>生成的<code>redo</code>日志就可以被覆盖了，所以我们可以进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称之为做一次<code>checkpoint</code>。做一次<code>checkpoint</code>其实可以分为两个步骤：</p><ul><li><p>步骤一：计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。<br><code>redo</code>日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的<code>oldest_modification</code>值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的<code>oldest_modification</code>赋值给<code>checkpoint_lsn</code>。<br>比方说当前系统中<code>页a</code>已经被刷新到磁盘，那么<code>flush链表</code>的尾节点就是<code>页c</code>，该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code>值为8916，我们就把8916赋值给<code>checkpoint_lsn</code>（也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉）。 </p></li><li><p>步骤二：将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。<br><code>InnoDB</code>维护了一个目前系统做了多少次<code>checkpoint</code>的变量<code>checkpoint_no</code>，每做一次<code>checkpoint</code>，该变量的值就加1。我们前边说过计算一个<code>lsn</code>值对应的<code>redo</code>日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code>在<code>redo</code>日志文件组中对应的偏移量<code>checkpoint_offset</code>，然后把这三个值都写到<code>redo</code>日志文件组的管理信息中。<br>我们说过，每一个<code>redo</code>日志文件都有<code>2048</code>个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。不过我们是存储到<code>checkpoint1</code>中还是<code>checkpoint2</code>中呢？<code>InnoDB</code>规定，当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中。 </p></li></ul><p>记录完<code>checkpoint</code>的信息之后，<code>redo</code>日志文件组中各个<code>lsn</code>值的关系就像这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/IvyqOs.png" alt="img"></p><h2 id="1-批量从flush链表中刷出脏页"><a href="#1-批量从flush链表中刷出脏页" class="headerlink" title="1.批量从flush链表中刷出脏页"></a>1.批量从flush链表中刷出脏页</h2><p>一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统<code>lsn</code>值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘，这样这些脏页对应的<code>redo</code>日志就没用了，然后就可以去做<code>checkpoint</code>了。</p><h2 id="2-查看系统中的各种LSN值"><a href="#2-查看系统中的各种LSN值" class="headerlink" title="2.查看系统中的各种LSN值"></a>2.查看系统中的各种LSN值</h2><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前<code>InnoDB</code>存储引擎中的各种<code>LSN</code>值的情况，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to   124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at  124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">24 log i/o&#x27;s done, 2.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>Log sequence number</code>：代表系统中的<code>lsn</code>值，也就是当前系统已经写入的<code>redo</code>日志量，包括写入<code>log buffer</code>中的日志。</p></li><li><p><code>Log flushed up to</code>：代表<code>flushed_to_disk_lsn</code>的值，也就是当前系统已经写入磁盘的<code>redo</code>日志量。</p></li><li><p><code>Pages flushed up to</code>：代表<code>flush链表</code>中被最早修改的那个页面对应的<code>oldest_modification</code>属性值。</p></li><li><p><code>Last checkpoint at</code>：当前系统的<code>checkpoint_lsn</code>值。</p></li></ul><h2 id="3-innodb-flush-log-at-trx-commit的用法"><a href="#3-innodb-flush-log-at-trx-commit的用法" class="headerlink" title="3.innodb_flush_log_at_trx_commit的用法"></a>3.innodb_flush_log_at_trx_commit的用法</h2><p>为了保证事务的<code>持久性</code>，用户线程在事务提交时需要将该事务执行过程中产生的所有<code>redo</code>日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。如果对事务的<code>持久性</code>要求不是那么强烈的话，可以选择修改一个称为<code>innodb_flush_log_at_trx_commit</code>的系统变量的值，该变量有3个可选的值：</p><ul><li><p><code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志，这个任务是交给后台线程做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将<code>redo</code>日志刷新到磁盘，那么该事务对页面的修改会丢失。 </p></li><li><p> <code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘，可以保证事务的<code>持久性</code>。<code>1</code>也是<code>innodb_flush_log_at_trx_commit</code>的默认值。 </p></li><li><p><code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了。 </p></li></ul><h1 id="八，崩溃恢复"><a href="#八，崩溃恢复" class="headerlink" title="八，崩溃恢复"></a>八，崩溃恢复</h1><p>在服务器不挂的情况下，<code>redo</code>日志不仅没用，反而让性能变得更差。但是万一数据库挂了，我们就可以在重启时根据<code>redo</code>日志中的记录就可以将页面恢复到系统崩溃前的状态。我们接下来大致看一下恢复过程。</p><h2 id="1-确定恢复的起点"><a href="#1-确定恢复的起点" class="headerlink" title="1.确定恢复的起点"></a>1.确定恢复的起点</h2><p><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖，也就是说这些<code>redo</code>日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于<code>checkpoint_lsn</code>之后的<code>redo</code>日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从<code>checkpoint_lsn</code>开始读取<code>redo</code>日志来恢复页面。</p><p>当然，<code>redo</code>日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code>的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量<code>checkpoint</code>发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，只要把<code>checkpoint1</code>和<code>checkpoint2</code>这两个block中的<code>checkpoint_no</code>值读出来比一下大小，哪个的<code>checkpoint_no</code>值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code>信息。这样我们就能拿到最近发生的<code>checkpoint</code>对应的<code>checkpoint_lsn</code>值以及它在<code>redo</code>日志文件组中的偏移量<code>checkpoint_offset</code>。</p><h2 id="2-确定恢复的终点"><a href="#2-确定恢复的终点" class="headerlink" title="2.确定恢复的终点"></a>2.确定恢复的终点</h2><p><code>redo</code>日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。在写<code>redo</code>日志的时候都是顺序写的，写满了一个block之后会再往下一个block中写。</p><p>普通block的<code>log block header</code>部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为<code>512</code>。如果该属性的值不为<code>512</code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p><h2 id="3-怎么恢复"><a href="#3-怎么恢复" class="headerlink" title="3.怎么恢复"></a>3.怎么恢复</h2><p>确定了需要扫描哪些<code>redo</code>日志进行崩溃恢复之后，接下来就是怎么进行恢复了。假设现在的<code>redo</code>日志文件中有5条<code>redo</code>日志，如图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/zlN5rd.png" alt="img"></p><p>由于<code>redo 0</code>在<code>checkpoint_lsn</code>后前边，恢复时可以不管它。现在可以按照<code>redo</code>日志的顺序依次扫描<code>checkpoint_lsn</code>之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过<code>InnoDB</code>还是想了一些办法加快这个恢复的过程：</p><ul><li><p>使用哈希表<br>根据<code>redo</code>日志的<code>space ID</code>和<code>page number</code>属性计算出散列值，把<code>space ID</code>和<code>page number</code>相同的<code>redo</code>日志放到哈希表的同一个槽里，如果有多个<code>space ID</code>和<code>page number</code>都相同的<code>redo</code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/LG7sGs.png" alt="img"><br>之后就可以遍历哈希表，因为对同一个页面进行修改的<code>redo</code>日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO)，这样可以加快恢复速度。另外需要注意一点的是，同一个页面的<code>redo</code>日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复，如果不按照生成时间顺序进行排序的话，那么可能出现错误。比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。 </p></li><li><p>跳过已经刷新到磁盘的页面<br><code>checkpoint_lsn</code>之前的<code>redo</code>日志对应的脏页确定都已经刷到磁盘了，但是<code>checkpoint_lsn</code>之后的<code>redo</code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次<code>checkpoint</code>后，可能后台线程又不断的从<code>LRU链表</code>和<code>flush链表</code>中将一些脏页刷出<code>Buffer Pool</code>。这些在<code>checkpoint_lsn</code>之后的<code>redo</code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据<code>redo</code>日志的内容修改该页面了。<br>那在恢复时怎么知道某个<code>redo</code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，每个页面都有一个称之为<code>File Header</code>的部分，在<code>File Header</code>里有一个称之为<code>FIL_PAGE_LSN</code>的属性，该属性记载了最近一次修改页面时对应的<code>lsn</code>值（其实就是页面控制块中的<code>newest_modification</code>值）。如果在做了某次<code>checkpoint</code>之后有脏页被刷新到磁盘中，那么该页对应的<code>FIL_PAGE_LSN</code>代表的<code>lsn</code>值肯定大于<code>checkpoint_lsn</code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于<code>FIL_PAGE_LSN</code>的redo日志了，所以更进一步提升了崩溃恢复的速度。 </p></li></ul><h1 id="九，LOG-BLOCK-HDR-NO是如何计算的"><a href="#九，LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="九，LOG_BLOCK_HDR_NO是如何计算的"></a>九，LOG_BLOCK_HDR_NO是如何计算的</h1><p>对于实际存储<code>redo</code>日志的普通的<code>log block</code>来说，在<code>log block header</code>处有一个称之为<code>LOG_BLOCK_HDR_NO</code>的属性，我们说这个属性代表一个唯一的标号。这个属性是初次使用该block时分配的，跟当时的系统<code>lsn</code>值有关。使用下边的公式计算该block的<code>LOG_BLOCK_HDR_NO</code>值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/hYGejv.png" alt="img"></p><p>从图中可以看出，<code>0x3FFFFFFFUL</code>对应的二进制数的前2位为0，后30位的值都为<code>1</code>。一个二进制位与0做与运算（<code>&amp;</code>）的结果肯定是0，一个二进制位与1做与运算（<code>&amp;</code>）的结果就是原值。让一个数和<code>0x3FFFFFFFUL</code>做与运算的意思就是要将该值的前2个比特位的值置为0，这样该值就肯定小于或等于<code>0x3FFFFFFFUL</code>了。这也就说明了，不论lsn多大，<code>((lsn / 512) &amp; 0x3FFFFFFFUL)</code>的值肯定在<code>0``0x3FFFFFFFUL</code>之间，再加1的话肯定在<code>1``0x40000000UL</code>之间。而<code>0x40000000UL</code>这个值就代表着<code>1GB</code>。也就是说系统最多能产生不重复的<code>LOG_BLOCK_HDR_NO</code>值只有<code>1GB</code>个。InnoDB规定<code>redo</code>日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。</p><p>另外，<code>LOG_BLOCK_HDR_NO</code>值的第一个比特位比较特殊，称之为<code>flush bit</code>，如果该值为1，代表着本block是在某次将<code>log buffer</code>中的block刷新到磁盘的操作中的第一个被刷入的block。</p><h1 id="十，double-write"><a href="#十，double-write" class="headerlink" title="十，double write"></a>十，double write</h1><h2 id="1-脏页刷盘风险"><a href="#1-脏页刷盘风险" class="headerlink" title="1.脏页刷盘风险"></a>1.脏页刷盘风险</h2><p>关于IO的最小单位：</p><ol><li><p>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</p></li><li><p>文件系统IO的最小单位是4K（也有1K的）</p></li><li><p>磁盘IO的最小单位是512字节</p></li></ol><p>因此，存在IO写入导致page损坏的风险：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/8BiaPu.png" alt="img"> </p><h2 id="2-doublewrite：两次写"><a href="#2-doublewrite：两次写" class="headerlink" title="2.doublewrite：两次写"></a>2.doublewrite：两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p><h3 id="2-1-Double-write解决了什么问题"><a href="#2-1-Double-write解决了什么问题" class="headerlink" title="2.1 Double write解决了什么问题"></a>2.1 Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p><h3 id="2-2使用情景"><a href="#2-2使用情景" class="headerlink" title="2.2使用情景"></a>2.2使用情景</h3><p>当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p><h3 id="2-3-double-write工作流程"><a href="#2-3-double-write工作流程" class="headerlink" title="2.3 double write工作流程"></a>2.3 double write工作流程</h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/13kGkt.png" alt="img"></p><p>doublewrite由两部分组成，一部分为内存中的<code>doublewrite buffer</code>，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p><ol><li><ol><li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的<code>doublewrite buffer</code>中；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li></ol></li><li><ol><li>待第二步完成后，再将<code>doublewrite buffer</code>中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li></ol></li></ol><h3 id="2-4-doublewrite的崩溃恢复"><a href="#2-4-doublewrite的崩溃恢复" class="headerlink" title="2.4 doublewrite的崩溃恢复"></a>2.4 doublewrite的崩溃恢复</h3><p>如果操作系统在将页写入磁盘的过程中发生崩溃，在恢复过程中，<code>innodb</code>存储引擎可以从共享表空间的<code>doublewrite</code>中找到该页的一个最近的副本，将其复制到表空间文件，再应用<code>redo log</code>，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p><p><em>Q：为什么</em><code>*log write*</code><em>不需要</em><code>*doublewrite*</code><em>的支持？</em></p><p><em>A：因为</em><code>*redolog*</code><em>写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。</em></p><h2 id="3-doublewrite的副作用"><a href="#3-doublewrite的副作用" class="headerlink" title="3.doublewrite的副作用"></a>3.doublewrite的副作用</h2><h3 id="3-1-double-write带来的写负载"><a href="#3-1-double-write带来的写负载" class="headerlink" title="3.1 double write带来的写负载"></a>3.1 double write带来的写负载</h3><ol><li>double write是一个buffer, 但其实它是开在物理文件上的一个buffer, 其实也就是file, 所以它会导致系统有更多的fsync操作, 而硬盘的fsync性能是很慢的, 所以它会降低mysql的整体性能。</li><li>但是，doublewrite buffer写入磁盘共享表空间这个过程是连续存储，是顺序写，性能非常高，(约占写的10%)，牺牲一点写性能来保证数据页的完整还是很有必要的。</li></ol><h3 id="3-2-监控double-write工作负载"><a href="#3-2-监控double-write工作负载" class="headerlink" title="3.2 监控double write工作负载"></a>3.2 监控double write工作负载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">&#x27;%dblwr%&#x27;</span>;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Innodb_dblwr_pages_written | <span class="number">7</span>     |</span><br><span class="line">| Innodb_dblwr_writes        | <span class="number">3</span>     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>关注点：Innodb_dblwr_pages_written / Innodb_dblwr_writes</p><p>开启doublewrite后，每次脏页刷新必须要先写doublewrite，而doublewrite存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。</p><p>而根据以上系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，大概在3左右，远远还没到64(如果约等于64，那么说明系统的写压力非常大，有大量的脏页要往磁盘上写)，所以从这个角度也可以看出，系统写入压力并不高。</p><h3 id="3-3-关闭double-write适合的场景"><a href="#3-3-关闭double-write适合的场景" class="headerlink" title="3.3 关闭double write适合的场景"></a>3.3 关闭double write适合的场景</h3><ol><li><p>海量DML</p></li><li><p>不惧怕数据损坏和丢失</p></li><li><p>系统写负载成为主要负载</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;%double%&#x27;</span>;</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| innodb_doublewrite | ON    |</span><br><span class="line">+--------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>作为InnoDB的一个关键特性，doublewrite功能默认是开启的，但是在上述特殊的一些场景也可以视情况关闭，来提高数据库写性能。静态参数，配置文件修改，重启数据库。</p><h3 id="3-4-为什么没有把double-write里面的数据写到data-page里面呢？"><a href="#3-4-为什么没有把double-write里面的数据写到data-page里面呢？" class="headerlink" title="3.4 为什么没有把double write里面的数据写到data page里面呢？"></a>3.4 为什么没有把double write里面的数据写到data page里面呢？</h3><ol><li>double write里面的数据是连续的，如果直接写到data page里面，而data page的页又是离散的，写入会很慢。</li><li>double write里面的数据没有办法被及时的覆盖掉，导致double write的压力很大；短时间内可能会出现double write溢出的情况。</li></ol><h1 id="十一，总结"><a href="#十一，总结" class="headerlink" title="十一，总结"></a>十一，总结</h1><p>redo日志记录了事务执行过程中都修改了哪些内容。</p><p>事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘。这样做有两个好处：</p><ol><li>redo日志占用的空间非常小</li><li>redo日志是顺序写入磁盘的</li></ol><p>一条redo日志由下面几部分组成。</p><ol><li>type：这条redo日志的类型</li><li>space ID:表空间ID</li><li>page number :页号</li><li>data：这条redo日志的具体内容</li></ol><p>redo日志的类型有简单和复杂之分。简单类型的redo日志是纯粹的物理日志，复杂类型的redo日志兼有物理日志和逻辑日志的特性。</p><p>一个MTR可以包含一组redo日志。在进行崩溃恢复时，这一组redo日志作为一个不可分割的整体来处理。</p><p>redo日志存放在大小为512字节的block中。每一个block被分为3部分：</p><ol><li>log block header</li><li>log block body</li><li>log block trailer</li></ol><p>redo日志缓冲区是一片连续的内存空间，由若干个block组成；可以通过启动选项innodb_log_buffer_size 来调整他的大小。</p><p>redo日志文件组由若干个日志文件组成，这些redo日志文件是被循环使用的。redo日志文件组中每个文件的大小都一样，格式也一样，都是由两部分组成的：</p><ol><li>前2048字节用来存储一些管理信息</li><li>从第2048字节往后的字节用来存储log buffer中的block镜像</li></ol><p>lsn指已经写入的redo日志量，flushed_to_disk_lsn指刷新到磁盘中的redo日志量，flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的lsn值进行排序。被多次更新的页面不会重复插入到flush链表，但是会更新newest_modification属性的值。checkpoint_lsn表示当前系统中可以被覆盖的redo日志总量是多少。</p><p>redo日志占用的磁盘空间在他对应的脏页已经被刷新到磁盘后即可被覆盖。执行一次checkpoint的意思就是增加checkpoint_lsn的值，然后把相关信息放到日志文件的管理信息中。</p><p>innodb_flush_log_at_trx_commit系统变量控制着在事务提交时是否将该事务运行过程中产生的redo刷新到磁盘。</p><p>在崩溃恢复过程中，从redo日志文件组第一个文件的管理信息中取出最近发生的那次checkpoint信息，然后从checkpoint_lsn在日志文件组中对应的偏移量开始，一直扫描日志文件中的block，直到某个block的LOG_BLOCK_HDR_DATA_LEN值不等于512为止。再恢复过程中，使用hash表可加快恢复过程，并且会跳过已经刷新到磁盘的页面。</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undolog</title>
      <link href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/"/>
      <url>/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务回滚的需求"><a href="#1-事务回滚的需求" class="headerlink" title="1.事务回滚的需求"></a>1.事务回滚的需求</h2><p>我们说过<code>事务</code>需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：</p><ul><li><p>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</p></li><li><p>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前的事务的执行。</p></li></ul><p>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为<code>回滚</code>（英文名：<code>rollback</code>），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><p>每当我们要对一条记录做改动时（这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>），都需要留一手 —— 把回滚时所需的东西都给记下来。比方说：</p><ul><li><p>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</p></li><li><p>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</p></li><li><p>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</p></li></ul><p>数据库把这些为了回滚而记录的这些东西称之为撤销日志，英文名为<code>undo log</code>，我们也可以土洋结合，称之为<code>undo日志</code>。这里需要注意的一点是，由于查询操作（<code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的<code>undo日志</code>。在真实的<code>InnoDB</code>中，<code>undo日志</code>其实并不像我们上边所说的那么简单，不同类型的操作产生的<code>undo日志</code>的格式也是不同的，不过先暂时把这些具体细节放一放，我们先回过头来看看<code>事务id</code>。</p><h2 id="2-事务id"><a href="#2-事务id" class="headerlink" title="2.事务id"></a>2.事务id</h2><h3 id="2-1给事务分配id的时机"><a href="#2-1给事务分配id的时机" class="headerlink" title="2.1给事务分配id的时机"></a>2.1给事务分配id的时机</h3><p>一个事务可以是一个只读事务，或者是一个读写事务：</p><ul><li><p>我们可以通过<code>START TRANSACTION READ ONLY</code>语句开启一个只读事务。<br>在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。 </p></li><li><p>我们可以通过<code>START TRANSACTION READ WRITE</code>语句开启一个读写事务，或者使用<code>BEGIN</code>、<code>START TRANSACTION</code>语句开启的事务默认也算是读写事务。<br>在读写事务中可以对表执行增删改查操作。 </p></li></ul><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么<code>InnoDB</code>存储引擎就会给它分配一个独一无二的<code>事务id</code>，分配方式如下：</p><ul><li> 对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话是不分配<code>事务id</code>的。  </li></ul><p>对某个查询语句执行EXPLAIN分析它的查询计划时，有时候在Extra列会看到Using temporary的提示，这个表明在执行该查询语句时会用到内部临时表。这个所谓的内部临时表和我们手动用CREATE TEMPORARY TABLE创建的用户临时表并不一样，在事务回滚时并不需要把执行SELECT语句过程中用到的内部临时表也回滚，在执行SELECT语句用到内部临时表时并不会为它分配事务id。</p><ul><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话也是不分配<code>事务id</code>的。<br>有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个<code>事务id</code>。 </li></ul><p><strong>只有在事务对表中的记录做改动时才会为这个事务分配一个唯一的</strong><code>**事务id**</code><strong>。</strong></p><p>上边描述的事务id分配策略是针对MySQL 5.7来说的，前边的版本的分配方式可能不同。</p><h3 id="2-2事务id是怎么生成的"><a href="#2-2事务id是怎么生成的" class="headerlink" title="2.2事务id是怎么生成的"></a>2.2事务id是怎么生成的</h3><p>这个<code>事务id</code>本质上就是一个数字，它的分配策略和对隐藏列<code>row_id</code>（当用户没有为表创建主键和<code>UNIQUE</code>键时<code>InnoDB</code>自动创建的列）的分配策略大抵相同，具体策略如下：</p><ul><li><p>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个<code>事务id</code>时，就会把该变量的值当作<code>事务id</code>分配给该事务，并且把该变量自增1。</p></li><li><p>每当这个变量的值为<code>256</code>的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>5</code>的页面中一个称之为<code>Max Trx ID</code>的属性处，这个属性占用<code>8</code>个字节的存储空间。</p></li><li><p>当系统下一次重新启动时，会将上边提到的<code>Max Trx ID</code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Trx ID</code>属性值）。</p></li></ul><p>这样就可以保证整个系统中分配的<code>事务id</code>值是一个递增的数字。先被分配<code>id</code>的事务得到的是较小的<code>事务id</code>，后被分配<code>id</code>的事务得到的是较大的<code>事务id</code>。</p><h3 id="2-3trx-id隐藏列"><a href="#2-3trx-id隐藏列" class="headerlink" title="2.3trx_id隐藏列"></a>2.3trx_id隐藏列</h3><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。所以一条记录在页面中的真实结构看起来就是这样的：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/t1Mqs5.png" alt="image"></p><p>其中的<code>trx_id</code>列其实还蛮好理解的，就是某个对这个聚簇索引记录做改动的语句所在的事务对应的<code>事务id</code>而已（此处的改动可以是<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>操作）。至于<code>roll_pointer</code>隐藏列我们后边分析。</p><h2 id="3-undo日志的格式"><a href="#3-undo日志的格式" class="headerlink" title="3.undo日志的格式"></a>3.undo日志的格式</h2><p>为了实现事务的<code>原子性</code>，<code>InnoDB</code>存储引擎在实际进行增、删、改一条记录时，都需要先把对应的<code>undo日志</code>记下来。一般每对一条记录做一次改动，就对应着一条<code>undo日志</code>，但在某些更新记录的操作中，也可能会对应着2条<code>undo日志</code>。一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的<code>undo日志</code>，这些<code>undo日志</code>会被从<code>0</code>开始编号，也就是说根据生成的顺序分别被称为<code>第0号undo日志</code>、<code>第1号undo日志</code>、…、<code>第n号undo日志</code>等，这个编号也被称之为<code>undo no</code>。</p><p>这些<code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放<code>undo日志</code>的表空间，也就是所谓的<code>undo tablespace</code>中分配。先来看看不同操作都会产生什么样子的<code>undo日志</code>吧～我们先来创建一个名为<code>undo_demo</code>的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE undo_demo (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    col VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1)</span><br><span class="line">)Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>这个表中有3个列，其中<code>id</code>列是主键，我们为<code>key1</code>列建立了一个二级索引，<code>col</code>列是一个普通的列。每个表都会被分配一个唯一的<code>table id</code>，我们可以通过系统数据库<code>information_schema</code>中的<code>innodb_sys_tables</code>表来查看某个表对应的<code>table id</code>是什么，现在我们查看一下<code>undo_demo</code>对应的<code>table id</code>是多少：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#x27;yhd/undo_demo&#x27;;</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">| TABLE_ID | NAME                | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE | SPACE_TYPE |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">|      138 | yhd/undo_demo |   33 |      6 |   482 | Barracuda   | Dynamic    |             0 | Single     |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>从查询结果可以看出，<code>undo_demo</code>表对应的<code>table id</code>为<code>138</code>。</p><h3 id="3-1INSERT操作对应的undo日志"><a href="#3-1INSERT操作对应的undo日志" class="headerlink" title="3.1INSERT操作对应的undo日志"></a>3.1INSERT操作对应的undo日志</h3><p>当我们向表中插入一条记录时会有<code>乐观插入</code>和<code>悲观插入</code>的区分，但是不管怎么插入，最终导致的结果就是这条记录被放到了一个数据页中。如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的<code>undo</code>日志时，主要是把这条记录的主键信息记上。所以<code>InnoDB</code>设计了一个类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/qWMaKs.png" alt="img"></p><p>根据示意图我们强调几点：</p><ul><li><p><code>undo no</code>在一个事务中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。</p></li><li><p>如果记录中的主键只包含一个列，那么在类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的<code>len</code>就代表列占用的存储空间大小，<code>value</code>就代表列的真实值）。</p></li></ul><p>当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向聚簇索引插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后根据主键信息做对应的删除操作，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的。</p><p>现在我们向<code>undo_demo</code>中插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br></pre></td></tr></table></figure><p>因为记录的主键只包含一个<code>id</code>列，所以我们在对应的<code>undo日志</code>中只需要将待插入记录的<code>id</code>列占用的存储空间长度（<code>id</code>列的类型为<code>INT</code>，<code>INT</code>类型占用的存储空间长度为<code>4</code>个字节）和真实值记录下来。本例中插入了两条记录，所以会产生两条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>:</p><ul><li><p>第一条<code>undo日志</code>的<code>undo no</code>为<code>0</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>1</code>。画一个示意图就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/eWUSp2.png" alt="img"></p></li><li><p>第二条<code>undo日志</code>的<code>undo no</code>为<code>1</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>2</code>。画一个示意图就是这样（与第一条<code>undo日志</code>对比，<code>undo no</code>和主键各列信息有不同）：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/1m7QcK.png" alt="img"> </p></li></ul><p>为了最大限度的节省undo日志占用的存储空间，和我们前边说过的redo日志类似，InnoDB会给undo日志中的某些属性进行压缩处理。</p><h4 id="①roll-pointer隐藏列的含义"><a href="#①roll-pointer隐藏列的含义" class="headerlink" title="①roll_pointer隐藏列的含义"></a>①roll_pointer隐藏列的含义</h4><p><code>roll_pointer</code>本质上就是一个指向记录对应的<code>undo日志</code>的一个指针。比方说我们上边向<code>undo_demo</code>表里插入了2条记录，每条记录都有与其对应的一条<code>undo日志</code>。记录被存储到了类型为<code>FIL_PAGE_INDEX</code>的页面中（就是我们前边一直所说的<code>数据页</code>），<code>undo日志</code>被存放到了类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。效果如图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/OBcKdL.png" alt="img"></p><p><code>**roll_pointer**</code><strong>本质就是一个指针，指向记录对应的undo日志。</strong></p><h3 id="3-2-DELETE操作对应的undo日志"><a href="#3-2-DELETE操作对应的undo日志" class="headerlink" title="3.2 DELETE操作对应的undo日志"></a>3.2 DELETE操作对应的undo日志</h3><p>插入到页面中的记录会根据记录头信息中的<code>next_record</code>属性组成一个单向链表，我们把这个链表称之为<code>正常记录链表</code>；被删除的记录其实也会根据记录头信息中的<code>next_record</code>属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为<code>垃圾链表</code>。<code>Page Header</code>部分有一个称之为<code>PAGE_FREE</code>的属性，它指向由被删除记录组成的垃圾链表中的头节点。我们先画一个图，假设此刻某个页面中的记录分布情况是这样的（这个不是<code>undo_demo</code>表中的记录，只是我们随便举的一个例子）：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/A9CrRh.png" alt="img"></p><p>为了突出主题，在这个简化版的示意图中，我们只把记录的<code>delete_mask</code>标志位展示了出来。从图中可以看出，<code>正常记录链表</code>中包含了3条正常记录，<code>垃圾链表</code>里包含了2条已删除记录，在<code>垃圾链表</code>中的这些记录占用的存储空间可以被重新利用。页面的<code>Page Header</code>部分的<code>PAGE_FREE</code>属性的值代表指向<code>垃圾链表</code>头节点的指针。假设现在我们准备使用<code>DELETE</code>语句把<code>正常记录链表</code>中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：</p><ul><li>阶段一：仅仅将记录的<code>delete_mask</code>标识位设置为<code>1</code>，其他的不做修改（其实会修改记录的<code>trx_id</code>、<code>roll_pointer</code>这些隐藏列的值）。设计<code>InnoDB</code>的大叔把这个阶段称之为<code>delete mark</code>。<br>把这个过程画下来就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/6yPa60.png" alt="img"><br>可以看到，<code>正常记录链表</code>中的最后一条记录的<code>delete_mask</code>值被设置为<code>1</code>，但是并没有被加入到<code>垃圾链表</code>。也就是此时记录处于一个<code>中间状态</code>。在删除语句所在的事务提交之前，被删除的记录一直都处于这种所谓的<code>中间状态</code>。  </li></ul><p>为啥会有这种奇怪的中间状态呢？其实主要是为了实现一个称之为MVCC的功能。</p><ul><li>阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从<code>正常记录链表</code>中移除，并且加入到<code>垃圾链表</code>中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量<code>PAGE_N_RECS</code>、上次插入记录的位置<code>PAGE_LAST_INSERT</code>、垃圾链表头节点的指针<code>PAGE_FREE</code>、页面中可重用的字节数量<code>PAGE_GARBAGE</code>、还有页目录的一些信息等等。<code>InnoDB</code>把这个阶段称之为<code>purge</code>。<br>把<code>阶段二</code>执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。画下来就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/HvdH4n.png" alt="img"><br>将被删除记录加入到<code>垃圾链表</code>时，实际上加入到链表的头节点处，会跟着修改<code>PAGE_FREE</code>属性的值。 </li></ul><p>页面的Page Header部分有一个PAGE_GARBAGE属性，该属性记录着当前页面中可重用存储空间占用的总字节数。每当有已删除记录被加入到垃圾链表后，都会把这个PAGE_GARBAGE属性的值加上该已删除记录占用的存储空间大小。PAGE_FREE指向垃圾链表的头节点，之后每当新插入记录时，首先判断PAGE_FREE指向的头节点代表的已删除记录占用的存储空间是否足够容纳这条新插入的记录，如果不可以容纳，就直接向页面中申请新的空间来存储这条记录（并不会尝试遍历整个垃圾链表，找到一个可以容纳新记录的节点）。如果可以容纳，那么直接重用这条已删除记录的存储空间，并且把PAGE_FREE指向垃圾链表中的下一条已删除记录。但是这里有一个问题，如果新插入的那条记录占用的存储空间大小小于垃圾链表的头节点占用的存储空间大小，那就意味头节点对应的记录占用的存储空间里有一部分空间用不到，这部分空间就被称之为碎片空间。那这些碎片空间岂不是永远都用不到了么？其实也不是，这些碎片空间占用的存储空间大小会被统计到PAGE_GARBAGE属性中，这些碎片空间在整个页面快使用完前并不会被重新利用，不过当页面快满时，如果再插入一条记录，此时页面中并不能分配一条完整记录的空间，这时候会首先看一看PAGE_GARBAGE的空间和剩余可利用的空间加起来是不是可以容纳下这条记录，如果可以的话，InnoDB会尝试重新组织页内的记录，重新组织的过程就是先开辟一个临时页面，把页面内的记录依次插入一遍，因为依次插入时并不会产生碎片，之后再把临时页面的内容复制到本页面，这样就可以把那些碎片空间都解放出来（很显然重新组织页面内的记录比较耗费性能）。</p><p>从上边的描述中我们也可以看出来，在删除语句所在的事务提交之前，只会经历<code>阶段一</code>，也就是<code>delete mark</code>阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的<code>阶段一</code>做的影响进行回滚）。<code>InnoDB</code>为此设计了一种称之为<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/OUg54W.png" alt="img"></p><ul><li><p>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，就是我们图中显示的<code>old trx_id</code>和<code>old roll_pointer</code>属性。这样有一个好处，那就是可以通过<code>undo日志</code>的<code>old roll_pointer</code>找到记录在修改之前对应的<code>undo</code>日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/RMBnjn.png" alt="img"><br>从图中可以看出来，执行完<code>delete mark</code>操作后，它对应的<code>undo</code>日志和<code>INSERT</code>操作对应的<code>undo</code>日志就串成了一个链表。这个链表就称之为<code>版本链</code>。 </p></li><li><p> 与类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>不同，类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo</code>日志还多了一个<code>索引列各列信息</code>的内容，也就是说如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个<code>索引列各列信息</code>部分，所谓的相关信息包括该列在记录中的位置（用<code>pos</code>表示），该列占用的存储空间大小（用<code>len</code>表示），该列实际值（用<code>value</code>表示）。所以<code>索引列各列信息</code>存储的内容实质上就是<code>&lt;pos, len, value&gt;</code>的一个列表。这部分信息主要是用在事务提交后，对该<code>中间状态记录</code>做真正删除的阶段二，也就是<code>purge</code>阶段中使用的。 </p></li></ul><p>现在继续在上边那个事务id为<code>100</code>的事务中删除一条记录，比如我们把<code>id</code>为1的那条记录删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1;</span><br></pre></td></tr></table></figure><p>这个<code>delete mark</code>操作对应的<code>undo日志</code>的结构就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/b0pp8n.png" alt="img"></p><p>对照着这个图，我们得注意下边几点：</p><ul><li><p> 因为这条<code>undo</code>日志是<code>id</code>为<code>100</code>的事务中产生的第3条<code>undo</code>日志，所以它对应的<code>undo no</code>就是<code>2</code>。 </p></li><li><p> 在对记录做<code>delete mark</code>操作时，记录的<code>trx_id</code>隐藏列的值是<code>100</code>（也就是说对该记录最近的一次修改就发生在本事务中），所以把<code>100</code>填入<code>old trx_id</code>属性中。然后把记录的<code>roll_pointer</code>隐藏列的值取出来，填入<code>old roll_pointer</code>属性中，这样就可以通过<code>old roll_pointer</code>属性值找到最近一次对该记录做改动时产生的<code>undo日志</code>。 </p></li><li><p> 由于<code>undo_demo</code>表中有2个索引：一个是聚簇索引，一个是二级索引<code>idx_key1</code>。只要是包含在索引中的列，那么这个列在记录中的位置（<code>pos</code>），占用存储空间大小（<code>len</code>）和实际值（<code>value</code>）就需要存储到<code>undo日志</code>中。 </p></li><li><ul><li> 对于主键来说，只包含一个<code>id</code>列，存储到<code>undo日志</code>中的相关信息分别是： </li></ul></li><li><ul><li><ul><li><code>pos</code>：<code>id</code>列是主键，也就是在记录的第一个列，它对应的<code>pos</code>值为<code>0</code>。<code>pos</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>len</code>：<code>id</code>列的类型为<code>INT</code>，占用4个字节，所以<code>len</code>的值为<code>4</code>。<code>len</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>value</code>：在被删除的记录中<code>id</code>列的值为<code>1</code>，也就是<code>value</code>的值为<code>1</code>。<code>value</code>占用4个字节来存储。</li></ul></li></ul></li></ul><p>画一个图演示一下就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/wLTLBE.png" alt="img"><br>所以对于<code>id</code>列来说，最终存储的结果就是<code>&lt;0, 4, 1&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 4 = 6</code>个字节。 </p><ul><li><ul><li> 对于<code>idx_key1</code>来说，只包含一个<code>key1</code>列，存储到<code>undo日志</code>中的相关信息分别是： </li></ul></li><li><ul><li><ul><li><code>pos</code>：<code>key1</code>列是排在<code>id</code>列、<code>trx_id</code>列、<code>roll_pointer</code>列之后的，它对应的<code>pos</code>值为<code>3</code>。<code>pos</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>len</code>：<code>key1</code>列的类型为<code>VARCHAR(100)</code>，使用<code>utf8</code>字符集，被删除的记录实际存储的内容是<code>AWM</code>，所以一共占用3个字节，也就是所以<code>len</code>的值为<code>3</code>。<code>len</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>value</code>：在被删除的记录中<code>key1</code>列的值为<code>AWM</code>，也就是<code>value</code>的值为<code>AWM</code>。<code>value</code>占用3个字节来存储。</li></ul></li></ul></li></ul><p>画一个图演示一下就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/PntP80.png" alt="image.png"></p><p>所以对于<code>key1</code>列来说，最终存储的结果就是<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 3 = 5</code>个字节。<br>从上边的叙述中可以看到，<code>&lt;0, 4, 1&gt;</code>和<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>共占用<code>11</code>个字节。然后<code>index_col_info len</code>本身占用<code>2</code>个字节，所以加起来一共占用<code>13</code>个字节，把数字<code>13</code>就填到了<code>index_col_info len</code>的属性中。 </p><h3 id="3-3-UPDATE操作对应的undo日志"><a href="#3-3-UPDATE操作对应的undo日志" class="headerlink" title="3.3 UPDATE操作对应的undo日志"></a>3.3 UPDATE操作对应的undo日志</h3><p>在执行<code>UPDATE</code>语句时，<code>InnoDB</code>对更新主键和不更新主键这两种情况有截然不同的处理方案。</p><h4 id="①不更新主键的情况"><a href="#①不更新主键的情况" class="headerlink" title="①不更新主键的情况"></a>①不更新主键的情况</h4><p>在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。</p><ul><li><p>就地更新（in-place update）<br>更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>，也就是直接在原记录的基础上修改对应列的值。 </p></li><li><p>先删除掉旧记录，再插入新记录<br>在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。<br>注意，这里所说的<code>删除</code>并不是<code>delete mark</code>操作，而是真正的删除掉，也就是把这条记录从<code>正常记录链表</code>中移除并加入到<code>垃圾链表</code>中，并且修改页面中相应的统计信息（比如<code>PAGE_FREE</code>、<code>PAGE_GARBAGE</code>等这些信息）。不过这里做真正删除操作的线程并不是在<code>DELETE</code>语句中做<code>purge</code>操作时使用的另外专门的线程，而是由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。<br>这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到<code>垃圾链表</code>中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录。 </p></li></ul><p>针对<code>UPDATE</code>不更新主键的情况（包括上边所说的就地更新和先删除旧记录再插入新记录），InnoDB<code>设计了一种类型为</code>TRX_UNDO_UPD_EXIST_REC<code>的</code>undo日志`，它的完整结构如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/F0llIE.png" alt="img"></p><p>其实大部分属性和我们介绍过的<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>是类似的，不过还是要注意这么几点：</p><ul><li><p><code>n_updated</code>属性表示本条<code>UPDATE</code>语句执行后将有几个列被更新，后边跟着的<code>&lt;pos, old_len, old_value&gt;</code>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</p></li><li><p>如果在<code>UPDATE</code>语句中更新的列包含索引列，那么也会添加<code>索引列各列信息</code>这个部分，否则的话是不会添加这个部分的。</p></li></ul><p>现在继续在上边那个事务id为100的事务中更新一条记录，比如我们把id为2的那条记录更新一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1; </span><br><span class="line"></span><br><span class="line"># 更新一条记录</span><br><span class="line">UPDATE undo_demo</span><br><span class="line">    SET key1 = &#x27;M249&#x27;, col = &#x27;机枪&#x27;</span><br><span class="line">    WHERE id = 2;</span><br></pre></td></tr></table></figure><p>这个<code>UPDATE</code>语句更新的列大小都没有改动，所以可以采用<code>就地更新</code>的方式来执行，在真正改动页面记录时，会先记录一条类型为<code>TRX_UNDO_UPD_EXIST_REC</code>的<code>undo日志</code>，长这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/Yw0miI.png" alt="img"></p><p>对照着这个图我们注意一下这几个地方：</p><ul><li><p>因为这条<code>undo日志</code>是<code>id</code>为<code>100</code>的事务中产生的第4条<code>undo日志</code>，所以它对应的<code>undo no</code>就是3。</p></li><li><p>这条日志的<code>roll_pointer</code>指向<code>undo no</code>为<code>1</code>的那条日志，也就是插入主键值为<code>2</code>的记录时产生的那条<code>undo日志</code>，也就是最近一次对该记录做改动时产生的<code>undo日志</code>。</p></li><li><p>由于本条<code>UPDATE</code>语句中更新了索引列<code>key1</code>的值，所以需要记录一下<code>索引列各列信息</code>部分，也就是把主键和<code>key1</code>列更新前的信息填入。</p></li></ul><h4 id="②更新主键的情况"><a href="#②更新主键的情况" class="headerlink" title="②更新主键的情况"></a>②更新主键的情况</h4><p>在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变，比如你将记录的主键值从1更新为10000，如果还有非常多的记录的主键值分布在<code>1 ~ 10000</code>之间的话，那么这两条记录在聚簇索引中就有可能离得非常远，甚至中间隔了好多个页面。针对<code>UPDATE</code>语句中更新了记录主键值的这种情况，<code>InnoDB</code>在聚簇索引中分了两步处理：</p><ul><li>将旧记录进行<code>delete mark</code>操作<br>高能注意：这里是delete mark操作！这里是delete mark操作！这里是delete mark操作！也就是说在<code>UPDATE</code>语句所在的事务提交前，对旧记录只做一个<code>delete mark</code>操作，在事务提交后才由专门的线程做purge操作，把它加入到垃圾链表中。  </li></ul><p>之所以只对旧记录做delete mark操作，是因为别的事务同时也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的事务就访问不到了。这个功能就是所谓的MVCC。</p><ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。<br>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。 </li></ul><p>针对<code>UPDATE</code>语句更新记录主键值的这种情况，在对该记录进行<code>delete mark</code>操作前，会记录一条类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo日志</code>；之后插入新记录时，会记录一条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，也就是说每对一条记录的主键值做改动时，会记录2条<code>undo日志</code>。</p><h2 id="4-通用链表结构"><a href="#4-通用链表结构" class="headerlink" title="4.通用链表结构"></a>4.通用链表结构</h2><p>在写入<code>undo日志</code>的过程中会使用到多个链表，很多链表都有同样的节点结构，如图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/zJ8twY.png" alt="img"></p><p>在某个表空间内，我们可以通过一个页的页号和在页内的偏移量来唯一定位一个节点的位置，这两个信息也就相当于指向这个节点的一个指针。所以：</p><ul><li><p><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个节点的指针</p></li><li><p><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个节点的指针。</p></li></ul><p>整个<code>List Node</code>占用<code>12</code>个字节的存储空间。</p><p>为了更好的管理链表，<code>InnoDB</code>还提出了一个基节点的结构，里边存储了这个链表的<code>头节点</code>、<code>尾节点</code>以及链表长度信息，基节点的结构示意图如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/uyyeDy.png" alt="img"></p><p>其中：</p><ul><li><p><code>List Length</code>表明该链表一共有多少节点。</p></li><li><p><code>First Node Page Number</code>和<code>First Node Offset</code>的组合就是指向链表头节点的指针。</p></li><li><p><code>Last Node Page Number</code>和<code>Last Node Offset</code>的组合就是指向链表尾节点的指针。</p></li></ul><p>整个<code>List Base Node</code>占用<code>16</code>个字节的存储空间。</p><p>所以使用<code>List Base Node</code>和<code>List Node</code>这两个结构组成的链表的示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/AFw4Yb.png" alt="img"></p><h2 id="5-FIL-PAGE-UNDO-LOG页面"><a href="#5-FIL-PAGE-UNDO-LOG页面" class="headerlink" title="5.FIL_PAGE_UNDO_LOG页面"></a>5.FIL_PAGE_UNDO_LOG页面</h2><p>表空间其实是由许许多多的页面构成的，页面默认大小为<code>16KB</code>。这些页面有不同的类型，比如类型为<code>FIL_PAGE_INDEX</code>的页面用于存储聚簇索引以及二级索引，类型为<code>FIL_PAGE_TYPE_FSP_HDR</code>的页面用于存储表空间头部信息的，还有其他各种类型的页面，其中有一种称之为<code>FIL_PAGE_UNDO_LOG</code>类型的页面是专门用来存储<code>undo日志</code>的，这种类型的页面的通用结构如下图所示（以默认的<code>16KB</code>大小为例）：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/ttbEnF.png" alt="img"></p><p>我们就简称为<code>Undo页面</code>，上图中的<code>File Header</code>和<code>File Trailer</code>是各种页面都有的通用结构。<code>Undo Page Header</code>是<code>Undo页面</code>所特有的，我们来看一下它的结构：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/SRgzem.png" alt="img"></p><p>其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。<br>前边介绍了好几种类型的<code>undo日志</code>，它们可以被分为两个大类： </p></li><li><ul><li><code>TRX_UNDO_INSERT</code>（使用十进制<code>1</code>表示）：类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>属于此大类，一般由<code>INSERT</code>语句产生，或者在<code>UPDATE</code>语句中有更新主键的情况也会产生此类型的<code>undo日志</code>。</li></ul></li><li><ul><li><code>TRX_UNDO_UPDATE</code>（使用十进制<code>2</code>表示），除了类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>都属于这个大类，比如我们前边说的<code>TRX_UNDO_DEL_MARK_REC</code>、<code>TRX_UNDO_UPD_EXIST_REC</code>啥的，一般由<code>DELETE</code>、<code>UPDATE</code>语句产生的<code>undo日志</code>属于这个大类。</li></ul></li></ul><p>这个<code>TRX_UNDO_PAGE_TYPE</code>属性可选的值就是上边的两个，用来标记本页面用于存储哪个大类的<code>undo日志</code>，不同大类的<code>undo日志</code>不能混着存储，比如一个<code>Undo页面</code>的<code>TRX_UNDO_PAGE_TYPE</code>属性值为<code>TRX_UNDO_INSERT</code>，那么这个页面就只能存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>就不能放到这个页面中了。 </p><p>之所以把undo日志分成两个大类，是因为类型为TRX_UNDO_INSERT_REC的undo日志在事务提交后可以直接删除掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删除掉，对它们的处理需要区别对待。</p><ul><li><p> <code>TRX_UNDO_PAGE_START</code>：表示在当前页面中是从什么位置开始存储<code>undo日志</code>的，或者说表示第一条<code>undo日志</code>在本页面中的起始偏移量。 </p></li><li><p><code>TRX_UNDO_PAGE_FREE</code>：与上边的<code>TRX_UNDO_PAGE_START</code>对应，表示当前页面中存储的最后一条<code>undo</code>日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的<code>undo日志</code>。<br>假设现在向页面中写入了3条<code>undo日志</code>，那么<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的示意图就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/tIMNDG.png" alt="img"><br>当然，在最初一条<code>undo日志</code>也没写入的情况下，<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的值是相同的。 </p></li><li><p> <code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构（链表的普通节点，我们上边刚说的）。 </p></li></ul><h2 id="6-Undo页面链表"><a href="#6-Undo页面链表" class="headerlink" title="6.Undo页面链表"></a>6.Undo页面链表</h2><h3 id="6-1单个事务中的Undo页面链表"><a href="#6-1单个事务中的Undo页面链表" class="headerlink" title="6.1单个事务中的Undo页面链表"></a>6.1单个事务中的Undo页面链表</h3><p>因为一个事务可能包含多个语句，而且一个语句可能对若干条记录进行改动，而对每条记录进行改动前，都需要记录1条或2条的<code>undo日志</code>，所以在一个事务执行过程中可能产生很多<code>undo日志</code>，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上边介绍的<code>TRX_UNDO_PAGE_NODE</code>属性连成了链表：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/7mw8bz.png" alt="img"></p><p>我特意把链表中的第一个<code>Undo页面</code>给标了出来，称它为<code>first undo page</code>，其余的<code>Undo页面</code>称之为<code>normal undo page</code>，这是因为在<code>first undo page</code>中除了记录<code>Undo Page Header</code>之外，还会记录其他的一些管理信息。</p><p>在一个事务执行过程中，可能混着执行<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句，也就意味着会产生不同类型的<code>undo日志</code>。但是，同一个<code>Undo页面</code>要么只存储<code>TRX_UNDO_INSERT</code>大类的<code>undo日志</code>，要么只存储<code>TRX_UNDO_UPDATE</code>大类的<code>undo日志</code>，反正不能混着存，所以在一个事务执行过程中就可能需要2个<code>Undo页面</code>的链表，一个称之为<code>insert undo链表</code>，另一个称之为<code>update undo链表</code>，画个示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/OB9b2p.png" alt="img"></p><p>另外，<code>InnoDB</code>规定对普通表和临时表的记录改动时产生的<code>undo日志</code>要分别记录（我们稍后阐释为啥这么做），所以在一个事务中最多有4个以<code>Undo页面</code>为节点组成的链表：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/gn2kBz.png" alt="img"></p><p>当然，并不是在事务一开始就会为这个事务分配这4个链表，具体分配策略如下：</p><ul><li><p>刚刚开启事务时，一个<code>Undo页面</code>链表也不分配。</p></li><li><p>当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>普通表的insert undo链表</code>。</p></li><li><p>当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个<code>普通表的update undo链表</code>。</p></li><li><p>当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>临时表的insert undo链表</code>。</p></li><li><p>当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个<code>临时表的update undo链表</code>。</p></li></ul><p>总结一句就是：按需分配，啥时候需要啥时候再分配，不需要就不分配。</p><h3 id="6-2多个事务中的Undo页面链表"><a href="#6-2多个事务中的Undo页面链表" class="headerlink" title="6.2多个事务中的Undo页面链表"></a>6.2多个事务中的Undo页面链表</h3><p>为了尽可能提高<code>undo日志</code>的写入效率，不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中。比方说现在有事务<code>id</code>分别为<code>1</code>、<code>2</code>的两个事务，我们分别称之为<code>trx 1</code>和<code>trx 2</code>，假设在这两个事务执行过程中：</p><ul><li><p><code>trx 1</code>对普通表做了<code>DELETE</code>操作，对临时表做了<code>INSERT</code>和<code>UPDATE</code>操作。<br><code>InnoDB</code>会为<code>trx 1</code>分配3个链表，分别是： </p></li><li><ul><li>针对普通表的<code>update undo链表</code></li></ul></li><li><ul><li>针对临时表的<code>insert undo链表</code></li></ul></li><li><ul><li>针对临时表的<code>update undo链表</code>。</li></ul></li><li><p><code>trx 2</code>对普通表做了<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>操作，没有对临时表做改动。<br><code>InnoDB</code>会为<code>trx 2</code>分配2个链表，分别是： </p></li><li><ul><li>针对普通表的<code>insert undo链表</code></li></ul></li><li><ul><li>针对普通表的<code>update undo链表</code>。</li></ul></li></ul><p>综上所述，在<code>trx 1</code>和<code>trx 2</code>执行过程中，<code>InnoDB</code>共需为这两个事务分配5个<code>Undo页面</code>链表，画个图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/O665Sr.png" alt="img"></p><p>如果有更多的事务，那就意味着可能会产生更多的<code>Undo页面</code>链表。</p><h2 id="7-undo日志具体写入过程"><a href="#7-undo日志具体写入过程" class="headerlink" title="7.undo日志具体写入过程"></a>7.undo日志具体写入过程</h2><h3 id="7-1段（Segment）的概念"><a href="#7-1段（Segment）的概念" class="headerlink" title="7.1段（Segment）的概念"></a>7.1段（Segment）的概念</h3><p><code>段</code>是一个逻辑上的概念，本质上是由若干个零散页面和若干个完整的区组成的。比如一个<code>B+</code>树索引被划分成两个段，一个叶子节点段，一个非叶子节点段，这样叶子节点就可以被尽可能的存到一起，非叶子节点被尽可能的存到一起。每一个段对应一个<code>INODE Entry</code>结构，这个<code>INODE Entry</code>结构描述了这个段的各种信息，比如段的<code>ID</code>，段内的各种链表基节点，零散页面的页号有哪些等信息。我为了定位一个<code>INODE Entry</code>，<code>InnoDB</code>设计了一个<code>Segment Header</code>的结构：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/kp1B6d.png" alt="img"></p><p>整个<code>Segment Header</code>占用10个字节大小，各个属性的意思如下：</p><ul><li><p><code>Space ID of the INODE Entry</code>：<code>INODE Entry</code>结构所在的表空间ID。</p></li><li><p><code>Page Number of the INODE Entry</code>：<code>INODE Entry</code>结构所在的页面页号。</p></li><li><p><code>Byte Offset of the INODE Ent</code>：<code>INODE Entry</code>结构在该页面中的偏移量</p></li></ul><p>知道了表空间ID、页号、页内偏移量，就可以唯一定位一个<code>INODE Entry</code>的地址。</p><h3 id="7-2Undo-Log-Segment-Header"><a href="#7-2Undo-Log-Segment-Header" class="headerlink" title="7.2Undo Log Segment Header"></a>7.2Undo Log Segment Header</h3><p><code>InnoDB</code>规定，每一个<code>Undo页面</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。也就是说链表中的页面都是从这个段里边申请的，所以他们在<code>Undo页面</code>链表的第一个页面，也就是上边提到的<code>first undo page</code>中设计了一个称之为<code>Undo Log Segment Header</code>的部分，这个部分中包含了该链表对应的段的<code>segment header</code>信息以及其他的一些关于这个段的信息，所以<code>Undo</code>页面链表的第一个页面其实长这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/ir5E3d.png" alt="img"></p><p>可以看到这个<code>Undo</code>链表的第一个页面比普通页面多了个<code>Undo Log Segment Header</code>，我们来看一下它的结构：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/CxRuhe.png" alt="img"></p><p>其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_STATE</code>：本<code>Undo页面</code>链表处在什么状态。<br>一个<code>Undo Log Segment</code>可能处在的状态包括： </p></li><li><ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li></ul></li><li><ul><li><code>TRX_UNDO_CACHED</code>：被缓存的状态。处在该状态的<code>Undo页面</code>链表等待着之后被其他事务重用。</li></ul></li><li><ul><li><code>TRX_UNDO_TO_FREE</code>：对于<code>insert undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li></ul></li><li><ul><li><code>TRX_UNDO_TO_PURGE</code>：对于<code>update undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li></ul></li><li><ul><li><code>TRX_UNDO_PREPARED</code>：包含处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul></li><li><p> <code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。 </p></li><li><p> <code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息。 </p></li><li><p> <code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。 </p></li></ul><p><code>Undo页面</code>的<code>Undo Page Header</code>部分有一个12字节大小的<code>TRX_UNDO_PAGE_NODE</code>属性，这个属性代表一个<code>List Node</code>结构。每一个<code>Undo页面</code>都包含<code>Undo Page Header</code>结构，这些页面就可以通过这个属性连成一个链表。这个<code>TRX_UNDO_PAGE_LIST</code>属性代表着这个链表的基节点，当然这个基节点只存在于<code>Undo页面</code>链表的第一个页面，也就是<code>first undo page</code>中。</p><h3 id="7-3Undo-Log-Header"><a href="#7-3Undo-Log-Header" class="headerlink" title="7.3Undo Log Header"></a>7.3Undo Log Header</h3><p>一个事务在向<code>Undo页面</code>中写入<code>undo日志</code>时的方式是十分简单暴力的，就是直接往里怼，写完一条紧接着写另一条，各条<code>undo日志</code>之间是亲密无间的。写完一个<code>Undo页面</code>后，再从段里申请一个新页面，然后把这个页面插入到<code>Undo页面</code>链表中，继续往这个新申请的页面中写。<code>InnoDB</code>认为同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，比方说我们上边介绍的<code>trx 1</code>由于会分配3个<code>Undo页面</code>链表，也就会写入3个组的<code>undo日志</code>；<code>trx 2</code>由于会分配2个<code>Undo页面</code>链表，也就会写入2个组的<code>undo日志</code>。在每写入一组<code>undo日志</code>时，都会在这组<code>undo日志</code>前先记录一下关于这个组的一些属性，<code>InnoDB</code>把存储这些属性的地方称之为<code>Undo Log Header</code>。所以<code>Undo页面</code>链表的第一个页面在真正写入<code>undo日志</code>前，其实都会被填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，如图所示：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/hY5DWe.png" alt="img"></p><p>这个<code>Undo Log Header</code>具体的结构如下：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/gkq6RR.png" alt="img"></p><p>我们先大致看一下它们都是啥意思：</p><ul><li><p> <code>TRX_UNDO_TRX_ID</code>：生成本组<code>undo日志</code>的事务<code>id</code>。 </p></li><li><p> <code>TRX_UNDO_TRX_NO</code>：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。 </p></li><li><p> <code>TRX_UNDO_DEL_MARKS</code>：标记本组<code>undo</code>日志中是否包含由于<code>Delete mark</code>操作产生的<code>undo日志</code>。 </p></li><li><p> <code>TRX_UNDO_LOG_START</code>：表示本组<code>undo</code>日志中第一条<code>undo日志</code>的在页面中的偏移量。 </p></li><li><p> <code>TRX_UNDO_XID_EXISTS</code>：本组<code>undo日志</code>是否包含XID信息。 </p></li><li><p> <code>TRX_UNDO_DICT_TRANS</code>：标记本组<code>undo日志</code>是不是由DDL语句产生的。 </p></li><li><p> <code>TRX_UNDO_TABLE_ID</code>：如果<code>TRX_UNDO_DICT_TRANS</code>为真，那么本属性表示DDL语句操作的表的<code>table id</code>。 </p></li><li><p> <code>TRX_UNDO_NEXT_LOG</code>：下一组的<code>undo日志</code>在页面中开始的偏移量。 </p></li><li><p> <code>TRX_UNDO_PREV_LOG</code>：上一组的<code>undo日志</code>在页面中开始的偏移量。  </p></li></ul><p>一般来说一个Undo页面链表只存储一个事务执行过程中产生的一组undo日志，但是在某些情况下，可能会在一个事务提交之后，之后开启的事务重复利用这个Undo页面链表，这样就会导致一个Undo页面中可能存放多组Undo日志，TRX_UNDO_NEXT_LOG和TRX_UNDO_PREV_LOG就是用来标记下一组和上一组undo日志在页面中的偏移量的。</p><ul><li> <code>TRX_UNDO_HISTORY_NODE</code>：一个12字节的<code>List Node</code>结构，代表一个称之为<code>History</code>链表的节点。 </li></ul><h3 id="7-4小结"><a href="#7-4小结" class="headerlink" title="7.4小结"></a>7.4小结</h3><p>对于没有被重用的<code>Undo页面</code>链表来说，链表的第一个页面，也就是<code>first undo page</code>在真正写入<code>undo日志</code>前，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。对于其他的页面来说，也就是<code>normal undo page</code>在真正写入<code>undo日志</code>前，只会填充<code>Undo Page Header</code>。链表的<code>List Base Node</code>存放到<code>first undo page</code>的<code>Undo Log Segment Header</code>部分，<code>List Node</code>信息存放到每一个<code>Undo页面</code>的<code>undo Page Header</code>部分，所以画一个<code>Undo页面</code>链表的示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/pirUYb.png" alt="img"></p><h2 id="8-重用Undo页面"><a href="#8-重用Undo页面" class="headerlink" title="8.重用Undo页面"></a>8.重用Undo页面</h2><p>为了能提高并发执行的多个事务写入<code>undo日志</code>的性能，<code>InnoDB</code>决定为每个事务单独分配相应的<code>Undo页面</code>链表（最多可能单独分配4个链表）。但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，针对某个<code>Undo页面</code>链表只产生了非常少的<code>undo日志</code>，这些<code>undo日志</code>可能只占用一点存储空间，每开启一个事务就新创建一个<code>Undo页面</code>链表（虽然这个链表中只有一个页面）来存储这么一点<code>undo日志</code>岂不是太浪费了么？的确是挺浪费，于是<code>InnoDB</code>决定在事务提交后在某些情况下重用该事务的<code>Undo页面</code>链表。一个<code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li><p>该链表中只包含一个<code>Undo页面</code>。<br>如果一个事务执行过程中产生了非常多的<code>undo日志</code>，那么它可能申请非常多的页面加入到<code>Undo页面</code>链表中。在该事物提交后，如果将整个链表中的页面都重用，那就意味着即使新的事务并没有向该<code>Undo页面</code>链表中写入很多<code>undo日志</code>，那该链表中也得维护非常多的页面，那些用不到的页面也不能被别的事务所使用，这样就造成了另一种浪费。所以<code>InnoDB</code>规定，只有在<code>Undo页面</code>链表中只包含一个<code>Undo页面</code>时，该链表才可以被下一个事务所重用。 </p></li><li><p> 该<code>Undo页面</code>已经使用的空间小于整个页面空间的3/4。 </p></li></ul><p><code>Undo页面</code>链表按照存储的<code>undo日志</code>所属的大类可以被分为<code>insert undo链表</code>和<code>update undo链表</code>两种，这两种链表在被重用时的策略也是不同的，我们分别看一下：</p><ul><li>insert undo链表<br><code>insert undo链表</code>中只存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，这种类型的<code>undo日志</code>在事务提交之后就没用了，就可以被清除掉。所以在某个事务提交后，重用这个事务的<code>insert undo链表</code>（这个链表中只有一个页面）时，可以直接把之前事务写入的一组<code>undo日志</code>覆盖掉，从头开始写入新事务的一组<code>undo日志</code>，如下图所示：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/6auiKu.png" alt="img"><br>如图所示，假设有一个事务使用的<code>insert undo链表</code>，到事务提交时，只向<code>insert undo链表</code>中插入了3条<code>undo日志</code>，这个<code>insert undo链表</code>只申请了一个<code>Undo页面</code>。假设此刻该页面已使用的空间小于整个页面大小的3/4，那么下一个事务就可以重用这个<code>insert undo链表</code>（链表中只有一个页面)。假设此时有一个新事务重用了该<code>insert undo链表</code>，那么可以直接把旧的一组<code>undo日志</code>覆盖掉，写入一组新的<code>undo日志</code>。  </li></ul><p>在重用Undo页面链表写入新的一组undo日志时，不仅会写入新的Undo Log Header，还会适当调整Undo Page Header、Undo Log Segment Header、Undo Log Header中的一些属性，比如TRX_UNDO_PAGE_START、TRX_UNDO_PAGE_FREE等等。</p><ul><li>update undo链表<br>在一个事务提交后，它的<code>update undo链表</code>中的<code>undo日志</code>也不能立即删除掉（这些日志用于MVCC）。所以如果之后的事务想重用<code>update undo链表</code>时，就不能覆盖之前事务写入的<code>undo日志</code>。这样就相当于在同一个<code>Undo页面</code>中写入了多组的<code>undo日志</code>，效果看起来就是这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/ZBDWza.png" alt="img"> </li></ul><h2 id="9-回滚段"><a href="#9-回滚段" class="headerlink" title="9.回滚段"></a>9.回滚段</h2><h3 id="9-1回滚段的概念"><a href="#9-1回滚段的概念" class="headerlink" title="9.1回滚段的概念"></a>9.1回滚段的概念</h3><p>一个事务在执行过程中最多可以分配4个<code>Undo页面</code>链表，在同一时刻不同事务拥有的<code>Undo页面</code>链表是不一样的，所以在同一时刻系统里其实可以有许许多多个<code>Undo页面</code>链表存在。为了更好的管理这些链表，<code>InnoDB</code>又设计了一个称之为<code>Rollback Segment Header</code>的页面，在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，这些<code>页号</code>称之为<code>undo slot</code>。可以这样理解，每个<code>Undo页面</code>链表都相当于是一个班，这个链表的<code>first undo page</code>就相当于这个班的班长，找到了这个班的班长，就可以找到班里的其他同学（其他同学相当于<code>normal undo page</code>）。有时候学校需要向这些班级传达一下精神，就需要把班长都召集在会议室，这个<code>Rollback Segment Header</code>就相当于是一个会议室。</p><p>我们看一下这个称之为<code>Rollback Segment Header</code>的页面长啥样（以默认的16KB为例）：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/yP0tWZ.png" alt="img"></p><p><code>InnoDB</code>规定，每一个<code>Rollback Segment Header</code>页面都对应着一个段，这个段就称为<code>Rollback Segment</code>，翻译过来就是<code>回滚段</code>。与之前介绍的各种段不同的是，这个<code>Rollback Segment</code>里其实只有一个页面。</p><p>了解了<code>Rollback Segment</code>的含义之后，我们再来看看这个称之为<code>Rollback Segment Header</code>的页面的各个部分的含义都是啥意思：</p><ul><li><code>TRX_RSEG_MAX_SIZE</code>：本<code>Rollback Segment</code>中管理的所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和的最大值。换句话说，本<code>Rollback Segment</code>中所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和不能超过<code>TRX_RSEG_MAX_SIZE</code>代表的值。<br>该属性的值默认为无限大，也就是我们想写多少<code>Undo页面</code>都可以。  </li></ul><p>无限大其实也只是个夸张的说法，4个字节能表示最大的数也就是0xFFFFFFFF，但是0xFFFFFFFF这个数有特殊用途，所以实际上TRX_RSEG_MAX_SIZE的值为0xFFFFFFFE。</p><ul><li><p> <code>TRX_RSEG_HISTORY_SIZE</code>：<code>History</code>链表占用的页面数量。 </p></li><li><p> <code>TRX_RSEG_HISTORY</code>：<code>History</code>链表的基节点。 </p></li><li><p> <code>TRX_RSEG_FSEG_HEADER</code>：本<code>Rollback Segment</code>对应的10字节大小的<code>Segment Header</code>结构，通过它可以找到本段对应的<code>INODE Entry</code>。 </p></li><li><p><code>TRX_RSEG_UNDO_SLOTS</code>：各个<code>Undo页面</code>链表的<code>first undo page</code>的<code>页号</code>集合，也就是<code>undo slot</code>集合。<br>一个页号占用<code>4</code>个字节，对于<code>16KB</code>大小的页面来说，这个<code>TRX_RSEG_UNDO_SLOTS</code>部分共存储了<code>1024</code>个<code>undo slot</code>，所以共需<code>1024 × 4 = 4096</code>个字节。 </p></li></ul><h3 id="9-2-从回滚段中申请Undo页面链表"><a href="#9-2-从回滚段中申请Undo页面链表" class="headerlink" title="9.2 从回滚段中申请Undo页面链表"></a>9.2 从回滚段中申请Undo页面链表</h3><p>初始情况下，由于未向任何事务分配任何<code>Undo页面</code>链表，所以对于一个<code>Rollback Segment Header</code>页面来说，它的各个<code>undo slot</code>都被设置成了一个特殊的值：<code>FIL_NULL</code>（对应的十六进制就是<code>0xFFFFFFFF</code>），表示该<code>undo slot</code>不指向任何页面。</p><p>随着时间的流逝，开始有事务需要分配<code>Undo页面</code>链表了，就从回滚段的第一个<code>undo slot</code>开始，看看该<code>undo slot</code>的值是不是<code>FIL_NULL</code>：</p><ul><li><p>如果是<code>FIL_NULL</code>，那么在表空间中新创建一个段（也就是<code>Undo Log Segment</code>），然后从段里申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>，然后把该<code>undo slot</code>的值设置为刚刚申请的这个页面的页号，这样也就意味着这个<code>undo slot</code>被分配给了这个事务。</p></li><li><p>如果不是<code>FIL_NULL</code>，说明该<code>undo slot</code>已经指向了一个<code>undo链表</code>，也就是说这个<code>undo slot</code>已经被别的事务占用了，那就跳到下一个<code>undo slot</code>，判断该<code>undo slot</code>的值是不是<code>FIL_NULL</code>，重复上边的步骤。</p></li></ul><p>一个<code>Rollback Segment Header</code>页面中包含<code>1024</code>个<code>undo slot</code>，如果这<code>1024</code>个<code>undo slot</code>的值都不为<code>FIL_NULL</code>，这就意味着这<code>1024</code>个<code>undo slot</code>都已经被分配给了某个事务，此时由于新事务无法再获得新的<code>Undo页面</code>链表，就会回滚这个事务并且给用户报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Too many active concurrent transactions</span><br></pre></td></tr></table></figure><p>用户看到这个错误，可以选择重新执行这个事务（可能重新执行时有别的事务提交了，该事务就可以被分配<code>Undo页面</code>链表了）。</p><p>当一个事务提交时，它所占用的<code>undo slot</code>有两种命运：</p><ul><li><p>如果该<code>undo slot</code>指向的<code>Undo页面</code>链表符合被重用的条件（就是我们上边说的<code>Undo页面</code>链表只占用一个页面并且已使用空间小于整个页面的3/4）。<br>该<code>undo slot</code>就处于被缓存的状态，InnoDB<code>规定这时该</code>Undo页面<code>链表的</code>TRX_UNDO_STATE<code>属性（该属性在</code>first undo page<code>的</code>Undo Log Segment Header<code>部分）会被设置为</code>TRX_UNDO_CACHED<code>。 被缓存的</code>undo slot<code>都会被加入到一个链表，根据对应的</code>Undo页面`链表的类型不同，也会被加入到不同的链表： </p></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>undo slot</code>会被加入<code>insert undo cached链表</code>。</li></ul></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>undo slot</code>会被加入<code>update undo cached链表</code>。</li></ul></li></ul><p>一个回滚段就对应着上述两个<code>cached链表</code>，如果有新事务要分配<code>undo slot</code>时，先从对应的<code>cached链表</code>中找。如果没有被缓存的<code>undo slot</code>，才会到回滚段的<code>Rollback Segment Header</code>页面中再去找。 </p><ul><li><p> 如果该<code>undo slot</code>指向的<code>Undo页面</code>链表不符合被重用的条件，那么针对该<code>undo slot</code>对应的<code>Undo页面</code>链表类型不同，也会有不同的处理： </p></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_FREE</code>，之后该<code>Undo页面</code>链表对应的段会被释放掉（也就意味着段中的页面可以被挪作他用），然后把该<code>undo slot</code>的值设置为<code>FIL_NULL</code>。</li></ul></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_PRUGE</code>，则会将该<code>undo slot</code>的值设置为<code>FIL_NULL</code>，然后将本次事务写入的一组<code>undo</code>日志放到所谓的<code>History链表</code>中（需要注意的是，这里并不会将<code>Undo页面</code>链表对应的段给释放掉，因为这些<code>undo</code>日志还有用呢～）。</li></ul></li></ul><h3 id="9-3多个回滚段"><a href="#9-3多个回滚段" class="headerlink" title="9.3多个回滚段"></a>9.3多个回滚段</h3><p>一个事务执行过程中最多分配<code>4</code>个<code>Undo页面</code>链表，而一个回滚段里只有<code>1024</code>个<code>undo slot</code>，很显然<code>undo slot</code>的数量有点少。即使假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那<code>1024</code>个<code>undo slot</code>也只能支持<code>1024</code>个读写事务同时执行，再多了就崩溃了</p><p>在<code>InnoDB</code>的早期发展阶段的确只有一个回滚段，但是<code>InnoDB</code>后来意识到了这个问题，所以<code>InnoDB</code>一口气定义了<code>128</code>个回滚段，也就相当于有了<code>128 × 1024 = 131072</code>个<code>undo slot</code>。假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那么就可以同时支持<code>131072</code>个读写事务并发执行。</p><p>只读事务并不需要分配Undo页面链表，MySQL 5.7中所有刚开启的事务默认都是只读事务，只有在事务执行过程中对记录做了某些改动时才会被升级为读写事务。</p><p>每个回滚段都对应着一个<code>Rollback Segment Header</code>页面，有128个回滚段，自然就要有128个<code>Rollback Segment Header</code>页面，这些页面的地址需要找个地方存一下！于是<code>InnoDB</code>在系统表空间的第<code>5</code>号页面的某个区域包含了128个8字节大小的格子：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/NJIQgm.png" alt="img"></p><p>每个8字节的格子的构造就像这样：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/oOsYUY.png" alt="img"></p><p>如果所示，每个8字节的格子其实由两部分组成：</p><ul><li><p>4字节大小的<code>Space ID</code>，代表一个表空间的ID。</p></li><li><p>4字节大小的<code>Page number</code>，代表一个页号。</p></li></ul><p>也就是说每个8字节大小的<code>格子</code>相当于一个指针，指向某个表空间中的某个页面，这些页面就是<code>Rollback Segment Header</code>。这里需要注意的一点事，要定位一个<code>Rollback Segment Header</code>还需要知道对应的表空间ID，这也就意味着不同的回滚段可能分布在不同的表空间中。</p><p>所以通过上边的叙述我们可以大致清楚，在系统表空间的第<code>5</code>号页面中存储了128个<code>Rollback Segment Header</code>页面地址，每个<code>Rollback Segment Header</code>就相当于一个回滚段。在<code>Rollback Segment Header</code>页面中，又包含<code>1024</code>个<code>undo slot</code>，每个<code>undo slot</code>都对应一个<code>Undo页面</code>链表。我们画个示意图：</p><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/12/EJvfdp.png" alt="img"></p><h3 id="9-4回滚段的分类"><a href="#9-4回滚段的分类" class="headerlink" title="9.4回滚段的分类"></a>9.4回滚段的分类</h3><p>我们把这128个回滚段给编一下号，最开始的回滚段称之为<code>第0号回滚段</code>，之后依次递增，最后一个回滚段就称之为<code>第127号回滚段</code>。这128个回滚段可以被分成两大类：</p><ul><li><p>第<code>0</code>号、第<code>33～127</code>号回滚段属于一类。其中第<code>0</code>号回滚段必须在系统表空间中（就是说第<code>0</code>号回滚段对应的<code>Rollback Segment Header</code>页面必须在系统表空间中），第<code>33～127</code>号回滚段既可以在系统表空间中，也可以在自己配置的<code>undo</code>表空间中。<br>如果一个事务在执行过程中由于对普通表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。 </p></li><li><p>第<code>1～32</code>号回滚段属于一类。这些回滚段必须在临时表空间（对应着数据目录中的<code>ibtmp1</code>文件）中。<br>如果一个事务在执行过程中由于对临时表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。 </p></li></ul><p>也就是说如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段，再分别到这两个回滚段中分配对应的<code>undo slot</code>。</p><p>为啥要把针对普通表和临时表来划分不同种类的<code>回滚段</code>呢？这个还得从<code>Undo页面</code>本身说起，我们说<code>Undo页面</code>其实是类型为<code>FIL_PAGE_UNDO_LOG</code>的页面的简称，说到底它也是一个普通的页面。我们前边说过，在修改页面之前一定要先把对应的<code>redo日志</code>写上，这样在系统奔溃重启时才能恢复到奔溃前的状态。我们向<code>Undo页面</code>写入<code>undo日志</code>本身也是一个写页面的过程，<code>InnoDB</code>为此还设计了许多种<code>redo日志</code>的类型，比方说<code>MLOG_UNDO_HDR_CREATE</code>、<code>MLOG_UNDO_INSERT</code>、<code>MLOG_UNDO_INIT</code>等等等等，也就是说我们对<code>Undo页面</code>做的任何改动都会记录相应类型的<code>redo日志</code>。但是对于临时表来说，因为修改临时表而产生的<code>undo日志</code>只需要在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这些<code>undo</code>日志所在的页面，所以在写针对临时表的<code>Undo页面</code>时，并不需要记录相应的<code>redo日志</code>。总结一下针对普通表和临时表划分不同种类的<code>回滚段</code>的原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p><p>实际上在MySQL 5.7.21这个版本中，如果我们仅仅对普通表的记录做了改动，那么只会为该事务分配针对普通表的回滚段，不分配针对临时表的回滚段。但是如果我们仅仅对临时表的记录做了改动，那么既会为该事务分配针对普通表的回滚段，又会为其分配针对临时表的回滚段（不过分配了回滚段并不会立即分配undo slot，只有在真正需要Undo页面链表时才会去分配回滚段中的undo slot）。</p><h3 id="9-5为事务分配Undo页面链表详细过程"><a href="#9-5为事务分配Undo页面链表详细过程" class="headerlink" title="9.5为事务分配Undo页面链表详细过程"></a>9.5为事务分配Undo页面链表详细过程</h3><p>接下来以事务对普通表的记录做改动为例，梳理一下事务执行过程中分配<code>Undo页面</code>链表时的完整过程：</p><ul><li><p>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第<code>5</code>号页面中分配一个回滚段（其实就是获取一个<code>Rollback Segment Header</code>页面的地址）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。<br>使用<code>round-robin</code>（循环使用）方式来分配回滚段。比如当前事务分配了第<code>0</code>号回滚段，那么下一个事务就要分配第<code>33</code>号回滚段，下下个事务就要分配第<code>34</code>号回滚段，简单一点的说就是这些回滚段被轮着分配给不同的事务。 </p></li><li><p> 在分配到回滚段后，首先看一下这个回滚段的两个<code>cached链表</code>有没有已经缓存了的<code>undo slot</code>，比如如果事务做的是<code>INSERT</code>操作，就去回滚段对应的<code>insert undo cached链表</code>中看看有没有缓存的<code>undo slot</code>；如果事务做的是<code>DELETE</code>操作，就去回滚段对应的<code>update undo cached链表</code>中看看有没有缓存的<code>undo slot</code>。如果有缓存的<code>undo slot</code>，那么就把这个缓存的<code>undo slot</code>分配给该事务。 </p></li><li><p>如果没有缓存的<code>undo slot</code>可供分配，那么就要到<code>Rollback Segment Header</code>页面中找一个可用的<code>undo slot</code>分配给当前事务。<br>从<code>Rollback Segment Header</code>页面中分配可用的<code>undo slot</code>的方式我们上边也说过了，就是从第<code>0</code>个<code>undo slot</code>开始，如果该<code>undo slot</code>的值为<code>FIL_NULL</code>，意味着这个<code>undo slot</code>是空闲的，就把这个<code>undo slot</code>分配给当前事务，否则查看第<code>1</code>个<code>undo slot</code>是否满足条件，依次类推，直到最后一个<code>undo slot</code>。如果这<code>1024</code>个<code>undo slot</code>都没有值为<code>FIL_NULL</code>的情况，就直接报错（一般不会出现这种情况）。 </p></li><li><p> 找到可用的<code>undo slot</code>后，如果该<code>undo slot</code>是从<code>cached链表</code>中获取的，那么它对应的<code>Undo Log Segment</code>已经分配了，否则的话需要重新分配一个<code>Undo Log Segment</code>，然后从该<code>Undo Log Segment</code>中申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>。 </p></li><li><p> 然后事务就可以把<code>undo日志</code>写入到上边申请的<code>Undo页面</code>链表了！ </p></li></ul><p>对临时表的记录做改动的步骤和上述的一样。不过需要再次强调一次，如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段。并发执行的不同事务其实也可以被分配相同的回滚段，只要分配不同的undo slot就可以了。</p><h2 id="10-回滚段相关配置"><a href="#10-回滚段相关配置" class="headerlink" title="10.回滚段相关配置"></a>10.回滚段相关配置</h2><h3 id="10-1配置回滚段数量"><a href="#10-1配置回滚段数量" class="headerlink" title="10.1配置回滚段数量"></a>10.1配置回滚段数量</h3><p>系统中一共有<code>128</code>个回滚段，其实这只是默认值，我们可以通过启动参数<code>innodb_rollback_segments</code>来配置回滚段的数量，可配置的范围是<code>1~128</code>。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表的回滚段数量一直是<code>32</code>，也就是说：</p><ul><li><p>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>1</code>，那么只会有1个针对普通表的可用回滚段，但是仍然有32个针对临时表的可用回滚段。</p></li><li><p>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>2～33</code>之间的数，效果和将其设置为<code>1</code>是一样的。</p></li><li><p>如果我们把<code>innodb_rollback_segments</code>设置为大于<code>33</code>的数，那么针对普通表的可用回滚段数量就是该值减去32。</p></li></ul><h3 id="10-2-配置undo表空间"><a href="#10-2-配置undo表空间" class="headerlink" title="10.2 配置undo表空间"></a>10.2 配置undo表空间</h3><p>默认情况下，针对普通表设立的回滚段（第<code>0</code>号以及第<code>33~127</code>号回滚段）都是被分配到系统表空间的。其中的第<code>0</code>号回滚段是一直在系统表空间的，但是第<code>33~127</code>号回滚段可以通过配置放到自定义的<code>undo表空间</code>中。但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了。我们看一下相关启动参数：</p><ul><li><p> 通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录，如果没有指定该参数，则默认<code>undo表空间</code>所在的目录就是数据目录。 </p></li><li><p>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量。该参数的默认值为<code>0</code>，表明不创建任何<code>undo表空间</code>。<br>第<code>33~127</code>号回滚段可以平均分布到不同的<code>undo表空间</code>中。 </p></li></ul><p>如果我们在系统初始化的时候指定了创建了undo表空间，那么系统表空间中的第0号回滚段将处于不可用状态。</p><p>比如我们在系统初始化时指定的<code>innodb_rollback_segments</code>为<code>35</code>，<code>innodb_undo_tablespaces</code>为<code>2</code>，这样就会将第<code>33</code>、<code>34</code>号回滚段分别分布到一个<code>undo表空间</code>中。</p><p>设立<code>undo表空间</code>的一个好处就是在<code>undo表空间</code>中的文件大到一定程度时，可以自动的将该<code>undo表空间</code>截断（truncate）成一个小文件。而系统表空间的大小只能不断的增大，却不能截断。</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h2><p>为了保证事务的原子性设计，InnoDB引入了undo日志。undo日志记载了回滚一个段所需的必要内容。</p><p>在事务对表中的记录进行改动的时候，才会为这个事务分配一个唯一的ID。事务ID值是一个递增的数字。先被分配ID的事务得到的是较小的事务ID，后被分配ID的事务得到的是较大的事务ID。未被分配事务ID的事务ID默认是0。聚簇索引记录中有一个trx_id隐藏列，他代表对这个聚簇索引隐藏记录进行改动的语句所在的事务对应的事务ID。</p><p>InnoDB针对不同的场景设计了不同类型的undo日志。</p><p>类型为FIL_PAGE_UNDO_LOG的页面是专门用来存储undo日志的，简称为undo页面。</p><p>在一个事务执行过程中，最多分配四个undo页面链表：</p><ol><li><p>针对普通表的insert undo链表</p></li><li><p>针对普通表的update undo链表</p></li><li><p>针对临时表的insert undo链表</p></li><li><p>针对临时表的update undo链表</p></li></ol><p>只有在真正用到这些链表的时候才会去创建他们。</p><p>每个undo页面链表都对应一个undo log segment。undo页面链表的第一个页面中有一个名为undo log segment header 的部分，专门用来存储关于这个段的一些信息。</p><p>同一个事务向一个undo页面链表中写入的undo日志算是一个组，每个组都以一个undo log header部分开头。</p><p>一个undo页面链表如果可以被重用，需要符合两个条件：</p><ol><li><p>该链表只包含一个undo页面</p></li><li><p>该undo页面已经使用的空间小于整个页面空间的3/4</p></li></ol><p>每一个Rollback segmrnt header 页面都对应一个回滚段，每个回滚段包含1024个undo slot，一个undo slot代表一个undo页面链表的第一个页面的页号。目前，InnoDB最多支持128个回滚段，其中第0号，第33127号回滚段是针对普通表设计的，第132号回滚段是针对临时表设计的。</p><p>我们可以选择将undo日志记录到专门的undo表空间中，在undo表空间中的文件大到一定程度时，可以自动将该undo表空间截断为小文件。</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
