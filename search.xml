<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2022/01/12/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2022/01/12/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/LOQBWm.png" alt="tabAt"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="https://zhangxin66666.github.io/images/uPic/202201/11/rmZ04d.png" alt="concurrenthashmap扩容图解"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="https://zhangxin66666.github.io/images/uPic/202201/11/ky3qW7.png" alt="concurrenthashmap迁移高低位原理1"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/8iLYmL.png" alt="ffb2efa924944e02b25e97a2b90bf6f5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/Z4wQG3.png" alt="3914c7b94d2843b985ea10e5c23a04b0"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/vNlWfH.png" alt="e7e01e24e3e844c7b31c4d73da2fffed"><br>2)为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/0UPxr0.png" alt="db389ed8b874494ca1f5a8723e8a6973"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行页索引底层结构</title>
      <link href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先明确下什么是索引呢？假设我一张数据库的表存了10亿条数据，如果要查找出其中的10条数据，如果逐条遍历匹配的话，效率上肯定是无法容忍的。所以为了提高数据查询的效率，就需要对数据进行一些格式化的存储，来方便我们更快的查找，这就是索引。</p><p>索引其实是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】，为什么要有页呢？</p><p>如果我们在查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p><p>换句话讲，其实就是内存一次拉到磁盘的数据最少是16KB，内存写入磁盘的数据一次最少也是16KB。</p><p>上面解释清楚了索引和页，MySQL的InnoDB存储引擎是基于页来进行内存和磁盘的数据交互的。所以我们的数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。</p><p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/o9sjNL.png" alt="页行层级关系"></p><p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p><h1 id="一、行"><a href="#一、行" class="headerlink" title="一、行"></a>一、行</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p><h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><p>首先来看下，我们如何来指定行格式呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure><p>比如我们创建一张表来指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br></pre></td></tr></table></figure><h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/u1WZ5x.png" alt="行格式示意图"></p><h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>先来看额外的信息，其实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p><h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】</p><p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p><p>在Compact行格式中，会把所有的变长字段占用的真实长度全部逆序存储在记录的开头位置，形成一个变长字段长度列表。</p><p>比如我们刚才创建的那张表，我们来分析一下：</p><p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p><table><thead><tr><th>列名</th><th>储存内容</th><th>内容长度(十进制表示)</th><th>内容长度(十六进制表示)</th></tr></thead><tbody><tr><td>C1</td><td>‘aaaa’</td><td>4</td><td>0x04</td></tr><tr><td>C2</td><td>‘bbb’</td><td>3</td><td>0x03</td></tr><tr><td>C4</td><td>‘d’</td><td>1</td><td>0x01</td></tr></tbody></table><p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/GicNPe.png" alt="行记录demo"></p><p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p><p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p><p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p><p>【L】：真实占用的字节数</p><ol><li><ol><li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li></ol><p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p></li><li><p>如果M*W&gt;=255,这个时候再次分为两种情况： </p></li><li><ol><li>如果L&lt;=127，那就用1个字节表示</li><li>否则就用2个字节表示</li></ol></li></ol><p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p><p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p><p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p><p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p><p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p><h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p><p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p><p>看一下处理过程：</p><ol><li>首先统计出表中允许存储NULL的字段</li><li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li><li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li></ol><p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p><p>这个时候再来看我们上面创建的表中的记录。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/Ar1SSA.png" alt="行记录null值列"></p><h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/DkHw2Y.png" alt="记录头信息"></p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p><p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p><p>在完善下我们开头创建的那张表的记录形象。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/hrhU7z.png" alt="行真实数据"></p><p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p><h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p><p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p><p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p><h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p><h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p><p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p><ol><li>真实数据</li><li>真实数据占用的字节长度</li><li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li></ol><p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p><p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p><h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/Lx6rk0.png" alt="行溢出1"></p><p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/9Nx5jA.png" alt="行溢出2"></p><p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p><h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p><p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p><p>分析一下页空间是如何利用的</p><ol><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：</li></ol><table><thead><tr><th>内容</th><th>大小(字节)</th></tr></thead><tbody><tr><td>真实数据的长度</td><td>2</td></tr><tr><td>列是否是NULL值</td><td>1</td></tr><tr><td>头信息</td><td>5</td></tr><tr><td>row_id</td><td>6</td></tr><tr><td>transaction_id</td><td>6</td></tr><tr><td>roll_pointer</td><td>7</td></tr></tbody></table><p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p><h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/uUTNzw.png" alt="行格式"></p><p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p><h1 id="二、页"><a href="#二、页" class="headerlink" title="二、页"></a>二、页</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p><p>本节分析存放表中记录的页，官方称为索引页，为了分析方便，我们暂且叫做数据页。</p><p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p><p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/wGkd2K.png" alt="页1"></p><p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页专有的一些信息</td></tr><tr><td>Infifmum + Supremum</td><td>最小记录和最大记录</td><td>26</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/bHvkJU.png" alt="页2"></p><p>再次回顾下记录头中5个字节表示的数据。</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>针对当前这个表的行格式简化图：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/GRkUos.png" alt="页3"></p><p>接下来我们往表中插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/iHTjzS.png" alt="页4"></p><p>分析一下头信息中的每个属性是什么意思。</p><h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p><p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p><p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p><h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p><h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p><p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p><p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p><p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/4PMBmm.png" alt="页5"></p><p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/XJNMeJ.png" alt="页6"></p><p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p><h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p><p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p><h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/EF4CbT.png" alt="页7"></p><p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>删除第二条记录以后：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/bDrm6E.png" alt="页8"></p><p>发生的变化：</p><ul><li><p>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</p></li><li><p>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</p></li><li><p>第一条记录的next record指向了第三条记录</p></li><li><p>最大记录的 n_owned 值从5 变成了4</p></li></ul><p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p><p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p><p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p><p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/zGw6Ie.png" alt="页9"></p><p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p><h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol><li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li><li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li><li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li></ol><p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/rHTXYE.png" alt="页10"></p><p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p><p>注意最大和最小记录的头信息的n_owned属性：</p><ol><li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li><li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li></ol><p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/D4ieuJ.png" alt="页11"></p><p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。所以分组是按照下边的步骤进行的：</p><ul><li><p> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </p></li><li><p> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </p></li><li><p> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </p></li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/M7MnRG.png" alt="页12"></p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol><h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p><p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p><h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p><p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p><ol><li><p>前四个字节代表校验和</p></li><li><p>后四个字节代表页面被最后修改时对应的日志序列位置</p></li></ol><p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p><p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p><h1 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h1><h2 id="1-索引结构"><a href="#1-索引结构" class="headerlink" title="1.索引结构"></a>1.索引结构</h2><h3 id="1-1-聚簇索引"><a href="#1-1-聚簇索引" class="headerlink" title="1.1 聚簇索引"></a>1.1 聚簇索引</h3><p>上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p><p>页内的记录是按照主键的大小顺序排成一个单向链表。</p><p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p><p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p></li></ol><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。另外，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/j76g6u.png" alt="聚簇索引"></p><h3 id="1-2-二级索引"><a href="#1-2-二级索引" class="headerlink" title="1.2 二级索引"></a>1.2 二级索引</h3><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p><p>我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/pup6Oo.png" alt="二级索引"></p><p>这个B+树与上边介绍的聚簇索引有几处不同：</p><ol><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义： </p><p>a页内的记录是按照c2列的大小顺序排成一个单向链表。</p><p>b各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。</p><p>c存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。</p></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。 </p></li><li><p>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。 </p></li></ol><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为4的记录为例，查找过程如下：</p><p>1确定目录项记录页</p><p>根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 &lt; 4 &lt; 9）。</p><p>2通过目录项记录页确定用户记录真实所在的页。</p><p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页34和页35中。</p><p>3在真实存储用户记录的页中定位到具体的记录.</p><p>到页34和页35中定位到具体的记录。</p><p>4但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程也被称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！！！</p><p>为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不就好了么？</p><p>如果把完整的用户记录放到叶子节点是可以不用回表，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为为c2列建立的索引。</p><p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p><p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p><h3 id="1-3-联合索引"><a href="#1-3-联合索引" class="headerlink" title="1.3 联合索引"></a>1.3 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p><p>●先把各个记录和页按照c2列进行排序。</p><p>●在记录的c2列相同的情况下，采用c3列进行排序</p><p>为c2和c3列建立的索引的示意图如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/h5xwiY.png" alt="联合索引"></p><h1 id="四、总结：一次通过聚簇索引定位数据的过程"><a href="#四、总结：一次通过聚簇索引定位数据的过程" class="headerlink" title="四、总结：一次通过聚簇索引定位数据的过程"></a>四、总结：一次通过聚簇索引定位数据的过程</h1><p>大家熟悉的三个版本索引结构图如下</p><p>普通索引</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/cCfg6Z.png" alt="总结1"></p><p>二级索引</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/qwXHhA.png" alt="总结2"></p><p>组合索引索引</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/MiAzWo.png" alt="总结3"></p><p>相对完整些的三种索引结构见（三、索引）</p><p>下图为聚簇索引完整版结构</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/gfMbZY.png" alt="聚簇索引数据结构完整版"></p><p>一次按照主键id查询id=5的数据的全流程</p><p>1.确定目录项记录页，找到页50</p><p>2.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页55</p><p>3.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页61</p><p>4.二分查找确定所属槽位2，然后遍历槽位2里的链表得到id为4的数据</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACID及实现原理</title>
      <link href="/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ACID简介"><a href="#ACID简介" class="headerlink" title="ACID简介"></a>ACID简介</h1><p>以最常见的 InnoDB 引擎来说，是如何保证 ACID 的。</p><ul><li>（Atomicity）原子性： 事务是最小的执行单位，不允许分割。要么全都执行,要么全都不执行；</li><li>（Consistency）一致性： 执行事务前后，数据保持一致，（原子性、隔离性、持久性就是为了来保证一致性）；</li><li>（Isolation）隔离性： 并发访问数据库时，一个事务不被其他事务所干扰，数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行；</li><li>（Durability）持久性: 一个事务被提交之后。对数据库中数据的改变是持久的，即使数据库发生故障也不会受到影响。</li></ul><h1 id="原子性（A）"><a href="#原子性（A）" class="headerlink" title="原子性（A）"></a>原子性（A）</h1><p>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句（<strong>undo log</strong>）。<br>当事务对数据库进行修改时，InnoDB会生成对应的 undo log；如果事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。<br>undo log 属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB 会根据 undo log 的内容做与之前相反的工作：</p><ul><li>对于每个 insert，回滚时会执行 delete；</li><li>对于每个 delete，回滚时会执行insert；</li><li>对于每个 update，回滚时会执行一个相反的 update，把数据改回去。</li></ul><h1 id="隔离性（I）"><a href="#隔离性（I）" class="headerlink" title="隔离性（I）"></a>隔离性（I）</h1><p>首先回忆四种mysql隔离级别</p><table><thead><tr><th align="left">隔离级别</th><th>说明</th></tr></thead><tbody><tr><td align="left">读未提交（Read uncommitted）</td><td>一个事务还没提交时，它做的变更就能被别的事务看到</td></tr><tr><td align="left">读提交（Read committed）</td><td>一个事务提交之后，它做的变更才会被其他事务看到。出 于性能考虑互联网公司会使用RC+乐观锁</td></tr><tr><td align="left">可重复读（Repeatable read）</td><td>一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。<strong>InnoDB默认级别</strong>。</td></tr><tr><td align="left">串行化（Serializable ）</td><td>事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，隔离级别最高，牺牲系统并发性。</td></tr></tbody></table><p>查看当前数据库的事务隔离级别:show variables like ‘%tx_isolation%’;</p><p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p><p>不同的隔离级别是为了解决不同的问题。也就是脏读、幻读、不可重复读。</p><h2 id="脏读、不可重复读、幻读区别"><a href="#脏读、不可重复读、幻读区别" class="headerlink" title="脏读、不可重复读、幻读区别"></a>脏读、不可重复读、幻读区别</h2><p>脏读：事务A读取到了事务B已经修改但尚未提交的数据，。</p><p>不可重复读：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。</p><p>幻读：事务A读取到了事务B提交的新增数据，不符合隔离性</p><p>不可重复读&amp;&amp;幻读区别</p><p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p><p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>读未提交</td><td>可以出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>读提交</td><td>不允许出现</td><td>可以出现</td><td>可以出现</td></tr><tr><td>可重复读</td><td>不允许出现</td><td>不允许出现</td><td>可以出现</td></tr><tr><td>序列化</td><td>不允许出现</td><td>不允许出现</td><td>不允许出现</td></tr></tbody></table><p><strong>不同的隔离级别下，隔离性是靠锁机制和MVCC共同实现的。</strong></p><h2 id="MVCC-并发多版本控制，Multi-Version-Concurrency-Control"><a href="#MVCC-并发多版本控制，Multi-Version-Concurrency-Control" class="headerlink" title="MVCC(并发多版本控制，Multi-Version Concurrency Control)"></a>MVCC(并发多版本控制，Multi-Version Concurrency Control)</h2><p><strong>MVCC用于读已提交（RC）和可重复读级别（RR）的控制，主要通过undo log日志版本链和read view来实现，</strong></p><p>InnoDB中MVCC的实现依赖四个条件: 隐藏字段, 事务链表，read view, undo log</p><hr><h3 id="数据表额外字段"><a href="#数据表额外字段" class="headerlink" title="数据表额外字段"></a>数据表额外字段</h3><p><strong>DB_TRX_ID(6字节)</strong>: 在innoDB中, 会为每个事物分配一个事务ID. 而该字段表示的就是插入或更新该行的最后一个事务的事务标识符.</p><p><strong>DB_ROLL_PTR(7字节)</strong>: 这个字段称为回滚指针, 指向了回滚段的撤销日志. (undo log)</p><p><strong>DB_ROW_ID(6字节)</strong>:  这个字段包含了一个行ID. 该ID在插入新行时会单调增加. 这个字段是为了在表里没有主键ID的时候, 生成聚簇索引使用的.</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/eGhZfg.png" alt="聚簇索引行结构"></p><hr><h3 id="事务链表"><a href="#事务链表" class="headerlink" title="事务链表"></a>事务链表</h3><p>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的事务链表中，基本的链表结构如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/IzCak0.png" alt="事务链表"></p><p>事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除。</p><hr><h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><p><strong>RC级别下每次都是重新生成read view，而在RR级别下则是一直使用事务内第一次查询时产生的read view。</strong></p><p>ReadView可以理解为一个数据结构，在事务开始的时候会根据上面的事务链表构造一个ReadView,初始化方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// readview 初始化</span><br><span class="line">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span><br><span class="line">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::memset(&amp;m_view_list, 0x0, sizeof(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>trx_ids</code>: 表示事务开启的时候, 其它未提交的活跃的事务ID. 这个集合中的事务对于当前事务来说, 一直都是不可见的.</p><p><code>low_limit_id</code>: 表示在生成ReadView时当前系统中最大事务id.</p><p><code>up_limit_id</code>: 表示未提交活跃事务Id(trx_ids)的最大值. 如果trx_ids为空, 则up_limit_id=low_limit_id.</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/bC4Qyv.png" alt="readview"></p><p>通过该ReadView，新的事务可以根据查询到的所有活跃事务记录的事务ID来匹配能够看见该记录，从而实现数据库的事务隔离，主要逻辑如下：</p><p>通过聚簇索引的行结构中DB_TRX_ID隐藏字段可以知道最近被哪个事务ID修改过。一个新的事务开始时会根据事务链表构造一个ReadView。当前事务根据ReadView中的数据去跟检索到的每一条数据去校验,看看当前事务是不是能看到这条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 判断数据对应的聚簇索引中的事务id在这个readview中是否可见</span><br><span class="line">bool changes_visible(</span><br><span class="line">        trx_id_t        id, // 记录的id</span><br><span class="line">    const table_name_t&amp; name) const</span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id &gt; 0);</span><br><span class="line">    // 如果当前记录id &lt; 事务链表的最小值或者等于创建该readview的id就是它自己,那么是可见的</span><br><span class="line">    if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    // 如果该记录的事务id大于事务链表中的最大值,那么不可见</span><br><span class="line">    if (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">        return(false);</span><br><span class="line">        // 如果事务链表是空的,那也是可见的</span><br><span class="line">    &#125; else if (m_ids.empty()) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ids_t::value_type*    p = m_ids.data();</span><br><span class="line"></span><br><span class="line">    //判断是否在ReadView中，如果在说明在创建ReadView时 此条记录还处于活跃状态则不应该查询到，否则说明创建ReadView是此条记录已经是不活跃状态则可以查询到</span><br><span class="line">    return(!std::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见性算法逻辑总结：</p><ol><li>当检索到的数据的事务ID小于事务链表中的最小值(数据行的DB_TRX_ID &lt; m_up_limit_id)表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li><li>当检索到的数据的事务ID表示的是当前事务自己修改的数据(数据行的DB_TRX_ID = m_creator_trx_id) 时，数据可见。</li><li>当检索到的数据的事务ID大于事务链表中的最大值(数据行的DB_TRX_ID &gt;= m_low_limit_id) 表示这个数据在当前事务开启后到下一次查询之间又被其他的事务修改过,那么就是不可见的。</li><li>如果事务链表为空,那么也是可见的,也就是当前事务开始的时候,没有其他任意一个事务在执行。</li><li>当检索到的数据的事务ID在事务链表中的最小值和最大值之间，从m_low_limit_id到m_up_limit_id进行遍历，取出DB_ROLL_PTR指针所指向的回滚段的事务ID，把它赋值给 trx_id_current ，然后从步骤1重新开始判断，这样总能最后找到一个可用的记录。</li></ol><hr><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生Undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</p><p>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。</p><p><strong>Undo Log 格式</strong></p><p>在InnoDB引擎中，undo log分为：</p><p><strong>insert undo log</strong>：</p><p>insert undo log是指在insert操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><p><strong>update undo log</strong>：</p><p>update undo log记录的是delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入undo log链表，等待purge线程进行最后的删除。下面是两种undo log的结构图。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/BtJgA9.png" alt="undolog"></p><h3 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h3><p>对于一条delete语句 delete from t where a = 1，如果列a有聚集索引，则不会进行真正的删除，而只是在主键列等于1的记录delete flag设置为1，即记录还是存在在B+树中。而对于update操作，不是直接对记录进行更新，而是标识旧记录为删除状态，然后新产生一条记录。那这些旧版本标识位删除的记录何时真正的删除？怎么删除？</p><p>其实InnoDB是通过undo日志来进行旧版本的删除操作的，在InnoDB内部，这个操作被称之为purge操作，原来在srv_master_thread主线程中完成，后来进行优化，开辟了purge线程进行purge操作，并且可以设置purge线程的数量。purge操作每10s进行一次。</p><p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行连接，如下面的一种情况：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/Zxv9V3.png" alt="purge"></p><p>在执行purge过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1所在的Undo page中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故再去history list中取查找，发现最尾端的记录时trx2，接着找到trx2所在的Undo page，依次把trx6、trx4清理，由于Undo page2中所有的记录都被清理了，因此该Undo page可以进行重用。</p><p>InnoDB存储引擎这种先从history list中找undo log，然后再从Undo page中找undo log的设计模式是为了避免大量随机读操作，从而提高purge的效率。</p><hr><h3 id="快照读与当前读的区别"><a href="#快照读与当前读的区别" class="headerlink" title="快照读与当前读的区别"></a>快照读与当前读的区别</h3><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><p><strong>快照读</strong>：就是select</p><ul><li>select * from table ….;</li></ul><p><strong>当前读</strong>：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert;</li><li>update ;</li><li>delete;</li></ul><hr><h2 id="场景举例："><a href="#场景举例：" class="headerlink" title="场景举例："></a>场景举例：</h2><p>新建一张数据表user，后续所有操作都依托于初始化的这三条数据。</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr></tbody></table><hr><p>操作1：</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td></td><td>update user set name=’zhangsan2’ where age=1;<br>commit;</td></tr><tr><td>3</td><td>select * from user where age=1;</td><td></td></tr></tbody></table><p>此时不管是RC还是RR，t1的select都能够读取到t2update的值</p><p>因为在t1select的时刻才会去生成read view，根据可见性算法得出能看到最新的t2数据</p><hr><p>操作2:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td>2</td><td>select * from user where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>update user set name=’zhangsan2’ where age=1;<br/>commit;</td></tr><tr><td>4</td><td>select * from user where age=1;</td><td></td></tr></tbody></table><p>此时RC级别下，t1的 第二次select能够查看到t2update的值，因为RC级别下每次select都会生成新的read view</p><p>在RR级别下，t1的 第二次不能查询到t2update的值，因为RR级别下的后面查询都是使用的第一次select生成的read view</p><p>同理，t2语句为insert时也是一样的情况。</p><hr><p>操作3:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td></td><td>update user set name=’zhangsan2’ where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>insert into user values (4,’haha’,3);<br/>waiting~~~</td></tr><tr><td>5</td><td>commit;</td><td></td></tr><tr><td>6</td><td></td><td>插入成功<br>commit;</td></tr></tbody></table><p>RR级别下，t1进行当前读时，会对数据加锁，具体是间隙锁｜行锁｜next-key，后面细说，此时t2的插入会waiting，直到t1释提交事务，来解决insert情况下的幻读问题</p><hr><p>那么，感觉RR就已经解决了幻读，为啥还需要串行化（Serializable ）？？？</p><p>操作4:</p><table><thead><tr><th>时刻</th><th>t1</th><th>t2</th></tr></thead><tbody><tr><td>1</td><td>begin</td><td>begin</td></tr><tr><td></td><td>select * from user where age=1;</td><td></td></tr><tr><td>3</td><td></td><td>insert into user values (4,’haha’,1);<br/>commit;</td></tr><tr><td>5</td><td>update user set name=’zhangsan2’ where age=1;</td><td></td></tr><tr><td>6</td><td>commit;</td><td></td></tr></tbody></table><p>RR级别下，此时想象中的结果为下面，因为实际上在第五行如果不是update而是select，是肯定差不到新数据的</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan2</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr><tr><td>4</td><td>haha</td><td>1</td></tr></tbody></table><p>但是实际的数据库中结果为：</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>zhangsan2</td><td>1</td></tr><tr><td>2</td><td>lisi</td><td>5</td></tr><tr><td>3</td><td>wangwu</td><td>10</td></tr><tr><td>4</td><td>zhangsan2</td><td>1</td></tr></tbody></table><p>其实在 MySQL在RR级别中并不是完全解决了幻读的问题，对照操作2中t2使用insert、操作3、以及操作4可以看出某些场景下RR解决了幻读，但是MVCC 对于幻读的解决是不彻底的。（快照读和当前读的混合使用会产生幻读问题）</p><h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><p>Innnodb有很多 log，持久性靠的是 redo log。</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql三大日志</title>
      <link href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
      <url>/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>日志是 <code>mysql</code> 数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。</p><p>作为开发，我们重点需要关注的是二进制日志( <code>binlog</code> )和事务日志(包括<code>redo log</code> 和 <code>undo log</code> )，本文接下来会详细介绍这三种日志。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p><code>binlog</code> 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code> 是 <code>mysql</code>的逻辑日志，并且由 <code>Server</code> 层进行记录，使用任何存储引擎的 <code>mysql</code> 数据库都会记录 <code>binlog</code> 日志。</p><ul><li><strong>逻辑日志</strong>：可以简单理解为记录的就是sql语句 。</li><li><strong>物理日志</strong>：<code>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li></ul><p><code>binlog</code> 是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code> 参数设置每个 <code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p><h3 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a><strong>binlog使用场景</strong></h3><p>在实际应用中， <code>binlog</code> 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p><ol><li><strong>主从复制</strong> ：在 <code>Master</code> 端开启 <code>binlog</code> ，然后将 <code>binlog</code>发送到各个 <code>Slave</code> 端， <code>Slave</code> 端重放 <code>binlog</code> 从而达到主从数据一致。</li><li><strong>数据恢复</strong> ：通过使用 <code>mysqlbinlog</code> 工具来恢复数据。</li></ol><h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a><strong>binlog刷盘时机</strong></h3><p>对于 <code>InnoDB</code> 存储引擎而言，只有在事务提交时才会记录<code>biglog</code> ，此时记录还在内存中，那么 <code>biglog</code>是什么时候刷到磁盘中的呢？</p><p><code>mysql</code> 通过 <code>sync_binlog</code> 参数控制 <code>biglog</code> 的刷盘时机，取值范围是 <code>0-N</code>：</p><ul><li>0：不去强制要求，由系统自行判断何时写入磁盘；</li><li>1：每次 <code>commit</code> 的时候都要将 <code>binlog</code> 写入磁盘；</li><li>N：每N个事务，才会将 <code>binlog</code> 写入磁盘。</li></ul><p>从上面可以看出， <code>sync_binlog</code> 最安全的是设置是 <code>1</code> ，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p><h3 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a><strong>binlog日志格式</strong></h3><p><code>binlog</code> 日志有三种格式，分别为 <code>STATMENT</code> 、 <code>ROW</code> 和 <code>MIXED</code>。</p><blockquote><p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code> ， <code>MySQL 5.7.7</code> 之后，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p></blockquote><ul><li><p><code>STATMENT</code>：基于<code>SQL</code> 语句的复制( <code>statement-based replication, SBR</code> )，每一条会修改数据的sql语句会记录到<code>binlog</code> 中  。</p></li><li><ul><li>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO  , 从而提高了性能；</li><li>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、  slepp()  等 。</li></ul></li><li><p><code>ROW</code>：基于行的复制(<code>row-based replication, RBR</code> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</p></li><li><ul><li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；</li><li>缺点：会产生大量的日志，尤其是<code>alter table</code> 的时候会让日志暴涨</li></ul></li><li><p><code>MIXED</code>：基于<code>STATMENT</code> 和 <code>ROW</code> 两种模式的混合复制(<code>mixed-based replication, MBR</code> )，一般的复制使用<code>STATEMENT</code> 模式保存 <code>binlog</code> ，对于 <code>STATEMENT</code> 模式无法复制的操作使用 <code>ROW</code> 模式保存 <code>binlog</code></p></li></ul><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a><strong>为什么需要redo log</strong></h3><p>我们都知道，事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。</p><p>那么 <code>mysql</code>是如何保证一致性的呢？</p><p>最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p><ol><li>因为 <code>Innodb</code> 是以 <code>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li><li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li></ol><p>因此 <code>mysql</code> 设计了 <code>redo log</code> ， <strong>具体来说就是只记录事务对数据页做了哪些****修改，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</strong></p><h3 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a><strong>redo log基本概念</strong></h3><p><code>redo log</code> 包括两部分：一个是内存中的日志缓冲( <code>redo log buffer</code> )，另一个是磁盘上的日志文件( <code>redo logfile</code>)。</p><p><code>mysql</code> 每执行一条 <code>DML</code> 语句，先将记录写入 <code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到 <code>redo log file</code>。这种 <strong>先写日志，再写磁盘</strong> 的技术就是 <code>MySQL</code>里经常说到的 <code>WAL(Write-Ahead Logging)</code> 技术。</p><p>在计算机操作系统中，用户空间( <code>user space</code> )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( <code>kernel space</code> )缓冲区( <code>OS Buffer</code> )。</p><p>因此， <code>redo log buffer</code> 写入 <code>redo logfile</code> 实际上是先写入 <code>OS Buffer</code> ，然后再通过系统调用 <code>fsync()</code> 将其刷到 <code>redo log file</code>中，过程如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/HPDG3n.png" alt="redolog刷盘"></p><p><code>mysql</code> 支持三种将 <code>redo log buffer</code> 写入 <code>redo log file</code> 的时机，可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数配置，各参数值含义如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/mV0ryb.png" alt="redolog参数"></p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/u45X6d.png" alt="redolog参数图"></p><h3 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a><strong>redo log记录形式</strong></h3><p>前面说过， <code>redo log</code> 实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 <code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。</p><p>如下图：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/emmy0S.png" alt="redolog环"></p><p>同时我们很容易得知， 在innodb中，既有<code>redo log</code> 需要刷盘，还有 <code>数据页</code> 也需要刷盘， <code>redo log</code>存在的意义主要就是降低对 <code>数据页</code> 刷盘的要求。</p><p>在上图中， <code>write pos</code> 表示 <code>redo log</code> 当前记录的 <code>LSN</code> (逻辑序列号)位置， <code>check point</code> 表示 <strong>数据页更改记录</strong> 刷盘后对应 <code>redo log</code> 所处的 <code>LSN</code>(逻辑序列号)位置。</p><p><code>write pos</code> 到 <code>check point</code> 之间的部分是 <code>redo log</code> 空着的部分，用于记录新的记录；<code>check point</code> 到 <code>write pos</code> 之间是 <code>redo log</code> 待落盘的数据页更改记录。当 <code>write pos</code>追上<code>check point</code> 时，会先推动 <code>check point</code> 向前移动，空出位置再记录新的日志。</p><p>启动 <code>innodb</code> 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 <code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 <code>binlog</code> )要快很多。</p><p>重启<code>innodb</code> 时，首先会检查磁盘中数据页的 <code>LSN</code> ，如果数据页的<code>LSN</code> 小于日志中的 <code>LSN</code> ，则会从 <code>checkpoint</code> 开始恢复。</p><p>还有一种情况，在宕机前正处于<code>checkpoint</code> 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 <code>LSN</code> 大于日志中的 <code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p><h3 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a><strong>redo log与binlog区别</strong></h3><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/QSGujy.png" alt="redolog和binlog区别"></p><p>由 <code>binlog</code> 和 <code>redo log</code> 的区别可知：<code>binlog</code> 日志只用于归档，只依靠 <code>binlog</code> 是没有 <code>crash-safe</code> 能力的。</p><p>但只有 <code>redo log</code> 也不行，因为 <code>redo log</code> 是 <code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code>binlog</code>和 <code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。</p><p>实际上， <strong>原子性</strong> 底层就是通过 <code>undo log</code> 实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条 <code>INSERT</code> 语句，对应一条<code>DELETE</code> 的 <code>undo log</code> ，对于每个 <code>UPDATE</code> 语句，对应一条相反的 <code>UPDATE</code> 的 <code>undo log</code> ，这样在发生错误时，就能回滚到事务之前的数据状态。</p><p>同时， <code>undo log</code> 也是 <code>MVCC</code>(多版本并发控制)实现的关键。</p><p>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生Undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</p><p>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。</p><p><strong>Undo Log 格式</strong></p><p>在InnoDB引擎中，undo log分为：</p><p><strong>insert undo log</strong>：</p><p>insert undo log是指在insert操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><p><strong>update undo log</strong>：</p><p>update undo log记录的是delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入undo log链表，等待purge线程进行最后的删除。下面是两种undo log的结构图。</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/11/zVqeou.png" alt="image-20220111180418341"></p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undolog</title>
      <link href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/"/>
      <url>/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务回滚的需求"><a href="#1-事务回滚的需求" class="headerlink" title="1.事务回滚的需求"></a>1.事务回滚的需求</h2><p>我们说过<code>事务</code>需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但是偏偏有时候事务执行到一半会出现一些情况，比如：</p><ul><li><p>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</p></li><li><p>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前的事务的执行。</p></li></ul><p>这两种情况都会导致事务执行到一半就结束，但是事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为<code>回滚</code>（英文名：<code>rollback</code>），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><p>每当我们要对一条记录做改动时（这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>），都需要留一手 —— 把回滚时所需的东西都给记下来。比方说：</p><ul><li><p>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</p></li><li><p>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</p></li><li><p>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</p></li></ul><p>数据库把这些为了回滚而记录的这些东西称之为撤销日志，英文名为<code>undo log</code>，我们也可以土洋结合，称之为<code>undo日志</code>。这里需要注意的一点是，由于查询操作（<code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的<code>undo日志</code>。在真实的<code>InnoDB</code>中，<code>undo日志</code>其实并不像我们上边所说的那么简单，不同类型的操作产生的<code>undo日志</code>的格式也是不同的，不过先暂时把这些具体细节放一放，我们先回过头来看看<code>事务id</code>。</p><h2 id="2-事务id"><a href="#2-事务id" class="headerlink" title="2.事务id"></a>2.事务id</h2><h3 id="2-1给事务分配id的时机"><a href="#2-1给事务分配id的时机" class="headerlink" title="2.1给事务分配id的时机"></a>2.1给事务分配id的时机</h3><p>一个事务可以是一个只读事务，或者是一个读写事务：</p><ul><li><p>我们可以通过<code>START TRANSACTION READ ONLY</code>语句开启一个只读事务。<br>在只读事务中不可以对普通的表（其他事务也能访问到的表）进行增、删、改操作，但可以对临时表做增、删、改操作。 </p></li><li><p>我们可以通过<code>START TRANSACTION READ WRITE</code>语句开启一个读写事务，或者使用<code>BEGIN</code>、<code>START TRANSACTION</code>语句开启的事务默认也算是读写事务。<br>在读写事务中可以对表执行增删改查操作。 </p></li></ul><p>如果某个事务执行过程中对某个表执行了增、删、改操作，那么<code>InnoDB</code>存储引擎就会给它分配一个独一无二的<code>事务id</code>，分配方式如下：</p><ul><li> 对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话是不分配<code>事务id</code>的。  </li></ul><p>对某个查询语句执行EXPLAIN分析它的查询计划时，有时候在Extra列会看到Using temporary的提示，这个表明在执行该查询语句时会用到内部临时表。这个所谓的内部临时表和我们手动用CREATE TEMPORARY TABLE创建的用户临时表并不一样，在事务回滚时并不需要把执行SELECT语句过程中用到的内部临时表也回滚，在执行SELECT语句用到内部临时表时并不会为它分配事务id。</p><ul><li>对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个<code>事务id</code>，否则的话也是不分配<code>事务id</code>的。<br>有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个<code>事务id</code>。 </li></ul><p><strong>只有在事务对表中的记录做改动时才会为这个事务分配一个唯一的</strong><code>**事务id**</code><strong>。</strong></p><p>上边描述的事务id分配策略是针对MySQL 5.7来说的，前边的版本的分配方式可能不同。</p><h3 id="2-2事务id是怎么生成的"><a href="#2-2事务id是怎么生成的" class="headerlink" title="2.2事务id是怎么生成的"></a>2.2事务id是怎么生成的</h3><p>这个<code>事务id</code>本质上就是一个数字，它的分配策略和我们前边提到的对隐藏列<code>row_id</code>（当用户没有为表创建主键和<code>UNIQUE</code>键时<code>InnoDB</code>自动创建的列）的分配策略大抵相同，具体策略如下：</p><ul><li><p>服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个<code>事务id</code>时，就会把该变量的值当作<code>事务id</code>分配给该事务，并且把该变量自增1。</p></li><li><p>每当这个变量的值为<code>256</code>的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>5</code>的页面中一个称之为<code>Max Trx ID</code>的属性处，这个属性占用<code>8</code>个字节的存储空间。</p></li><li><p>当系统下一次重新启动时，会将上边提到的<code>Max Trx ID</code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Trx ID</code>属性值）。</p></li></ul><p>这样就可以保证整个系统中分配的<code>事务id</code>值是一个递增的数字。先被分配<code>id</code>的事务得到的是较小的<code>事务id</code>，后被分配<code>id</code>的事务得到的是较大的<code>事务id</code>。</p><h3 id="2-3trx-id隐藏列"><a href="#2-3trx-id隐藏列" class="headerlink" title="2.3trx_id隐藏列"></a>2.3trx_id隐藏列</h3><p>聚簇索引的记录除了会保存完整的用户数据以外，而且还会自动添加名为trx_id、roll_pointer的隐藏列，如果用户没有在表中定义主键以及UNIQUE键，还会自动添加一个名为row_id的隐藏列。所以一条记录在页面中的真实结构看起来就是这样的：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/GOiqFm.png" alt="img"></p><p>其中的<code>trx_id</code>列其实还蛮好理解的，就是某个对这个聚簇索引记录做改动的语句所在的事务对应的<code>事务id</code>而已（此处的改动可以是<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>操作）。至于<code>roll_pointer</code>隐藏列我们后边分析。</p><h2 id="3-undo日志的格式"><a href="#3-undo日志的格式" class="headerlink" title="3.undo日志的格式"></a>3.undo日志的格式</h2><p>为了实现事务的<code>原子性</code>，<code>InnoDB</code>存储引擎在实际进行增、删、改一条记录时，都需要先把对应的<code>undo日志</code>记下来。一般每对一条记录做一次改动，就对应着一条<code>undo日志</code>，但在某些更新记录的操作中，也可能会对应着2条<code>undo日志</code>。一个事务在执行过程中可能新增、删除、更新若干条记录，也就是说需要记录很多条对应的<code>undo日志</code>，这些<code>undo日志</code>会被从<code>0</code>开始编号，也就是说根据生成的顺序分别被称为<code>第0号undo日志</code>、<code>第1号undo日志</code>、…、<code>第n号undo日志</code>等，这个编号也被称之为<code>undo no</code>。</p><p>这些<code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。这些页面可以从系统表空间中分配，也可以从一种专门存放<code>undo日志</code>的表空间，也就是所谓的<code>undo tablespace</code>中分配。先来看看不同操作都会产生什么样子的<code>undo日志</code>吧～我们先来创建一个名为<code>undo_demo</code>的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE undo_demo (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    col VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1)</span><br><span class="line">)Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>这个表中有3个列，其中<code>id</code>列是主键，我们为<code>key1</code>列建立了一个二级索引，<code>col</code>列是一个普通的列。每个表都会被分配一个唯一的<code>table id</code>，我们可以通过系统数据库<code>information_schema</code>中的<code>innodb_sys_tables</code>表来查看某个表对应的<code>table id</code>是什么，现在我们查看一下<code>undo_demo</code>对应的<code>table id</code>是多少：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#x27;yhd/undo_demo&#x27;;</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">| TABLE_ID | NAME                | FLAG | N_COLS | SPACE | FILE_FORMAT | ROW_FORMAT | ZIP_PAGE_SIZE | SPACE_TYPE |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">|      138 | yhd/undo_demo |   33 |      6 |   482 | Barracuda   | Dynamic    |             0 | Single     |</span><br><span class="line">+----------+---------------------+------+--------+-------+-------------+------------+---------------+------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>从查询结果可以看出，<code>undo_demo</code>表对应的<code>table id</code>为<code>138</code>。</p><h3 id="3-1INSERT操作对应的undo日志"><a href="#3-1INSERT操作对应的undo日志" class="headerlink" title="3.1INSERT操作对应的undo日志"></a>3.1INSERT操作对应的undo日志</h3><p>当我们向表中插入一条记录时会有<code>乐观插入</code>和<code>悲观插入</code>的区分，但是不管怎么插入，最终导致的结果就是这条记录被放到了一个数据页中。如果希望回滚这个插入操作，那么把这条记录删除就好了，也就是说在写对应的<code>undo</code>日志时，主要是把这条记录的主键信息记上。所以<code>InnoDB</code>设计了一个类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/qWMaKs.png" alt="img"></p><p>根据示意图我们强调几点：</p><ul><li><p><code>undo no</code>在一个事务中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。</p></li><li><p>如果记录中的主键只包含一个列，那么在类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列，那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的<code>len</code>就代表列占用的存储空间大小，<code>value</code>就代表列的真实值）。</p></li></ul><p>当我们向某个表中插入一条记录时，实际上需要向聚簇索引和所有的二级索引都插入一条记录。不过记录undo日志时，我们只需要考虑向聚簇索引插入记录时的情况就好了，因为其实聚簇索引记录和二级索引记录是一一对应的，我们在回滚插入操作时，只需要知道这条记录的主键信息，然后根据主键信息做对应的删除操作，做删除操作时就会顺带着把所有二级索引中相应的记录也删除掉。后边说到的DELETE操作和UPDATE操作对应的undo日志也都是针对聚簇索引记录而言的。</p><p>现在我们向<code>undo_demo</code>中插入两条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br></pre></td></tr></table></figure><p>因为记录的主键只包含一个<code>id</code>列，所以我们在对应的<code>undo日志</code>中只需要将待插入记录的<code>id</code>列占用的存储空间长度（<code>id</code>列的类型为<code>INT</code>，<code>INT</code>类型占用的存储空间长度为<code>4</code>个字节）和真实值记录下来。本例中插入了两条记录，所以会产生两条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>:</p><ul><li><p>第一条<code>undo日志</code>的<code>undo no</code>为<code>0</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>1</code>。画一个示意图就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/eWUSp2.png" alt="img"></p></li><li><p>第二条<code>undo日志</code>的<code>undo no</code>为<code>1</code>，记录主键占用的存储空间长度为<code>4</code>，真实值为<code>2</code>。画一个示意图就是这样（与第一条<code>undo日志</code>对比，<code>undo no</code>和主键各列信息有不同）：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/1m7QcK.png" alt="img"> </p></li></ul><p>为了最大限度的节省undo日志占用的存储空间，和我们前边说过的redo日志类似，InnoDB会给undo日志中的某些属性进行压缩处理。</p><h4 id="①roll-pointer隐藏列的含义"><a href="#①roll-pointer隐藏列的含义" class="headerlink" title="①roll_pointer隐藏列的含义"></a>①roll_pointer隐藏列的含义</h4><p><code>roll_pointer</code>本质上就是一个指向记录对应的<code>undo日志</code>的一个指针。比方说我们上边向<code>undo_demo</code>表里插入了2条记录，每条记录都有与其对应的一条<code>undo日志</code>。记录被存储到了类型为<code>FIL_PAGE_INDEX</code>的页面中（就是我们前边一直所说的<code>数据页</code>），<code>undo日志</code>被存放到了类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。效果如图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/OBcKdL.png" alt="img"></p><p><code>**roll_pointer**</code><strong>本质就是一个指针，指向记录对应的undo日志。</strong></p><h3 id="3-2-DELETE操作对应的undo日志"><a href="#3-2-DELETE操作对应的undo日志" class="headerlink" title="3.2 DELETE操作对应的undo日志"></a>3.2 DELETE操作对应的undo日志</h3><p>插入到页面中的记录会根据记录头信息中的<code>next_record</code>属性组成一个单向链表，我们把这个链表称之为<code>正常记录链表</code>；被删除的记录其实也会根据记录头信息中的<code>next_record</code>属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为<code>垃圾链表</code>。<code>Page Header</code>部分有一个称之为<code>PAGE_FREE</code>的属性，它指向由被删除记录组成的垃圾链表中的头节点。我们先画一个图，假设此刻某个页面中的记录分布情况是这样的（这个不是<code>undo_demo</code>表中的记录，只是我们随便举的一个例子）：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/A9CrRh.png" alt="img"></p><p>为了突出主题，在这个简化版的示意图中，我们只把记录的<code>delete_mask</code>标志位展示了出来。从图中可以看出，<code>正常记录链表</code>中包含了3条正常记录，<code>垃圾链表</code>里包含了2条已删除记录，在<code>垃圾链表</code>中的这些记录占用的存储空间可以被重新利用。页面的<code>Page Header</code>部分的<code>PAGE_FREE</code>属性的值代表指向<code>垃圾链表</code>头节点的指针。假设现在我们准备使用<code>DELETE</code>语句把<code>正常记录链表</code>中的最后一条记录给删除掉，其实这个删除的过程需要经历两个阶段：</p><ul><li>阶段一：仅仅将记录的<code>delete_mask</code>标识位设置为<code>1</code>，其他的不做修改（其实会修改记录的<code>trx_id</code>、<code>roll_pointer</code>这些隐藏列的值）。设计<code>InnoDB</code>的大叔把这个阶段称之为<code>delete mark</code>。<br>把这个过程画下来就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/6yPa60.png" alt="img"><br>可以看到，<code>正常记录链表</code>中的最后一条记录的<code>delete_mask</code>值被设置为<code>1</code>，但是并没有被加入到<code>垃圾链表</code>。也就是此时记录处于一个<code>中间状态</code>。在删除语句所在的事务提交之前，被删除的记录一直都处于这种所谓的<code>中间状态</code>。  </li></ul><p>为啥会有这种奇怪的中间状态呢？其实主要是为了实现一个称之为MVCC的功能。</p><ul><li>阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从<code>正常记录链表</code>中移除，并且加入到<code>垃圾链表</code>中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量<code>PAGE_N_RECS</code>、上次插入记录的位置<code>PAGE_LAST_INSERT</code>、垃圾链表头节点的指针<code>PAGE_FREE</code>、页面中可重用的字节数量<code>PAGE_GARBAGE</code>、还有页目录的一些信息等等。<code>InnoDB</code>把这个阶段称之为<code>purge</code>。<br>把<code>阶段二</code>执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。画下来就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/HvdH4n.png" alt="img"><br>将被删除记录加入到<code>垃圾链表</code>时，实际上加入到链表的头节点处，会跟着修改<code>PAGE_FREE</code>属性的值。 </li></ul><p>页面的Page Header部分有一个PAGE_GARBAGE属性，该属性记录着当前页面中可重用存储空间占用的总字节数。每当有已删除记录被加入到垃圾链表后，都会把这个PAGE_GARBAGE属性的值加上该已删除记录占用的存储空间大小。PAGE_FREE指向垃圾链表的头节点，之后每当新插入记录时，首先判断PAGE_FREE指向的头节点代表的已删除记录占用的存储空间是否足够容纳这条新插入的记录，如果不可以容纳，就直接向页面中申请新的空间来存储这条记录（并不会尝试遍历整个垃圾链表，找到一个可以容纳新记录的节点）。如果可以容纳，那么直接重用这条已删除记录的存储空间，并且把PAGE_FREE指向垃圾链表中的下一条已删除记录。但是这里有一个问题，如果新插入的那条记录占用的存储空间大小小于垃圾链表的头节点占用的存储空间大小，那就意味头节点对应的记录占用的存储空间里有一部分空间用不到，这部分空间就被称之为碎片空间。那这些碎片空间岂不是永远都用不到了么？其实也不是，这些碎片空间占用的存储空间大小会被统计到PAGE_GARBAGE属性中，这些碎片空间在整个页面快使用完前并不会被重新利用，不过当页面快满时，如果再插入一条记录，此时页面中并不能分配一条完整记录的空间，这时候会首先看一看PAGE_GARBAGE的空间和剩余可利用的空间加起来是不是可以容纳下这条记录，如果可以的话，InnoDB会尝试重新组织页内的记录，重新组织的过程就是先开辟一个临时页面，把页面内的记录依次插入一遍，因为依次插入时并不会产生碎片，之后再把临时页面的内容复制到本页面，这样就可以把那些碎片空间都解放出来（很显然重新组织页面内的记录比较耗费性能）。</p><p>从上边的描述中我们也可以看出来，在删除语句所在的事务提交之前，只会经历<code>阶段一</code>，也就是<code>delete mark</code>阶段（提交之后我们就不用回滚了，所以只需考虑对删除操作的<code>阶段一</code>做的影响进行回滚）。<code>InnoDB</code>为此设计了一种称之为<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>，它的完整结构如下图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/OUg54W.png" alt="img"></p><ul><li><p>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，就是我们图中显示的<code>old trx_id</code>和<code>old roll_pointer</code>属性。这样有一个好处，那就是可以通过<code>undo日志</code>的<code>old roll_pointer</code>找到记录在修改之前对应的<code>undo</code>日志。比方说在一个事务中，我们先插入了一条记录，然后又执行对该记录的删除操作，这个过程的示意图就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/RMBnjn.png" alt="img"><br>从图中可以看出来，执行完<code>delete mark</code>操作后，它对应的<code>undo</code>日志和<code>INSERT</code>操作对应的<code>undo</code>日志就串成了一个链表。这个链表就称之为<code>版本链</code>。 </p></li><li><p> 与类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>不同，类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo</code>日志还多了一个<code>索引列各列信息</code>的内容，也就是说如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个<code>索引列各列信息</code>部分，所谓的相关信息包括该列在记录中的位置（用<code>pos</code>表示），该列占用的存储空间大小（用<code>len</code>表示），该列实际值（用<code>value</code>表示）。所以<code>索引列各列信息</code>存储的内容实质上就是<code>&lt;pos, len, value&gt;</code>的一个列表。这部分信息主要是用在事务提交后，对该<code>中间状态记录</code>做真正删除的阶段二，也就是<code>purge</code>阶段中使用的。 </p></li></ul><p>现在继续在上边那个事务id为<code>100</code>的事务中删除一条记录，比如我们把<code>id</code>为1的那条记录删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1;</span><br></pre></td></tr></table></figure><p>这个<code>delete mark</code>操作对应的<code>undo日志</code>的结构就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/b0pp8n.png" alt="img"></p><p>对照着这个图，我们得注意下边几点：</p><ul><li><p> 因为这条<code>undo</code>日志是<code>id</code>为<code>100</code>的事务中产生的第3条<code>undo</code>日志，所以它对应的<code>undo no</code>就是<code>2</code>。 </p></li><li><p> 在对记录做<code>delete mark</code>操作时，记录的<code>trx_id</code>隐藏列的值是<code>100</code>（也就是说对该记录最近的一次修改就发生在本事务中），所以把<code>100</code>填入<code>old trx_id</code>属性中。然后把记录的<code>roll_pointer</code>隐藏列的值取出来，填入<code>old roll_pointer</code>属性中，这样就可以通过<code>old roll_pointer</code>属性值找到最近一次对该记录做改动时产生的<code>undo日志</code>。 </p></li><li><p> 由于<code>undo_demo</code>表中有2个索引：一个是聚簇索引，一个是二级索引<code>idx_key1</code>。只要是包含在索引中的列，那么这个列在记录中的位置（<code>pos</code>），占用存储空间大小（<code>len</code>）和实际值（<code>value</code>）就需要存储到<code>undo日志</code>中。 </p></li><li><ul><li> 对于主键来说，只包含一个<code>id</code>列，存储到<code>undo日志</code>中的相关信息分别是： </li></ul></li><li><ul><li><ul><li><code>pos</code>：<code>id</code>列是主键，也就是在记录的第一个列，它对应的<code>pos</code>值为<code>0</code>。<code>pos</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>len</code>：<code>id</code>列的类型为<code>INT</code>，占用4个字节，所以<code>len</code>的值为<code>4</code>。<code>len</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>value</code>：在被删除的记录中<code>id</code>列的值为<code>1</code>，也就是<code>value</code>的值为<code>1</code>。<code>value</code>占用4个字节来存储。</li></ul></li></ul></li></ul><p>画一个图演示一下就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/wLTLBE.png" alt="img"><br>所以对于<code>id</code>列来说，最终存储的结果就是<code>&lt;0, 4, 1&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 4 = 6</code>个字节。 </p><ul><li><ul><li> 对于<code>idx_key1</code>来说，只包含一个<code>key1</code>列，存储到<code>undo日志</code>中的相关信息分别是： </li></ul></li><li><ul><li><ul><li><code>pos</code>：<code>key1</code>列是排在<code>id</code>列、<code>trx_id</code>列、<code>roll_pointer</code>列之后的，它对应的<code>pos</code>值为<code>3</code>。<code>pos</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>len</code>：<code>key1</code>列的类型为<code>VARCHAR(100)</code>，使用<code>utf8</code>字符集，被删除的记录实际存储的内容是<code>AWM</code>，所以一共占用3个字节，也就是所以<code>len</code>的值为<code>3</code>。<code>len</code>占用1个字节来存储。</li></ul></li></ul></li><li><ul><li><ul><li><code>value</code>：在被删除的记录中<code>key1</code>列的值为<code>AWM</code>，也就是<code>value</code>的值为<code>AWM</code>。<code>value</code>占用3个字节来存储。</li></ul></li></ul></li></ul><p>画一个图演示一下就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/PntP80.png" alt="image.png"></p><p>所以对于<code>key1</code>列来说，最终存储的结果就是<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>，存储这些信息占用的存储空间大小为<code>1 + 1 + 3 = 5</code>个字节。<br>从上边的叙述中可以看到，<code>&lt;0, 4, 1&gt;</code>和<code>&lt;3, 3, &#39;AWM&#39;&gt;</code>共占用<code>11</code>个字节。然后<code>index_col_info len</code>本身占用<code>2</code>个字节，所以加起来一共占用<code>13</code>个字节，把数字<code>13</code>就填到了<code>index_col_info len</code>的属性中。 </p><h3 id="3-3-UPDATE操作对应的undo日志"><a href="#3-3-UPDATE操作对应的undo日志" class="headerlink" title="3.3 UPDATE操作对应的undo日志"></a>3.3 UPDATE操作对应的undo日志</h3><p>在执行<code>UPDATE</code>语句时，<code>InnoDB</code>对更新主键和不更新主键这两种情况有截然不同的处理方案。</p><h4 id="①不更新主键的情况"><a href="#①不更新主键的情况" class="headerlink" title="①不更新主键的情况"></a>①不更新主键的情况</h4><p>在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。</p><ul><li><p>就地更新（in-place update）<br>更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>，也就是直接在原记录的基础上修改对应列的值。 </p></li><li><p>先删除掉旧记录，再插入新记录<br>在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。<br>注意，这里所说的<code>删除</code>并不是<code>delete mark</code>操作，而是真正的删除掉，也就是把这条记录从<code>正常记录链表</code>中移除并加入到<code>垃圾链表</code>中，并且修改页面中相应的统计信息（比如<code>PAGE_FREE</code>、<code>PAGE_GARBAGE</code>等这些信息）。不过这里做真正删除操作的线程并不是在<code>DELETE</code>语句中做<code>purge</code>操作时使用的另外专门的线程，而是由用户线程同步执行真正的删除操作，真正删除之后紧接着就要根据各个列更新后的值创建的新记录插入。<br>这里如果新创建的记录占用的存储空间大小不超过旧记录占用的空间，那么可以直接重用被加入到<code>垃圾链表</code>中的旧记录所占用的存储空间，否则的话需要在页面中新申请一段空间以供新记录使用，如果本页面内已经没有可用的空间的话，那就需要进行页面分裂操作，然后再插入新记录。 </p></li></ul><p>针对<code>UPDATE</code>不更新主键的情况（包括上边所说的就地更新和先删除旧记录再插入新记录），InnoDB<code>设计了一种类型为</code>TRX_UNDO_UPD_EXIST_REC<code>的</code>undo日志`，它的完整结构如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/F0llIE.png" alt="img"></p><p>其实大部分属性和我们介绍过的<code>TRX_UNDO_DEL_MARK_REC</code>类型的<code>undo日志</code>是类似的，不过还是要注意这么几点：</p><ul><li><p><code>n_updated</code>属性表示本条<code>UPDATE</code>语句执行后将有几个列被更新，后边跟着的<code>&lt;pos, old_len, old_value&gt;</code>分别表示被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。</p></li><li><p>如果在<code>UPDATE</code>语句中更新的列包含索引列，那么也会添加<code>索引列各列信息</code>这个部分，否则的话是不会添加这个部分的。</p></li></ul><p>现在继续在上边那个事务id为100的事务中更新一条记录，比如我们把id为2的那条记录更新一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;  # 显式开启一个事务，假设该事务的id为100</span><br><span class="line"></span><br><span class="line"># 插入两条记录</span><br><span class="line">INSERT INTO undo_demo(id, key1, col) </span><br><span class="line">    VALUES (1, &#x27;AWM&#x27;, &#x27;狙击枪&#x27;), (2, &#x27;M416&#x27;, &#x27;步枪&#x27;);</span><br><span class="line">    </span><br><span class="line"># 删除一条记录    </span><br><span class="line">DELETE FROM undo_demo WHERE id = 1; </span><br><span class="line"></span><br><span class="line"># 更新一条记录</span><br><span class="line">UPDATE undo_demo</span><br><span class="line">    SET key1 = &#x27;M249&#x27;, col = &#x27;机枪&#x27;</span><br><span class="line">    WHERE id = 2;</span><br></pre></td></tr></table></figure><p>这个<code>UPDATE</code>语句更新的列大小都没有改动，所以可以采用<code>就地更新</code>的方式来执行，在真正改动页面记录时，会先记录一条类型为<code>TRX_UNDO_UPD_EXIST_REC</code>的<code>undo日志</code>，长这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/Yw0miI.png" alt="img"></p><p>对照着这个图我们注意一下这几个地方：</p><ul><li><p>因为这条<code>undo日志</code>是<code>id</code>为<code>100</code>的事务中产生的第4条<code>undo日志</code>，所以它对应的<code>undo no</code>就是3。</p></li><li><p>这条日志的<code>roll_pointer</code>指向<code>undo no</code>为<code>1</code>的那条日志，也就是插入主键值为<code>2</code>的记录时产生的那条<code>undo日志</code>，也就是最近一次对该记录做改动时产生的<code>undo日志</code>。</p></li><li><p>由于本条<code>UPDATE</code>语句中更新了索引列<code>key1</code>的值，所以需要记录一下<code>索引列各列信息</code>部分，也就是把主键和<code>key1</code>列更新前的信息填入。</p></li></ul><h4 id="②更新主键的情况"><a href="#②更新主键的情况" class="headerlink" title="②更新主键的情况"></a>②更新主键的情况</h4><p>在聚簇索引中，记录是按照主键值的大小连成了一个单向链表的，如果我们更新了某条记录的主键值，意味着这条记录在聚簇索引中的位置将会发生改变，比如你将记录的主键值从1更新为10000，如果还有非常多的记录的主键值分布在<code>1 ~ 10000</code>之间的话，那么这两条记录在聚簇索引中就有可能离得非常远，甚至中间隔了好多个页面。针对<code>UPDATE</code>语句中更新了记录主键值的这种情况，<code>InnoDB</code>在聚簇索引中分了两步处理：</p><ul><li>将旧记录进行<code>delete mark</code>操作<br>高能注意：这里是delete mark操作！这里是delete mark操作！这里是delete mark操作！也就是说在<code>UPDATE</code>语句所在的事务提交前，对旧记录只做一个<code>delete mark</code>操作，在事务提交后才由专门的线程做purge操作，把它加入到垃圾链表中。  </li></ul><p>之所以只对旧记录做delete mark操作，是因为别的事务同时也可能访问这条记录，如果把它真正的删除加入到垃圾链表后，别的事务就访问不到了。这个功能就是所谓的MVCC。</p><ul><li>根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。<br>由于更新后的记录主键值发生了改变，所以需要重新从聚簇索引中定位这条记录所在的位置，然后把它插进去。 </li></ul><p>针对<code>UPDATE</code>语句更新记录主键值的这种情况，在对该记录进行<code>delete mark</code>操作前，会记录一条类型为<code>TRX_UNDO_DEL_MARK_REC</code>的<code>undo日志</code>；之后插入新记录时，会记录一条类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，也就是说每对一条记录的主键值做改动时，会记录2条<code>undo日志</code>。</p><h2 id="4-通用链表结构"><a href="#4-通用链表结构" class="headerlink" title="4.通用链表结构"></a>4.通用链表结构</h2><p>在写入<code>undo日志</code>的过程中会使用到多个链表，很多链表都有同样的节点结构，如图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/zJ8twY.png" alt="img"></p><p>在某个表空间内，我们可以通过一个页的页号和在页内的偏移量来唯一定位一个节点的位置，这两个信息也就相当于指向这个节点的一个指针。所以：</p><ul><li><p><code>Pre Node Page Number</code>和<code>Pre Node Offset</code>的组合就是指向前一个节点的指针</p></li><li><p><code>Next Node Page Number</code>和<code>Next Node Offset</code>的组合就是指向后一个节点的指针。</p></li></ul><p>整个<code>List Node</code>占用<code>12</code>个字节的存储空间。</p><p>为了更好的管理链表，<code>InnoDB</code>还提出了一个基节点的结构，里边存储了这个链表的<code>头节点</code>、<code>尾节点</code>以及链表长度信息，基节点的结构示意图如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/uyyeDy.png" alt="img"></p><p>其中：</p><ul><li><p><code>List Length</code>表明该链表一共有多少节点。</p></li><li><p><code>First Node Page Number</code>和<code>First Node Offset</code>的组合就是指向链表头节点的指针。</p></li><li><p><code>Last Node Page Number</code>和<code>Last Node Offset</code>的组合就是指向链表尾节点的指针。</p></li></ul><p>整个<code>List Base Node</code>占用<code>16</code>个字节的存储空间。</p><p>所以使用<code>List Base Node</code>和<code>List Node</code>这两个结构组成的链表的示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/AFw4Yb.png" alt="img"></p><h2 id="5-FIL-PAGE-UNDO-LOG页面"><a href="#5-FIL-PAGE-UNDO-LOG页面" class="headerlink" title="5.FIL_PAGE_UNDO_LOG页面"></a>5.FIL_PAGE_UNDO_LOG页面</h2><p>表空间其实是由许许多多的页面构成的，页面默认大小为<code>16KB</code>。这些页面有不同的类型，比如类型为<code>FIL_PAGE_INDEX</code>的页面用于存储聚簇索引以及二级索引，类型为<code>FIL_PAGE_TYPE_FSP_HDR</code>的页面用于存储表空间头部信息的，还有其他各种类型的页面，其中有一种称之为<code>FIL_PAGE_UNDO_LOG</code>类型的页面是专门用来存储<code>undo日志</code>的，这种类型的页面的通用结构如下图所示（以默认的<code>16KB</code>大小为例）：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/ttbEnF.png" alt="img"></p><p>我们就简称为<code>Undo页面</code>，上图中的<code>File Header</code>和<code>File Trailer</code>是各种页面都有的通用结构。<code>Undo Page Header</code>是<code>Undo页面</code>所特有的，我们来看一下它的结构：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/SRgzem.png" alt="img"></p><p>其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。<br>前边介绍了好几种类型的<code>undo日志</code>，它们可以被分为两个大类： </p></li><li><ul><li><code>TRX_UNDO_INSERT</code>（使用十进制<code>1</code>表示）：类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>属于此大类，一般由<code>INSERT</code>语句产生，或者在<code>UPDATE</code>语句中有更新主键的情况也会产生此类型的<code>undo日志</code>。</li></ul></li><li><ul><li><code>TRX_UNDO_UPDATE</code>（使用十进制<code>2</code>表示），除了类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>都属于这个大类，比如我们前边说的<code>TRX_UNDO_DEL_MARK_REC</code>、<code>TRX_UNDO_UPD_EXIST_REC</code>啥的，一般由<code>DELETE</code>、<code>UPDATE</code>语句产生的<code>undo日志</code>属于这个大类。</li></ul></li></ul><p>这个<code>TRX_UNDO_PAGE_TYPE</code>属性可选的值就是上边的两个，用来标记本页面用于存储哪个大类的<code>undo日志</code>，不同大类的<code>undo日志</code>不能混着存储，比如一个<code>Undo页面</code>的<code>TRX_UNDO_PAGE_TYPE</code>属性值为<code>TRX_UNDO_INSERT</code>，那么这个页面就只能存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，其他类型的<code>undo日志</code>就不能放到这个页面中了。 </p><p>之所以把undo日志分成两个大类，是因为类型为TRX_UNDO_INSERT_REC的undo日志在事务提交后可以直接删除掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删除掉，对它们的处理需要区别对待。</p><ul><li><p> <code>TRX_UNDO_PAGE_START</code>：表示在当前页面中是从什么位置开始存储<code>undo日志</code>的，或者说表示第一条<code>undo日志</code>在本页面中的起始偏移量。 </p></li><li><p><code>TRX_UNDO_PAGE_FREE</code>：与上边的<code>TRX_UNDO_PAGE_START</code>对应，表示当前页面中存储的最后一条<code>undo</code>日志结束时的偏移量，或者说从这个位置开始，可以继续写入新的<code>undo日志</code>。<br>假设现在向页面中写入了3条<code>undo日志</code>，那么<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的示意图就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/tIMNDG.png" alt="img"><br>当然，在最初一条<code>undo日志</code>也没写入的情况下，<code>TRX_UNDO_PAGE_START</code>和<code>TRX_UNDO_PAGE_FREE</code>的值是相同的。 </p></li><li><p> <code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构（链表的普通节点，我们上边刚说的）。 </p></li></ul><h2 id="6-Undo页面链表"><a href="#6-Undo页面链表" class="headerlink" title="6.Undo页面链表"></a>6.Undo页面链表</h2><h3 id="6-1单个事务中的Undo页面链表"><a href="#6-1单个事务中的Undo页面链表" class="headerlink" title="6.1单个事务中的Undo页面链表"></a>6.1单个事务中的Undo页面链表</h3><p>因为一个事务可能包含多个语句，而且一个语句可能对若干条记录进行改动，而对每条记录进行改动前，都需要记录1条或2条的<code>undo日志</code>，所以在一个事务执行过程中可能产生很多<code>undo日志</code>，这些日志可能一个页面放不下，需要放到多个页面中，这些页面就通过我们上边介绍的<code>TRX_UNDO_PAGE_NODE</code>属性连成了链表：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/7mw8bz.png" alt="img"></p><p>我特意把链表中的第一个<code>Undo页面</code>给标了出来，称它为<code>first undo page</code>，其余的<code>Undo页面</code>称之为<code>normal undo page</code>，这是因为在<code>first undo page</code>中除了记录<code>Undo Page Header</code>之外，还会记录其他的一些管理信息。</p><p>在一个事务执行过程中，可能混着执行<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句，也就意味着会产生不同类型的<code>undo日志</code>。但是，同一个<code>Undo页面</code>要么只存储<code>TRX_UNDO_INSERT</code>大类的<code>undo日志</code>，要么只存储<code>TRX_UNDO_UPDATE</code>大类的<code>undo日志</code>，反正不能混着存，所以在一个事务执行过程中就可能需要2个<code>Undo页面</code>的链表，一个称之为<code>insert undo链表</code>，另一个称之为<code>update undo链表</code>，画个示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/OB9b2p.png" alt="img"></p><p>另外，<code>InnoDB</code>规定对普通表和临时表的记录改动时产生的<code>undo日志</code>要分别记录（我们稍后阐释为啥这么做），所以在一个事务中最多有4个以<code>Undo页面</code>为节点组成的链表：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/gn2kBz.png" alt="img"></p><p>当然，并不是在事务一开始就会为这个事务分配这4个链表，具体分配策略如下：</p><ul><li><p>刚刚开启事务时，一个<code>Undo页面</code>链表也不分配。</p></li><li><p>当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>普通表的insert undo链表</code>。</p></li><li><p>当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个<code>普通表的update undo链表</code>。</p></li><li><p>当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个<code>临时表的insert undo链表</code>。</p></li><li><p>当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个<code>临时表的update undo链表</code>。</p></li></ul><p>总结一句就是：按需分配，啥时候需要啥时候再分配，不需要就不分配。</p><h3 id="6-2多个事务中的Undo页面链表"><a href="#6-2多个事务中的Undo页面链表" class="headerlink" title="6.2多个事务中的Undo页面链表"></a>6.2多个事务中的Undo页面链表</h3><p>为了尽可能提高<code>undo日志</code>的写入效率，不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中。比方说现在有事务<code>id</code>分别为<code>1</code>、<code>2</code>的两个事务，我们分别称之为<code>trx 1</code>和<code>trx 2</code>，假设在这两个事务执行过程中：</p><ul><li><p><code>trx 1</code>对普通表做了<code>DELETE</code>操作，对临时表做了<code>INSERT</code>和<code>UPDATE</code>操作。<br><code>InnoDB</code>会为<code>trx 1</code>分配3个链表，分别是： </p></li><li><ul><li>针对普通表的<code>update undo链表</code></li></ul></li><li><ul><li>针对临时表的<code>insert undo链表</code></li></ul></li><li><ul><li>针对临时表的<code>update undo链表</code>。</li></ul></li><li><p><code>trx 2</code>对普通表做了<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>操作，没有对临时表做改动。<br><code>InnoDB</code>会为<code>trx 2</code>分配2个链表，分别是： </p></li><li><ul><li>针对普通表的<code>insert undo链表</code></li></ul></li><li><ul><li>针对普通表的<code>update undo链表</code>。</li></ul></li></ul><p>综上所述，在<code>trx 1</code>和<code>trx 2</code>执行过程中，<code>InnoDB</code>共需为这两个事务分配5个<code>Undo页面</code>链表，画个图就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/O665Sr.png" alt="img"></p><p>如果有更多的事务，那就意味着可能会产生更多的<code>Undo页面</code>链表。</p><h2 id="7-undo日志具体写入过程"><a href="#7-undo日志具体写入过程" class="headerlink" title="7.undo日志具体写入过程"></a>7.undo日志具体写入过程</h2><h3 id="7-1段（Segment）的概念"><a href="#7-1段（Segment）的概念" class="headerlink" title="7.1段（Segment）的概念"></a>7.1段（Segment）的概念</h3><p><code>段</code>是一个逻辑上的概念，本质上是由若干个零散页面和若干个完整的区组成的。比如一个<code>B+</code>树索引被划分成两个段，一个叶子节点段，一个非叶子节点段，这样叶子节点就可以被尽可能的存到一起，非叶子节点被尽可能的存到一起。每一个段对应一个<code>INODE Entry</code>结构，这个<code>INODE Entry</code>结构描述了这个段的各种信息，比如段的<code>ID</code>，段内的各种链表基节点，零散页面的页号有哪些等信息。我为了定位一个<code>INODE Entry</code>，<code>InnoDB</code>设计了一个<code>Segment Header</code>的结构：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/kp1B6d.png" alt="img"></p><p>整个<code>Segment Header</code>占用10个字节大小，各个属性的意思如下：</p><ul><li><p><code>Space ID of the INODE Entry</code>：<code>INODE Entry</code>结构所在的表空间ID。</p></li><li><p><code>Page Number of the INODE Entry</code>：<code>INODE Entry</code>结构所在的页面页号。</p></li><li><p><code>Byte Offset of the INODE Ent</code>：<code>INODE Entry</code>结构在该页面中的偏移量</p></li></ul><p>知道了表空间ID、页号、页内偏移量，就可以唯一定位一个<code>INODE Entry</code>的地址。</p><h3 id="7-2Undo-Log-Segment-Header"><a href="#7-2Undo-Log-Segment-Header" class="headerlink" title="7.2Undo Log Segment Header"></a>7.2Undo Log Segment Header</h3><p><code>InnoDB</code>规定，每一个<code>Undo页面</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。也就是说链表中的页面都是从这个段里边申请的，所以他们在<code>Undo页面</code>链表的第一个页面，也就是上边提到的<code>first undo page</code>中设计了一个称之为<code>Undo Log Segment Header</code>的部分，这个部分中包含了该链表对应的段的<code>segment header</code>信息以及其他的一些关于这个段的信息，所以<code>Undo</code>页面链表的第一个页面其实长这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/ir5E3d.png" alt="img"></p><p>可以看到这个<code>Undo</code>链表的第一个页面比普通页面多了个<code>Undo Log Segment Header</code>，我们来看一下它的结构：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/CxRuhe.png" alt="img"></p><p>其中各个属性的意思如下：</p><ul><li><p><code>TRX_UNDO_STATE</code>：本<code>Undo页面</code>链表处在什么状态。<br>一个<code>Undo Log Segment</code>可能处在的状态包括： </p></li><li><ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li></ul></li><li><ul><li><code>TRX_UNDO_CACHED</code>：被缓存的状态。处在该状态的<code>Undo页面</code>链表等待着之后被其他事务重用。</li></ul></li><li><ul><li><code>TRX_UNDO_TO_FREE</code>：对于<code>insert undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li></ul></li><li><ul><li><code>TRX_UNDO_TO_PURGE</code>：对于<code>update undo</code>链表来说，如果在它对应的事务提交之后，该链表不能被重用，那么就会处于这种状态。</li></ul></li><li><ul><li><code>TRX_UNDO_PREPARED</code>：包含处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul></li><li><p> <code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。 </p></li><li><p> <code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息。 </p></li><li><p> <code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。 </p></li></ul><p><code>Undo页面</code>的<code>Undo Page Header</code>部分有一个12字节大小的<code>TRX_UNDO_PAGE_NODE</code>属性，这个属性代表一个<code>List Node</code>结构。每一个<code>Undo页面</code>都包含<code>Undo Page Header</code>结构，这些页面就可以通过这个属性连成一个链表。这个<code>TRX_UNDO_PAGE_LIST</code>属性代表着这个链表的基节点，当然这个基节点只存在于<code>Undo页面</code>链表的第一个页面，也就是<code>first undo page</code>中。</p><h3 id="7-3Undo-Log-Header"><a href="#7-3Undo-Log-Header" class="headerlink" title="7.3Undo Log Header"></a>7.3Undo Log Header</h3><p>一个事务在向<code>Undo页面</code>中写入<code>undo日志</code>时的方式是十分简单暴力的，就是直接往里怼，写完一条紧接着写另一条，各条<code>undo日志</code>之间是亲密无间的。写完一个<code>Undo页面</code>后，再从段里申请一个新页面，然后把这个页面插入到<code>Undo页面</code>链表中，继续往这个新申请的页面中写。<code>InnoDB</code>认为同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，比方说我们上边介绍的<code>trx 1</code>由于会分配3个<code>Undo页面</code>链表，也就会写入3个组的<code>undo日志</code>；<code>trx 2</code>由于会分配2个<code>Undo页面</code>链表，也就会写入2个组的<code>undo日志</code>。在每写入一组<code>undo日志</code>时，都会在这组<code>undo日志</code>前先记录一下关于这个组的一些属性，<code>InnoDB</code>把存储这些属性的地方称之为<code>Undo Log Header</code>。所以<code>Undo页面</code>链表的第一个页面在真正写入<code>undo日志</code>前，其实都会被填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，如图所示：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/hY5DWe.png" alt="img"></p><p>这个<code>Undo Log Header</code>具体的结构如下：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/gkq6RR.png" alt="img"></p><p>我们先大致看一下它们都是啥意思：</p><ul><li><p> <code>TRX_UNDO_TRX_ID</code>：生成本组<code>undo日志</code>的事务<code>id</code>。 </p></li><li><p> <code>TRX_UNDO_TRX_NO</code>：事务提交后生成的一个需要序号，使用此序号来标记事务的提交顺序（先提交的此序号小，后提交的此序号大）。 </p></li><li><p> <code>TRX_UNDO_DEL_MARKS</code>：标记本组<code>undo</code>日志中是否包含由于<code>Delete mark</code>操作产生的<code>undo日志</code>。 </p></li><li><p> <code>TRX_UNDO_LOG_START</code>：表示本组<code>undo</code>日志中第一条<code>undo日志</code>的在页面中的偏移量。 </p></li><li><p> <code>TRX_UNDO_XID_EXISTS</code>：本组<code>undo日志</code>是否包含XID信息。 </p></li><li><p> <code>TRX_UNDO_DICT_TRANS</code>：标记本组<code>undo日志</code>是不是由DDL语句产生的。 </p></li><li><p> <code>TRX_UNDO_TABLE_ID</code>：如果<code>TRX_UNDO_DICT_TRANS</code>为真，那么本属性表示DDL语句操作的表的<code>table id</code>。 </p></li><li><p> <code>TRX_UNDO_NEXT_LOG</code>：下一组的<code>undo日志</code>在页面中开始的偏移量。 </p></li><li><p> <code>TRX_UNDO_PREV_LOG</code>：上一组的<code>undo日志</code>在页面中开始的偏移量。  </p></li></ul><p>一般来说一个Undo页面链表只存储一个事务执行过程中产生的一组undo日志，但是在某些情况下，可能会在一个事务提交之后，之后开启的事务重复利用这个Undo页面链表，这样就会导致一个Undo页面中可能存放多组Undo日志，TRX_UNDO_NEXT_LOG和TRX_UNDO_PREV_LOG就是用来标记下一组和上一组undo日志在页面中的偏移量的。</p><ul><li> <code>TRX_UNDO_HISTORY_NODE</code>：一个12字节的<code>List Node</code>结构，代表一个称之为<code>History</code>链表的节点。 </li></ul><h3 id="7-4小结"><a href="#7-4小结" class="headerlink" title="7.4小结"></a>7.4小结</h3><p>对于没有被重用的<code>Undo页面</code>链表来说，链表的第一个页面，也就是<code>first undo page</code>在真正写入<code>undo日志</code>前，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。对于其他的页面来说，也就是<code>normal undo page</code>在真正写入<code>undo日志</code>前，只会填充<code>Undo Page Header</code>。链表的<code>List Base Node</code>存放到<code>first undo page</code>的<code>Undo Log Segment Header</code>部分，<code>List Node</code>信息存放到每一个<code>Undo页面</code>的<code>undo Page Header</code>部分，所以画一个<code>Undo页面</code>链表的示意图就是这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/pirUYb.png" alt="img"></p><h2 id="8-重用Undo页面"><a href="#8-重用Undo页面" class="headerlink" title="8.重用Undo页面"></a>8.重用Undo页面</h2><p>为了能提高并发执行的多个事务写入<code>undo日志</code>的性能，<code>InnoDB</code>决定为每个事务单独分配相应的<code>Undo页面</code>链表（最多可能单独分配4个链表）。但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，针对某个<code>Undo页面</code>链表只产生了非常少的<code>undo日志</code>，这些<code>undo日志</code>可能只占用一点存储空间，每开启一个事务就新创建一个<code>Undo页面</code>链表（虽然这个链表中只有一个页面）来存储这么一点<code>undo日志</code>岂不是太浪费了么？的确是挺浪费，于是<code>InnoDB</code>决定在事务提交后在某些情况下重用该事务的<code>Undo页面</code>链表。一个<code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li><p>该链表中只包含一个<code>Undo页面</code>。<br>如果一个事务执行过程中产生了非常多的<code>undo日志</code>，那么它可能申请非常多的页面加入到<code>Undo页面</code>链表中。在该事物提交后，如果将整个链表中的页面都重用，那就意味着即使新的事务并没有向该<code>Undo页面</code>链表中写入很多<code>undo日志</code>，那该链表中也得维护非常多的页面，那些用不到的页面也不能被别的事务所使用，这样就造成了另一种浪费。所以<code>InnoDB</code>规定，只有在<code>Undo页面</code>链表中只包含一个<code>Undo页面</code>时，该链表才可以被下一个事务所重用。 </p></li><li><p> 该<code>Undo页面</code>已经使用的空间小于整个页面空间的3/4。 </p></li></ul><p><code>Undo页面</code>链表按照存储的<code>undo日志</code>所属的大类可以被分为<code>insert undo链表</code>和<code>update undo链表</code>两种，这两种链表在被重用时的策略也是不同的，我们分别看一下：</p><ul><li>insert undo链表<br><code>insert undo链表</code>中只存储类型为<code>TRX_UNDO_INSERT_REC</code>的<code>undo日志</code>，这种类型的<code>undo日志</code>在事务提交之后就没用了，就可以被清除掉。所以在某个事务提交后，重用这个事务的<code>insert undo链表</code>（这个链表中只有一个页面）时，可以直接把之前事务写入的一组<code>undo日志</code>覆盖掉，从头开始写入新事务的一组<code>undo日志</code>，如下图所示：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/6auiKu.png" alt="img"><br>如图所示，假设有一个事务使用的<code>insert undo链表</code>，到事务提交时，只向<code>insert undo链表</code>中插入了3条<code>undo日志</code>，这个<code>insert undo链表</code>只申请了一个<code>Undo页面</code>。假设此刻该页面已使用的空间小于整个页面大小的3/4，那么下一个事务就可以重用这个<code>insert undo链表</code>（链表中只有一个页面)。假设此时有一个新事务重用了该<code>insert undo链表</code>，那么可以直接把旧的一组<code>undo日志</code>覆盖掉，写入一组新的<code>undo日志</code>。  </li></ul><p>在重用Undo页面链表写入新的一组undo日志时，不仅会写入新的Undo Log Header，还会适当调整Undo Page Header、Undo Log Segment Header、Undo Log Header中的一些属性，比如TRX_UNDO_PAGE_START、TRX_UNDO_PAGE_FREE等等。</p><ul><li>update undo链表<br>在一个事务提交后，它的<code>update undo链表</code>中的<code>undo日志</code>也不能立即删除掉（这些日志用于MVCC）。所以如果之后的事务想重用<code>update undo链表</code>时，就不能覆盖之前事务写入的<code>undo日志</code>。这样就相当于在同一个<code>Undo页面</code>中写入了多组的<code>undo日志</code>，效果看起来就是这样：<br><img src="https://zhangxin66666.github.io/images/uPic/202201/12/ZBDWza.png" alt="img"> </li></ul><h2 id="9-回滚段"><a href="#9-回滚段" class="headerlink" title="9.回滚段"></a>9.回滚段</h2><h3 id="9-1回滚段的概念"><a href="#9-1回滚段的概念" class="headerlink" title="9.1回滚段的概念"></a>9.1回滚段的概念</h3><p>一个事务在执行过程中最多可以分配4个<code>Undo页面</code>链表，在同一时刻不同事务拥有的<code>Undo页面</code>链表是不一样的，所以在同一时刻系统里其实可以有许许多多个<code>Undo页面</code>链表存在。为了更好的管理这些链表，<code>InnoDB</code>又设计了一个称之为<code>Rollback Segment Header</code>的页面，在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，这些<code>页号</code>称之为<code>undo slot</code>。可以这样理解，每个<code>Undo页面</code>链表都相当于是一个班，这个链表的<code>first undo page</code>就相当于这个班的班长，找到了这个班的班长，就可以找到班里的其他同学（其他同学相当于<code>normal undo page</code>）。有时候学校需要向这些班级传达一下精神，就需要把班长都召集在会议室，这个<code>Rollback Segment Header</code>就相当于是一个会议室。</p><p>我们看一下这个称之为<code>Rollback Segment Header</code>的页面长啥样（以默认的16KB为例）：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/yP0tWZ.png" alt="img"></p><p><code>InnoDB</code>规定，每一个<code>Rollback Segment Header</code>页面都对应着一个段，这个段就称为<code>Rollback Segment</code>，翻译过来就是<code>回滚段</code>。与之前介绍的各种段不同的是，这个<code>Rollback Segment</code>里其实只有一个页面。</p><p>了解了<code>Rollback Segment</code>的含义之后，我们再来看看这个称之为<code>Rollback Segment Header</code>的页面的各个部分的含义都是啥意思：</p><ul><li><code>TRX_RSEG_MAX_SIZE</code>：本<code>Rollback Segment</code>中管理的所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和的最大值。换句话说，本<code>Rollback Segment</code>中所有<code>Undo页面</code>链表中的<code>Undo页面</code>数量之和不能超过<code>TRX_RSEG_MAX_SIZE</code>代表的值。<br>该属性的值默认为无限大，也就是我们想写多少<code>Undo页面</code>都可以。  </li></ul><p>无限大其实也只是个夸张的说法，4个字节能表示最大的数也就是0xFFFFFFFF，但是0xFFFFFFFF这个数有特殊用途，所以实际上TRX_RSEG_MAX_SIZE的值为0xFFFFFFFE。</p><ul><li><p> <code>TRX_RSEG_HISTORY_SIZE</code>：<code>History</code>链表占用的页面数量。 </p></li><li><p> <code>TRX_RSEG_HISTORY</code>：<code>History</code>链表的基节点。 </p></li><li><p> <code>TRX_RSEG_FSEG_HEADER</code>：本<code>Rollback Segment</code>对应的10字节大小的<code>Segment Header</code>结构，通过它可以找到本段对应的<code>INODE Entry</code>。 </p></li><li><p><code>TRX_RSEG_UNDO_SLOTS</code>：各个<code>Undo页面</code>链表的<code>first undo page</code>的<code>页号</code>集合，也就是<code>undo slot</code>集合。<br>一个页号占用<code>4</code>个字节，对于<code>16KB</code>大小的页面来说，这个<code>TRX_RSEG_UNDO_SLOTS</code>部分共存储了<code>1024</code>个<code>undo slot</code>，所以共需<code>1024 × 4 = 4096</code>个字节。 </p></li></ul><h3 id="9-2-从回滚段中申请Undo页面链表"><a href="#9-2-从回滚段中申请Undo页面链表" class="headerlink" title="9.2 从回滚段中申请Undo页面链表"></a>9.2 从回滚段中申请Undo页面链表</h3><p>初始情况下，由于未向任何事务分配任何<code>Undo页面</code>链表，所以对于一个<code>Rollback Segment Header</code>页面来说，它的各个<code>undo slot</code>都被设置成了一个特殊的值：<code>FIL_NULL</code>（对应的十六进制就是<code>0xFFFFFFFF</code>），表示该<code>undo slot</code>不指向任何页面。</p><p>随着时间的流逝，开始有事务需要分配<code>Undo页面</code>链表了，就从回滚段的第一个<code>undo slot</code>开始，看看该<code>undo slot</code>的值是不是<code>FIL_NULL</code>：</p><ul><li><p>如果是<code>FIL_NULL</code>，那么在表空间中新创建一个段（也就是<code>Undo Log Segment</code>），然后从段里申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>，然后把该<code>undo slot</code>的值设置为刚刚申请的这个页面的页号，这样也就意味着这个<code>undo slot</code>被分配给了这个事务。</p></li><li><p>如果不是<code>FIL_NULL</code>，说明该<code>undo slot</code>已经指向了一个<code>undo链表</code>，也就是说这个<code>undo slot</code>已经被别的事务占用了，那就跳到下一个<code>undo slot</code>，判断该<code>undo slot</code>的值是不是<code>FIL_NULL</code>，重复上边的步骤。</p></li></ul><p>一个<code>Rollback Segment Header</code>页面中包含<code>1024</code>个<code>undo slot</code>，如果这<code>1024</code>个<code>undo slot</code>的值都不为<code>FIL_NULL</code>，这就意味着这<code>1024</code>个<code>undo slot</code>都已经被分配给了某个事务，此时由于新事务无法再获得新的<code>Undo页面</code>链表，就会回滚这个事务并且给用户报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Too many active concurrent transactions</span><br></pre></td></tr></table></figure><p>用户看到这个错误，可以选择重新执行这个事务（可能重新执行时有别的事务提交了，该事务就可以被分配<code>Undo页面</code>链表了）。</p><p>当一个事务提交时，它所占用的<code>undo slot</code>有两种命运：</p><ul><li><p>如果该<code>undo slot</code>指向的<code>Undo页面</code>链表符合被重用的条件（就是我们上边说的<code>Undo页面</code>链表只占用一个页面并且已使用空间小于整个页面的3/4）。<br>该<code>undo slot</code>就处于被缓存的状态，InnoDB<code>规定这时该</code>Undo页面<code>链表的</code>TRX_UNDO_STATE<code>属性（该属性在</code>first undo page<code>的</code>Undo Log Segment Header<code>部分）会被设置为</code>TRX_UNDO_CACHED<code>。 被缓存的</code>undo slot<code>都会被加入到一个链表，根据对应的</code>Undo页面`链表的类型不同，也会被加入到不同的链表： </p></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>undo slot</code>会被加入<code>insert undo cached链表</code>。</li></ul></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>undo slot</code>会被加入<code>update undo cached链表</code>。</li></ul></li></ul><p>一个回滚段就对应着上述两个<code>cached链表</code>，如果有新事务要分配<code>undo slot</code>时，先从对应的<code>cached链表</code>中找。如果没有被缓存的<code>undo slot</code>，才会到回滚段的<code>Rollback Segment Header</code>页面中再去找。 </p><ul><li><p> 如果该<code>undo slot</code>指向的<code>Undo页面</code>链表不符合被重用的条件，那么针对该<code>undo slot</code>对应的<code>Undo页面</code>链表类型不同，也会有不同的处理： </p></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>insert undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_FREE</code>，之后该<code>Undo页面</code>链表对应的段会被释放掉（也就意味着段中的页面可以被挪作他用），然后把该<code>undo slot</code>的值设置为<code>FIL_NULL</code>。</li></ul></li><li><ul><li>如果对应的<code>Undo页面</code>链表是<code>update undo链表</code>，则该<code>Undo页面</code>链表的<code>TRX_UNDO_STATE</code>属性会被设置为<code>TRX_UNDO_TO_PRUGE</code>，则会将该<code>undo slot</code>的值设置为<code>FIL_NULL</code>，然后将本次事务写入的一组<code>undo</code>日志放到所谓的<code>History链表</code>中（需要注意的是，这里并不会将<code>Undo页面</code>链表对应的段给释放掉，因为这些<code>undo</code>日志还有用呢～）。</li></ul></li></ul><h3 id="9-3多个回滚段"><a href="#9-3多个回滚段" class="headerlink" title="9.3多个回滚段"></a>9.3多个回滚段</h3><p>一个事务执行过程中最多分配<code>4</code>个<code>Undo页面</code>链表，而一个回滚段里只有<code>1024</code>个<code>undo slot</code>，很显然<code>undo slot</code>的数量有点少。即使假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那<code>1024</code>个<code>undo slot</code>也只能支持<code>1024</code>个读写事务同时执行，再多了就崩溃了</p><p>在<code>InnoDB</code>的早期发展阶段的确只有一个回滚段，但是<code>InnoDB</code>后来意识到了这个问题，所以<code>InnoDB</code>一口气定义了<code>128</code>个回滚段，也就相当于有了<code>128 × 1024 = 131072</code>个<code>undo slot</code>。假设一个读写事务执行过程中只分配<code>1</code>个<code>Undo页面</code>链表，那么就可以同时支持<code>131072</code>个读写事务并发执行。</p><p>只读事务并不需要分配Undo页面链表，MySQL 5.7中所有刚开启的事务默认都是只读事务，只有在事务执行过程中对记录做了某些改动时才会被升级为读写事务。</p><p>每个回滚段都对应着一个<code>Rollback Segment Header</code>页面，有128个回滚段，自然就要有128个<code>Rollback Segment Header</code>页面，这些页面的地址需要找个地方存一下！于是<code>InnoDB</code>在系统表空间的第<code>5</code>号页面的某个区域包含了128个8字节大小的格子：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/NJIQgm.png" alt="img"></p><p>每个8字节的格子的构造就像这样：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/oOsYUY.png" alt="img"></p><p>如果所示，每个8字节的格子其实由两部分组成：</p><ul><li><p>4字节大小的<code>Space ID</code>，代表一个表空间的ID。</p></li><li><p>4字节大小的<code>Page number</code>，代表一个页号。</p></li></ul><p>也就是说每个8字节大小的<code>格子</code>相当于一个指针，指向某个表空间中的某个页面，这些页面就是<code>Rollback Segment Header</code>。这里需要注意的一点事，要定位一个<code>Rollback Segment Header</code>还需要知道对应的表空间ID，这也就意味着不同的回滚段可能分布在不同的表空间中。</p><p>所以通过上边的叙述我们可以大致清楚，在系统表空间的第<code>5</code>号页面中存储了128个<code>Rollback Segment Header</code>页面地址，每个<code>Rollback Segment Header</code>就相当于一个回滚段。在<code>Rollback Segment Header</code>页面中，又包含<code>1024</code>个<code>undo slot</code>，每个<code>undo slot</code>都对应一个<code>Undo页面</code>链表。我们画个示意图：</p><p><img src="https://zhangxin66666.github.io/images/uPic/202201/12/EJvfdp.png" alt="img"></p><h3 id="9-4回滚段的分类"><a href="#9-4回滚段的分类" class="headerlink" title="9.4回滚段的分类"></a>9.4回滚段的分类</h3><p>我们把这128个回滚段给编一下号，最开始的回滚段称之为<code>第0号回滚段</code>，之后依次递增，最后一个回滚段就称之为<code>第127号回滚段</code>。这128个回滚段可以被分成两大类：</p><ul><li><p>第<code>0</code>号、第<code>33～127</code>号回滚段属于一类。其中第<code>0</code>号回滚段必须在系统表空间中（就是说第<code>0</code>号回滚段对应的<code>Rollback Segment Header</code>页面必须在系统表空间中），第<code>33～127</code>号回滚段既可以在系统表空间中，也可以在自己配置的<code>undo</code>表空间中。<br>如果一个事务在执行过程中由于对普通表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。 </p></li><li><p>第<code>1～32</code>号回滚段属于一类。这些回滚段必须在临时表空间（对应着数据目录中的<code>ibtmp1</code>文件）中。<br>如果一个事务在执行过程中由于对临时表的记录做了改动需要分配<code>Undo页面</code>链表时，必须从这一类的段中分配相应的<code>undo slot</code>。 </p></li></ul><p>也就是说如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段，再分别到这两个回滚段中分配对应的<code>undo slot</code>。</p><p>为啥要把针对普通表和临时表来划分不同种类的<code>回滚段</code>呢？这个还得从<code>Undo页面</code>本身说起，我们说<code>Undo页面</code>其实是类型为<code>FIL_PAGE_UNDO_LOG</code>的页面的简称，说到底它也是一个普通的页面。我们前边说过，在修改页面之前一定要先把对应的<code>redo日志</code>写上，这样在系统奔溃重启时才能恢复到奔溃前的状态。我们向<code>Undo页面</code>写入<code>undo日志</code>本身也是一个写页面的过程，<code>InnoDB</code>为此还设计了许多种<code>redo日志</code>的类型，比方说<code>MLOG_UNDO_HDR_CREATE</code>、<code>MLOG_UNDO_INSERT</code>、<code>MLOG_UNDO_INIT</code>等等等等，也就是说我们对<code>Undo页面</code>做的任何改动都会记录相应类型的<code>redo日志</code>。但是对于临时表来说，因为修改临时表而产生的<code>undo日志</code>只需要在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这些<code>undo</code>日志所在的页面，所以在写针对临时表的<code>Undo页面</code>时，并不需要记录相应的<code>redo日志</code>。总结一下针对普通表和临时表划分不同种类的<code>回滚段</code>的原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p><p>实际上在MySQL 5.7.21这个版本中，如果我们仅仅对普通表的记录做了改动，那么只会为该事务分配针对普通表的回滚段，不分配针对临时表的回滚段。但是如果我们仅仅对临时表的记录做了改动，那么既会为该事务分配针对普通表的回滚段，又会为其分配针对临时表的回滚段（不过分配了回滚段并不会立即分配undo slot，只有在真正需要Undo页面链表时才会去分配回滚段中的undo slot）。</p><h3 id="9-5为事务分配Undo页面链表详细过程"><a href="#9-5为事务分配Undo页面链表详细过程" class="headerlink" title="9.5为事务分配Undo页面链表详细过程"></a>9.5为事务分配Undo页面链表详细过程</h3><p>接下来以事务对普通表的记录做改动为例，梳理一下事务执行过程中分配<code>Undo页面</code>链表时的完整过程：</p><ul><li><p>事务在执行过程中对普通表的记录首次做改动之前，首先会到系统表空间的第<code>5</code>号页面中分配一个回滚段（其实就是获取一个<code>Rollback Segment Header</code>页面的地址）。一旦某个回滚段被分配给了这个事务，那么之后该事务中再对普通表的记录做改动时，就不会重复分配了。<br>使用<code>round-robin</code>（循环使用）方式来分配回滚段。比如当前事务分配了第<code>0</code>号回滚段，那么下一个事务就要分配第<code>33</code>号回滚段，下下个事务就要分配第<code>34</code>号回滚段，简单一点的说就是这些回滚段被轮着分配给不同的事务。 </p></li><li><p> 在分配到回滚段后，首先看一下这个回滚段的两个<code>cached链表</code>有没有已经缓存了的<code>undo slot</code>，比如如果事务做的是<code>INSERT</code>操作，就去回滚段对应的<code>insert undo cached链表</code>中看看有没有缓存的<code>undo slot</code>；如果事务做的是<code>DELETE</code>操作，就去回滚段对应的<code>update undo cached链表</code>中看看有没有缓存的<code>undo slot</code>。如果有缓存的<code>undo slot</code>，那么就把这个缓存的<code>undo slot</code>分配给该事务。 </p></li><li><p>如果没有缓存的<code>undo slot</code>可供分配，那么就要到<code>Rollback Segment Header</code>页面中找一个可用的<code>undo slot</code>分配给当前事务。<br>从<code>Rollback Segment Header</code>页面中分配可用的<code>undo slot</code>的方式我们上边也说过了，就是从第<code>0</code>个<code>undo slot</code>开始，如果该<code>undo slot</code>的值为<code>FIL_NULL</code>，意味着这个<code>undo slot</code>是空闲的，就把这个<code>undo slot</code>分配给当前事务，否则查看第<code>1</code>个<code>undo slot</code>是否满足条件，依次类推，直到最后一个<code>undo slot</code>。如果这<code>1024</code>个<code>undo slot</code>都没有值为<code>FIL_NULL</code>的情况，就直接报错（一般不会出现这种情况）。 </p></li><li><p> 找到可用的<code>undo slot</code>后，如果该<code>undo slot</code>是从<code>cached链表</code>中获取的，那么它对应的<code>Undo Log Segment</code>已经分配了，否则的话需要重新分配一个<code>Undo Log Segment</code>，然后从该<code>Undo Log Segment</code>中申请一个页面作为<code>Undo页面</code>链表的<code>first undo page</code>。 </p></li><li><p> 然后事务就可以把<code>undo日志</code>写入到上边申请的<code>Undo页面</code>链表了！ </p></li></ul><p>对临时表的记录做改动的步骤和上述的一样。不过需要再次强调一次，如果一个事务在执行过程中既对普通表的记录做了改动，又对临时表的记录做了改动，那么需要为这个记录分配2个回滚段。并发执行的不同事务其实也可以被分配相同的回滚段，只要分配不同的undo slot就可以了。</p><h2 id="10-回滚段相关配置"><a href="#10-回滚段相关配置" class="headerlink" title="10.回滚段相关配置"></a>10.回滚段相关配置</h2><h3 id="10-1配置回滚段数量"><a href="#10-1配置回滚段数量" class="headerlink" title="10.1配置回滚段数量"></a>10.1配置回滚段数量</h3><p>系统中一共有<code>128</code>个回滚段，其实这只是默认值，我们可以通过启动参数<code>innodb_rollback_segments</code>来配置回滚段的数量，可配置的范围是<code>1~128</code>。但是这个参数并不会影响针对临时表的回滚段数量，针对临时表的回滚段数量一直是<code>32</code>，也就是说：</p><ul><li><p>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>1</code>，那么只会有1个针对普通表的可用回滚段，但是仍然有32个针对临时表的可用回滚段。</p></li><li><p>如果我们把<code>innodb_rollback_segments</code>的值设置为<code>2～33</code>之间的数，效果和将其设置为<code>1</code>是一样的。</p></li><li><p>如果我们把<code>innodb_rollback_segments</code>设置为大于<code>33</code>的数，那么针对普通表的可用回滚段数量就是该值减去32。</p></li></ul><h3 id="10-2-配置undo表空间"><a href="#10-2-配置undo表空间" class="headerlink" title="10.2 配置undo表空间"></a>10.2 配置undo表空间</h3><p>默认情况下，针对普通表设立的回滚段（第<code>0</code>号以及第<code>33~127</code>号回滚段）都是被分配到系统表空间的。其中的第<code>0</code>号回滚段是一直在系统表空间的，但是第<code>33~127</code>号回滚段可以通过配置放到自定义的<code>undo表空间</code>中。但是这种配置只能在系统初始化（创建数据目录时）的时候使用，一旦初始化完成，之后就不能再次更改了。我们看一下相关启动参数：</p><ul><li><p> 通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录，如果没有指定该参数，则默认<code>undo表空间</code>所在的目录就是数据目录。 </p></li><li><p>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量。该参数的默认值为<code>0</code>，表明不创建任何<code>undo表空间</code>。<br>第<code>33~127</code>号回滚段可以平均分布到不同的<code>undo表空间</code>中。 </p></li></ul><p>如果我们在系统初始化的时候指定了创建了undo表空间，那么系统表空间中的第0号回滚段将处于不可用状态。</p><p>比如我们在系统初始化时指定的<code>innodb_rollback_segments</code>为<code>35</code>，<code>innodb_undo_tablespaces</code>为<code>2</code>，这样就会将第<code>33</code>、<code>34</code>号回滚段分别分布到一个<code>undo表空间</code>中。</p><p>设立<code>undo表空间</code>的一个好处就是在<code>undo表空间</code>中的文件大到一定程度时，可以自动的将该<code>undo表空间</code>截断（truncate）成一个小文件。而系统表空间的大小只能不断的增大，却不能截断。</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h2><p>为了保证事务的原子性设计，InnoDB引入了undo日志。undo日志记载了回滚一个段所需的必要内容。</p><p>在事务对表中的记录进行改动的时候，才会为这个事务分配一个唯一的ID。事务ID值是一个递增的数字。先被分配ID的事务得到的是较小的事务ID，后被分配ID的事务得到的是较大的事务ID。未被分配事务ID的事务ID默认是0。聚簇索引记录中有一个trx_id隐藏列，他代表对这个聚簇索引隐藏记录进行改动的语句所在的事务对应的事务ID。</p><p>InnoDB针对不同的场景设计了不同类型的undo日志。</p><p>类型为FIL_PAGE_UNDO_LOG的页面是专门用来存储undo日志的，简称为undo页面。</p><p>在一个事务执行过程中，最多分配四个undo页面链表：</p><ol><li><p>针对普通表的insert undo链表</p></li><li><p>针对普通表的update undo链表</p></li><li><p>针对临时表的insert undo链表</p></li><li><p>针对临时表的update undo链表</p></li></ol><p>只有在真正用到这些链表的时候才会去创建他们。</p><p>每个undo页面链表都对应一个undo log segment。undo页面链表的第一个页面中有一个名为undo log segment header 的部分，专门用来存储关于这个段的一些信息。</p><p>同一个事务向一个undo页面链表中写入的undo日志算是一个组，每个组都以一个undo log header部分开头。</p><p>一个undo页面链表如果可以被重用，需要符合两个条件：</p><ol><li><p>该链表只包含一个undo页面</p></li><li><p>该undo页面已经使用的空间小于整个页面空间的3/4</p></li></ol><p>每一个Rollback segmrnt header 页面都对应一个回滚段，每个回滚段包含1024个undo slot，一个undo slot代表一个undo页面链表的第一个页面的页号。目前，InnoDB最多支持128个回滚段，其中第0号，第33127号回滚段是针对普通表设计的，第132号回滚段是针对临时表设计的。</p><p>我们可以选择将undo日志记录到专门的undo表空间中，在undo表空间中的文件大到一定程度时，可以自动将该undo表空间截断为小文件。</p>]]></content>
      
      
      <categories>
          
          <category> 7.mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
