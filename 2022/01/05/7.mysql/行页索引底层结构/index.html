<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>行页索引底层结构 | 金子爸爸の家</title><meta name="keywords" content="Mysql"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2介绍mysql行、页、索引底层结构">
<meta property="og:type" content="article">
<meta property="og:title" content="行页索引底层结构">
<meta property="og:url" content="https://zhangxin66666.github.io/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="2介绍mysql行、页、索引底层结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-04T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-13T02:31:00.685Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '行页索引底层结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-13 10:31:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">行页索引底层结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-04T16:00:00.000Z" title="发表于 2022-01-05 00:00:00">2022-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-13T02:31:00.685Z" title="更新于 2022-01-13 10:31:00">2022-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/7-mysql/">7.mysql</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="行页索引底层结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先明确下什么是索引呢？假设我一张数据库的表存了10亿条数据，如果要查找出其中的10条数据，如果逐条遍历匹配的话，效率上肯定是无法容忍的。所以为了提高数据查询的效率，就需要对数据进行一些格式化的存储，来方便我们更快的查找，这就是索引。</p>
<p>索引其实是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】，为什么要有页呢？</p>
<p>如果我们在查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p>
<p>换句话讲，其实就是内存一次拉到磁盘的数据最少是16KB，内存写入磁盘的数据一次最少也是16KB。</p>
<p>上面解释清楚了索引和页，MySQL的InnoDB存储引擎是基于页来进行内存和磁盘的数据交互的。所以我们的数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。</p>
<p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/o9sjNL.png" alt="页行层级关系"></p>
<p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p>
<h1 id="一、行"><a href="#一、行" class="headerlink" title="一、行"></a>一、行</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p>
<h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><p>首先来看下，我们如何来指定行格式呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称</span><br></pre></td></tr></table></figure>

<p>比如我们创建一张表来指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br></pre></td></tr></table></figure>

<h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/u1WZ5x.png" alt="行格式示意图"></p>
<h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>先来看额外的信息，其实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p>
<h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】</p>
<p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p>
<p>在Compact行格式中，会把所有的变长字段占用的真实长度全部逆序存储在记录的开头位置，形成一个变长字段长度列表。</p>
<p>比如我们刚才创建的那张表，我们来分析一下：</p>
<p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>储存内容</th>
<th>内容长度(十进制表示)</th>
<th>内容长度(十六进制表示)</th>
</tr>
</thead>
<tbody><tr>
<td>C1</td>
<td>‘aaaa’</td>
<td>4</td>
<td>0x04</td>
</tr>
<tr>
<td>C2</td>
<td>‘bbb’</td>
<td>3</td>
<td>0x03</td>
</tr>
<tr>
<td>C4</td>
<td>‘d’</td>
<td>1</td>
<td>0x01</td>
</tr>
</tbody></table>
<p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/GicNPe.png" alt="行记录demo"></p>
<p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p>
<p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p>
<p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p>
<p>【L】：真实占用的字节数</p>
<ol>
<li><ol>
<li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li>
</ol>
<p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p>
</li>
<li><p>如果M*W&gt;=255,这个时候再次分为两种情况： </p>
</li>
<li><ol>
<li>如果L&lt;=127，那就用1个字节表示</li>
<li>否则就用2个字节表示</li>
</ol>
</li>
</ol>
<p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p>
<p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p>
<p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p>
<p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p>
<p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p>
<h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p>
<p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p>
<p>看一下处理过程：</p>
<ol>
<li>首先统计出表中允许存储NULL的字段</li>
<li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li>
<li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li>
</ol>
<p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p>
<p>这个时候再来看我们上面创建的表中的记录。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Ar1SSA.png" alt="行记录null值列"></p>
<h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/DkHw2Y.png" alt="记录头信息"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p>
<p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p>
<p>在完善下我们开头创建的那张表的记录形象。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/hrhU7z.png" alt="行真实数据"></p>
<p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p>
<h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p>
<p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p>
<p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p>
<h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p>
<h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p>
<p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p>
<ol>
<li>真实数据</li>
<li>真实数据占用的字节长度</li>
<li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li>
</ol>
<p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p>
<p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p>
<p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p>
<p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p>
<p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p>
<h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p>
<p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Lx6rk0.png" alt="行溢出1"></p>
<p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/9Nx5jA.png" alt="行溢出2"></p>
<p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p>
<h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p>
<p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p>
<p>分析一下页空间是如何利用的</p>
<ol>
<li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li>
<li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：</li>
</ol>
<table>
<thead>
<tr>
<th>内容</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>真实数据的长度</td>
<td>2</td>
</tr>
<tr>
<td>列是否是NULL值</td>
<td>1</td>
</tr>
<tr>
<td>头信息</td>
<td>5</td>
</tr>
<tr>
<td>row_id</td>
<td>6</td>
</tr>
<tr>
<td>transaction_id</td>
<td>6</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>7</td>
</tr>
</tbody></table>
<p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p>
<h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/uUTNzw.png" alt="行格式"></p>
<p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p>
<p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p>
<h1 id="二、页"><a href="#二、页" class="headerlink" title="二、页"></a>二、页</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p>
<p>本节分析存放表中记录的页，官方称为索引页，为了分析方便，我们暂且叫做数据页。</p>
<p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p>
<p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/wGkd2K.png" alt="页1"></p>
<p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小（字节）</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infifmum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/bHvkJU.png" alt="页2"></p>
<p>再次回顾下记录头中5个字节表示的数据。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>针对当前这个表的行格式简化图：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/GRkUos.png" alt="页3"></p>
<p>接下来我们往表中插入几条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/iHTjzS.png" alt="页4"></p>
<p>分析一下头信息中的每个属性是什么意思。</p>
<h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p>
<p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p>
<p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p>
<h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p>
<h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p>
<p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p>
<p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p>
<p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/4PMBmm.png" alt="页5"></p>
<p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/XJNMeJ.png" alt="页6"></p>
<p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p>
<h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p>
<p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p>
<h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/EF4CbT.png" alt="页7"></p>
<p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure>

<p>删除第二条记录以后：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/bDrm6E.png" alt="页8"></p>
<p>发生的变化：</p>
<ul>
<li><p>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</p>
</li>
<li><p>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</p>
</li>
<li><p>第一条记录的next record指向了第三条记录</p>
</li>
<li><p>最大记录的 n_owned 值从5 变成了4</p>
</li>
</ul>
<p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p>
<p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p>
<p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p>
<p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/zGw6Ie.png" alt="页9"></p>
<p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p>
<h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li>
<li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li>
<li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li>
</ol>
<p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/rHTXYE.png" alt="页10"></p>
<p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p>
<p>注意最大和最小记录的头信息的n_owned属性：</p>
<ol>
<li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li>
<li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li>
</ol>
<p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/D4ieuJ.png" alt="页11"></p>
<p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。所以分组是按照下边的步骤进行的：</p>
<ul>
<li><p> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </p>
</li>
<li><p> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </p>
</li>
<li><p> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </p>
</li>
</ul>
<p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/M7MnRG.png" alt="页12"></p>
<p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p>
<ol>
<li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li>
<li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li>
<li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li>
</ol>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的数据页</td>
</tr>
</tbody></table>
<p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p>
<p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p>
<h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p>
<p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p>
<ol>
<li><p>前四个字节代表校验和</p>
</li>
<li><p>后四个字节代表页面被最后修改时对应的日志序列位置</p>
</li>
</ol>
<p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p>
<p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p>
<h1 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h1><h2 id="1-索引结构"><a href="#1-索引结构" class="headerlink" title="1.索引结构"></a>1.索引结构</h2><h3 id="1-1-聚簇索引"><a href="#1-1-聚簇索引" class="headerlink" title="1.1 聚簇索引"></a>1.1 聚簇索引</h3><p>上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </p>
<p>页内的记录是按照主键的大小顺序排成一个单向链表。</p>
<p>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</p>
<p>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</p>
</li>
<li><p>B+树的叶子节点存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </p>
</li>
</ol>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。另外，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/j76g6u.png" alt="聚簇索引"></p>
<h3 id="1-2-二级索引"><a href="#1-2-二级索引" class="headerlink" title="1.2 二级索引"></a>1.2 二级索引</h3><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p>
<p>我们可以多建几棵B+树，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/pup6Oo.png" alt="二级索引"></p>
<p>这个B+树与上边介绍的聚簇索引有几处不同：</p>
<ol>
<li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义： </p>
<p>a页内的记录是按照c2列的大小顺序排成一个单向链表。</p>
<p>b各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。</p>
<p>c存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。</p>
</li>
<li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。 </p>
</li>
<li><p>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。 </p>
</li>
</ol>
<p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为4的记录为例，查找过程如下：</p>
<p>1确定目录项记录页</p>
<p>根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 &lt; 4 &lt; 9）。</p>
<p>2通过目录项记录页确定用户记录真实所在的页。</p>
<p>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页34和页35中。</p>
<p>3在真实存储用户记录的页中定位到具体的记录.</p>
<p>到页34和页35中定位到具体的记录。</p>
<p>4但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程也被称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树！！！</p>
<p>为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不就好了么？</p>
<p>如果把完整的用户记录放到叶子节点是可以不用回表，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引（英文名secondary index），或者辅助索引。由于我们使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为为c2列建立的索引。</p>
<p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p>
<p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p>
<h3 id="1-3-联合索引"><a href="#1-3-联合索引" class="headerlink" title="1.3 联合索引"></a>1.3 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<p>●先把各个记录和页按照c2列进行排序。</p>
<p>●在记录的c2列相同的情况下，采用c3列进行排序</p>
<p>为c2和c3列建立的索引的示意图如下：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/h5xwiY.png" alt="联合索引"></p>
<h1 id="四、总结：一次通过聚簇索引定位数据的过程"><a href="#四、总结：一次通过聚簇索引定位数据的过程" class="headerlink" title="四、总结：一次通过聚簇索引定位数据的过程"></a>四、总结：一次通过聚簇索引定位数据的过程</h1><p>大家熟悉的三个版本索引结构图如下</p>
<p>普通索引</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/cCfg6Z.png" alt="总结1"></p>
<p>二级索引</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/qwXHhA.png" alt="总结2"></p>
<p>组合索引索引</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/MiAzWo.png" alt="总结3"></p>
<p>相对完整些的三种索引结构见（三、索引）</p>
<p>下图为聚簇索引完整版结构</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/gfMbZY.png" alt="聚簇索引数据结构完整版"></p>
<p>一次按照主键id查询id=5的数据的全流程</p>
<p>1.确定目录项记录页，找到页50</p>
<p>2.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页55</p>
<p>3.二分查找确定所属槽位1，然后遍历槽位1里的链表得知下次该继续查询页61</p>
<p>4.二分查找确定所属槽位2，然后遍历槽位2里的链表得到id为4的数据</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/">https://zhangxin66666.github.io/2022/01/05/7.mysql/行页索引底层结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"><img class="prev-cover" src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ConcurrentHashMap源码解读</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img class="next-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ACID及实现原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/" title="mysql三大日志"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">mysql三大日志</div></div></a></div><div><a href="/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="ACID及实现原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-28</div><div class="title">ACID及实现原理</div></div></a></div><div><a href="/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/" title="redolog"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">redolog</div></div></a></div><div><a href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/" title="undolog"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">undolog</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%A1%8C"><span class="toc-text">一、行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. 如何指定行格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-compact-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.compact 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A2%9D%E5%A4%96%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1 额外的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-text">2.1.1 变长字段长度列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">2.1.2 NULL值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.3 记录头信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-CHAR-%E4%B9%9F%E6%98%AF%E5%8F%98%E9%95%BF%E7%9A%84%EF%BC%9F"><span class="toc-text">2.2.1 CHAR 也是变长的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="toc-text">3. 行溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-varchar-M-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">3.1 varchar(M)最多能存储的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%AA%E5%A4%9A%E4%BA%A7%E7%94%9F%E6%BA%A2%E5%87%BA"><span class="toc-text">3.2 记录中的数据太多产生溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E4%B8%B4%E7%95%8C%E7%82%B9"><span class="toc-text">3.3 行溢出的临界点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Dynamic-amp-Compressed-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.Dynamic &amp; Compressed 行格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%B5"><span class="toc-text">二、页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%B0%E5%BD%95%E5%9C%A8%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">1. 记录在页中的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-delete-mask"><span class="toc-text">1.1 delete_mask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-min-rec-mask"><span class="toc-text">1.2 min_rec_mask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-n-owned"><span class="toc-text">1.3 n_owned</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-heap-no"><span class="toc-text">1.4 heap_no</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-record-type"><span class="toc-text">1.5 record_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-next-record"><span class="toc-text">1.6 next_record</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Page-Directory%EF%BC%88%E9%A1%B5%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-text">2. Page Directory（页目录）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Page-Header%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-text">3.Page Header（页面头部）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-File-Header%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-text">4.File Header（文件头部）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-text">5.File Trailer(文件尾部)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-text">三、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">1.索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">1.1 聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">1.2 二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">1.3 联合索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%80%E6%AC%A1%E9%80%9A%E8%BF%87%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">四、总结：一次通过聚簇索引定位数据的过程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/" title="业务架构-稳定性建设方法论"><img src="/images/cover/%E6%96%B9%E6%B3%95%E8%AE%BA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="业务架构-稳定性建设方法论"/></a><div class="content"><a class="title" href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/" title="业务架构-稳定性建设方法论">业务架构-稳定性建设方法论</a><time datetime="2022-01-16T16:00:00.000Z" title="发表于 2022-01-17 00:00:00">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读"><img src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap源码解读"/></a><div class="content"><a class="title" href="/2022/01/12/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读">ConcurrentHashMap源码解读</a><time datetime="2022-01-12T01:46:11.938Z" title="发表于 2022-01-12 09:46:11">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" title="行页索引底层结构"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行页索引底层结构"/></a><div class="content"><a class="title" href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" title="行页索引底层结构">行页索引底层结构</a><time datetime="2022-01-04T16:00:00.000Z" title="发表于 2022-01-05 00:00:00">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="ACID及实现原理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ACID及实现原理"/></a><div class="content"><a class="title" href="/2021/12/28/7.mysql/ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" title="ACID及实现原理">ACID及实现原理</a><time datetime="2021-12-27T16:00:00.000Z" title="发表于 2021-12-28 00:00:00">2021-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/" title="mysql三大日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql三大日志"/></a><div class="content"><a class="title" href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/" title="mysql三大日志">mysql三大日志</a><time datetime="2021-12-26T16:00:00.000Z" title="发表于 2021-12-27 00:00:00">2021-12-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>