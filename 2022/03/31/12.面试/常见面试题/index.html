<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识点总结 | 金子爸爸の家</title><meta name="keywords" content="面试"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点总结">
<meta property="og:url" content="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png">
<meta property="article:published_time" content="2022-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-07T09:33:25.727Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-07 17:33:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-07T09:33:25.727Z" title="更新于 2022-04-07 17:33:25">2022-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-集合"><a href="#1-集合" class="headerlink" title="1.集合"></a>1.集合</h2><h3 id="1-1ConcurrentHashMap"><a href="#1-1ConcurrentHashMap" class="headerlink" title="1.1ConcurrentHashMap"></a>1.1ConcurrentHashMap</h3><p><a href="../../1.基础知识/ConcurrentHashMap" target="_blank">ConcurrentHashMap</a></p>
<h3 id="1-2xxx"><a href="#1-2xxx" class="headerlink" title="1.2xxx"></a>1.2xxx</h3><h2 id="Set-List-Map有什么区别"><a href="#Set-List-Map有什么区别" class="headerlink" title="Set,List,Map有什么区别"></a>Set,List,Map有什么区别</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/abkwex.png" alt="image-20220331111150319"></p>
<ul>
<li>结构特点<ol>
<li>List 和 Set 是存储单列数据的集合， Map 是存储键和值这样的双列数据的集合;</li>
<li>List中存储的数据是有顺序，并且允许重复; Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的， Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的hashcode决定，位置是固定的(Set集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的);</li>
</ol>
</li>
</ul>
<h2 id="HashMap和HashTable有什么区别？"><a href="#HashMap和HashTable有什么区别？" class="headerlink" title="HashMap和HashTable有什么区别？"></a>HashMap和HashTable有什么区别？</h2><p>区别：</p>
<ol>
<li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li>
<li>HashMap允许key和value为null，而HashTable不允许</li>
</ol>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><ol>
<li>jdk1.7底层采用的是数组+链表实现；jdk1.8底层采用数组+链表+红黑树实现，相对于1.7提升了查询的性能</li>
<li>链表过度到红黑树的阈值为8，红黑树退化为链表的阈值是6，原因在源码中332行给了明确解释(Poisson distribution)泊松分布，这是数学里面类似于正态分布的一个问题，这是统计学里面的一些东西</li>
<li>HashMap初始化的数组长度为16(算法导论中的除法散列法讲到 K取模m得到一个对应的位置，根据具体位置插入一个数据值，假如长度是16，长度范围就是0<del>15，取模之后我的余数为0</del>15之间，而算法导论中指出，一个不太接近2的整数幂的素数（质数：只能被1和它本身整出的数），常常是m的最好选择。但是hashMap中未采用素数，而是采用2的n次方(合数)作为数组长度)，原因为：1、更便于位置计算；2、方便做数据迁移。</li>
<li>为了保证存入的数据均匀的散列分布在数组中，需要设计良好的hash散列算法(hashMap中采用扰动函数来做的：移位和异或相关操作ConcurrentHashMap源码中684行spread方法，即：让int的高16位异或它本身)，尽可能的避免hash冲突(概率问题)，具体落到数组哪个节点并非是通过取模运算得出，而是通过与上数组长度-1即可(只需要int类型数32位的后四位参与运算)，即可得到0~15之间的数，因为取模运算效率远低于位运算，所以这也是hashMap要求底层数组长度必须为2的n次方的原因之一（ConcurrentHashMap源码中514行规定）。</li>
</ol>
<h3 id="HashMap-put流程"><a href="#HashMap-put流程" class="headerlink" title="HashMap put流程"></a>HashMap put流程</h3><ol>
<li>HashMap/ConcurrentHashMap 并不是通过构造函数创建默认空间的，而是通过put数据的时候获取到对应的数据空间的，如果数组长度是0，则通过CAS操作后初始化数组，如果有线程正在做初始化数组操作，其他线程则让出时间片</li>
<li></li>
</ol>
<h3 id="HashMap扩容流程"><a href="#HashMap扩容流程" class="headerlink" title="HashMap扩容流程"></a>HashMap扩容流程</h3><ol>
<li>hashMap规定了当我的数组快放满的时候就要开始扩容了，什么时候算是快放满？HashMap是通过扩容因子来规定的</li>
<li>HashMap规定扩容因子是0.75，如果默认长度是16，也就是说当HashMap底层数组的容量达到12的时候进行扩容操作。0.75则是根据统计学得来的。<code>private static final float LOAD_FACTOR = 0.75f;</code></li>
<li>扩容首先要创建新的数组（原来大小左移1位）ConcurrentHaspMap源码2367行开始扩容操作</li>
<li>转移旧数据到新的数组中去（怎么计算扩容后数据下标位置？）原来：h&amp;(n-1)计算下标位置，扩容后 h$(31)，原来占用4个二进制位，扩容后占用5个二进制位，所以只需要看第五位即可，如果第五位是0，扩容后的的下标跟原位置一样，如果是1，新下标位置在原数组的位置的基础上加上原来数组长度即可，这也是数组长度采用2的N次方扩容的第二个原因</li>
<li>假设原来长度是128，扩容后是256，整体扩容方式是通过多线程方式运行的，但是要保证数据不能乱，将原来数组分段，规定每个线程最少负责16个桶的迁移工作，8个线程可以并行执行，如果小于16个桶，直接单线程执行</li>
</ol>
<h3 id="为什么选择用红黑树"><a href="#为什么选择用红黑树" class="headerlink" title="为什么选择用红黑树"></a>为什么选择用红黑树</h3><p>二叉树在极端情况下会退化为链表，查询时间复杂度跟链表相似，而AVL树，SB树，红黑树，都属于平衡二叉树，尽量保持左子树和右子树的高度差不要相差太大，而这三种树的差别就在于左树和右树的高度规则不同。</p>
<ul>
<li>AVL树：严格意义平衡树，的要求左子树和右子树的高度差不能超过1，损失了部分插入性能，带来了高效的查询</li>
<li>SB树：</li>
<li>红黑树：要求最长子树不能超过最短子树的2倍即可，损失了部分查询性能，使得查询效率高于链表的同时，相比于其他树提升了插入性能，尽量做到了插入和查询的一个平衡点，而HashMap则是查多，插入少(这里的插入指的是产生Hash冲突下的插入)，所以红黑树更适合HashMap来做底层的存储结构。</li>
</ul>
<h3 id="ConcurrentHaspMap"><a href="#ConcurrentHaspMap" class="headerlink" title="ConcurrentHaspMap"></a>ConcurrentHaspMap</h3><ol>
<li>ConcurrentHaspMap是线程安全的HashMap，它底层采用大量的CAS操作</li>
</ol>
<h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征?"></a>面向对象的特征?</h3><p>面向对象的特征:封装、继承、多态、抽象。 封装:就是把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内 部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。 继承:子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代 码的复用性。 多态:指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采 用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备 的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。 抽象:表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类(接口)就是为了继承而存在的。</p>
<h3 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h3><ol>
<li>java.lang.NullPointerException 空指针异常;出现原因:调用了未经初始化的对象或者是不存在 的对象。</li>
<li>java.lang.ClassNotFoundException 指定的类找不到;出现原因:类的名称和路径加载错误;通常 都是程序试图通过字符串来加载某个类时可能引发异常。</li>
<li>java.lang.NumberFormatException 字符串转换为数字异常;出现原因:字符型数据中包含非数 字型字符。</li>
<li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</li>
<li>java.lang.IllegalArgumentException 方法传递参数错误。</li>
<li>java.lang.ClassCastException 数据类型转换异常。 </li>
<li>java.lang.NoClassDefFoundException 未找到类定义错误。</li>
<li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。</li>
<li>java.lang.InstantiationException实例化异常。</li>
<li>java.lang.NoSuchMethodException方法不存在异常。</li>
</ol>
<h3 id="常见的引用类型"><a href="#常见的引用类型" class="headerlink" title="常见的引用类型"></a>常见的引用类型</h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<ul>
<li><strong>强引用</strong>：普通的变量引用</li>
<li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li>
<li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li>
<li><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li>
</ul>
<h1 id="二、JVM"><a href="#二、JVM" class="headerlink" title="二、JVM"></a>二、JVM</h1><h2 id="1-jvm基础"><a href="#1-jvm基础" class="headerlink" title="1.jvm基础"></a>1.jvm基础</h2><h3 id="1-1jvm内存模型"><a href="#1-1jvm内存模型" class="headerlink" title="1.1jvm内存模型"></a>1.1jvm内存模型</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/0Wv4TH.png"/>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/4jwdVI.png" alt="image-20220331111041423"></p>
<ol>
<li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li>
<li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li>
<li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li>
<li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li>
</ol>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol>
<li>引用计数法</li>
<li>可达性分析法</li>
</ol>
<p>对于可达性分析法，我们知道需要存在一个GC Root的对象作为起点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。</p>
<h3 id="GC-Root有哪些？"><a href="#GC-Root有哪些？" class="headerlink" title="GC Root有哪些？"></a>GC Root有哪些？</h3><ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中JNI引用对象</li>
</ul>
<h3 id="垃圾回收器有哪些？"><a href="#垃圾回收器有哪些？" class="headerlink" title="垃圾回收器有哪些？"></a>垃圾回收器有哪些？</h3><ol>
<li><strong>Serial收集器</strong>(-XX:+UseSerialGC -XX:+UseSerialOldGC)：Serial（串行）收集器是一个单线程收集器，新生代采用复制算法，老年代采用标记-整理算法。</li>
<li><strong>Parallel Scavenge收集器</strong>(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)) ：Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同</li>
<li><strong>ParNew收集器</strong>(-XX:+UseParNewGC)：只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作</li>
<li><strong>CMS收集器</strong>(-XX:+UseConcMarkSweepGC(old))：收集器是一种以获取最短回收停顿时间为目标的收集器CMS收集器是一种 “标记-清除”算法实现的。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</li>
<li><strong>G1收集器</strong>(-XX:+UseG1GC)：G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M</li>
<li><strong>Shenandoah：</strong>可以看成是G1升级版</li>
<li><strong>ZGC收集器：</strong>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器。1、支持TB量级的堆；2、最大GC停顿时间不超10ms；3、奠定未来GC特性的基础；4、最糟糕的情况下吞吐量会降低15%</li>
</ol>
<h3 id="CMS运行过程，缺点？"><a href="#CMS运行过程，缺点？" class="headerlink" title="CMS运行过程，缺点？"></a>CMS运行过程，缺点？</h3><p>整个过程分为四个步骤</p>
<ol>
<li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>对CPU资源敏感（会和服务抢资源）</li>
<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li>
</ol>
<h3 id="G1运行过程"><a href="#G1运行过程" class="headerlink" title="G1运行过程"></a>G1运行过程</h3><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p>
<ol>
<li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li>
<li>并发标记（Concurrent Marking）：同CMS的并发标记</li>
<li>最终标记（Remark，STW）：同CMS的重新标记</li>
<li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li>
</ol>
<h3 id="G1适合什么场景"><a href="#G1适合什么场景" class="headerlink" title="G1适合什么场景"></a>G1适合什么场景</h3><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h3 id="判断元空间是无用的类"><a href="#判断元空间是无用的类" class="headerlink" title="判断元空间是无用的类"></a>判断元空间是无用的类</h3><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h3 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h3><p><strong>安全点：</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>安全区域：如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p>
<h3 id="类加载器？双亲委派，好处？"><a href="#类加载器？双亲委派，好处？" class="headerlink" title="类加载器？双亲委派，好处？"></a>类加载器？双亲委派，好处？</h3><p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p>
<p><strong>双亲委派：</strong>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p>
<p><strong>好处：</strong>1、安全性，避免自己写的类替换掉java核心类；2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p>
<h3 id="YGC和FGC发生的场景"><a href="#YGC和FGC发生的场景" class="headerlink" title="YGC和FGC发生的场景"></a>YGC和FGC发生的场景</h3><p>YGC：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。edn空间不足,执行 </p>
<p>FGC：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。生产环境，一般比较少会触发fgc，有时10天或一周左右会有一次。</p>
<p>老年代空间不足，永久区空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</p>
<h3 id="jstack，jmap，Jstat作用"><a href="#jstack，jmap，Jstat作用" class="headerlink" title="jstack，jmap，Jstat作用"></a>jstack，jmap，Jstat作用</h3><p><strong>jmap：</strong>可以用来查看内存信息，实例个数以及占用内存大小</p>
<ul>
<li>jmap -heap 进程号：查看堆内存信息</li>
<li>jmap ‐dump:format=b,file=eureka.hprof 进程号： 堆内存的快照信息，添加jvm参数也可以设置内存溢出自动导出dump文件</li>
</ul>
<p><strong>jstack:</strong> 可以获得java线程的运行情况，可以查看死锁，阻塞，等待</p>
<ul>
<li>Jstack -l PID &gt;&gt; 123.txt 打印某个java进程的堆栈信息</li>
</ul>
<p><strong>Jstat：</strong>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量</p>
<ul>
<li>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</li>
</ul>
<h1 id="三、Mysql数据库"><a href="#三、Mysql数据库" class="headerlink" title="三、Mysql数据库"></a>三、Mysql数据库</h1><h2 id="1-索引底层结构-amp-行格式-amp-页格式"><a href="#1-索引底层结构-amp-行格式-amp-页格式" class="headerlink" title="1.索引底层结构&amp;行格式&amp;页格式"></a>1.索引底层结构&amp;行格式&amp;页格式</h2><p>文章内容包含索引结构，联合索引结构，聚簇索引、非聚簇索引区别，在页上如何搜索具体数据过程，一次完成的索引检索过程</p>
<p>地址：<a href="/2022/01/05/7.mysql/行页索引底层结构" target="_blank">行页索引底层结构</a></p>
<h2 id="2-一条-SQL-的执行过程详解"><a href="#2-一条-SQL-的执行过程详解" class="headerlink" title="2.一条 SQL 的执行过程详解"></a>2.一条 SQL 的执行过程详解</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/jK9nFC.png" alt="image-20220402151247405"></p>
<p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<p>至此表示整个更新事务已经完成</p>
<p><strong>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</strong> </p>
<p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。 </p>
<p>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是<strong>更新内存BufferPool</strong>，然后<strong>顺序写日志文件</strong>，同时还能 </p>
<p>保证各种异常情况下的数据一致性。 </p>
<p>更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。 </p>
<p>正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干的读写请求。</p>
<p>细节介绍server层连接器、词法分析器、优化器、执行器、查询缓存功能见单独文章</p>
<p>地址：<a href="/2022/04/02/7.mysql/mysql执行流程" target="_blank">mysql执行流程</a></p>
<h2 id="3-ACID及实现原理"><a href="#3-ACID及实现原理" class="headerlink" title="3.ACID及实现原理"></a>3.ACID及实现原理</h2><ul>
<li>（Atomicity）原子性： 事务是最小的执行单位，不允许分割。要么全都执行,要么全都不执行；——-&gt;原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时，撤销已经执行成功的sql</li>
<li>（Consistency）一致性： 执行事务前后，数据保持一致；——-&gt;原子性、隔离性、持久性就是为了来保证一致性</li>
<li>（Isolation）隔离性： 并发访问数据库时，一个事务不被其他事务所干扰，数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行；——-&gt;锁机制和MVCC共同实现</li>
<li>（Durability）持久性: 一个事务被提交之后。对数据库中数据的改变是持久的，即使数据库发生故障也不会受到影响。——-&gt;持久性由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。</li>
</ul>
<h2 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h2><p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p>
<p>MVCC主要解决三个问题：</p>
<p>第一、通过MVCC可以解决读写并发阻塞问题，从而提高数据库的并发处理能力；</p>
<p>第二、MVCC采用的是乐观锁的方式实现，降低了死锁的概率；</p>
<p>第三、解决了一致性读的问题，也就是事务启动的时候，根据某个条件去读取到的数据，知道事务结束的时候再去执行相同条件，还是读到同一份数据，不会发生变化变化。</p>
<p><strong>MVCC用于读已提交（RC）和可重复读级别（RR）的控制，主要通过undo log日志版本链和read view来实现，</strong></p>
<p>InnoDB中MVCC的实现依赖四个条件: 隐藏字段, 事务链表，read view, undo log</p>
<p>数据表额外字段</p>
<p><strong>DB_TRX_ID(6字节)</strong>: 在innoDB中, 会为每个事物分配一个事务ID. 而该字段表示的就是插入或更新该行的最后一个事务的事务标识符.</p>
<p><strong>DB_ROLL_PTR(7字节)</strong>: 这个字段称为回滚指针, 指向了回滚段的撤销日志. (undo log)</p>
<p><strong>DB_ROW_ID(6字节)</strong>:  这个字段包含了一个行ID. 该ID在插入新行时会单调增加. 这个字段是为了在表里没有主键ID的时候, 生成聚簇索引使用的.</p>
<p>rowid存的是什么？</p>
<p>rowid默认是主键，如果没有主键，会选择唯一键，如果没有唯一键，会生成6字节的rowid</p>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/7Syg8j.png" alt="聚簇索引行结构" style="zoom: 67%;" />



<p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚 </p>
<p>日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kP6kYm.png" alt="image-20220407160145376"></p>
<p>在<strong>可重复读隔离级别（RR）</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束 </p>
<p>之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>)，这个视图由执行查询时所有未提交事 </p>
<p>务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应 </p>
<p>版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。 </p>
<p><strong>版本链比对规则：</strong> </p>
<ol>
<li><p>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的； </p>
</li>
<li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若 </p>
</li>
</ol>
<p>row 的 trx_id 就是当前自己的事务是可见的）；3. 如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况 </p>
<p>​        a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自 </p>
<p>己的事务是可见的)； </p>
<p>​        b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。 </p>
<p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的 </p>
<p>trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被 </p>
<p>删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数 </p>
<p>据。</p>
<p><strong>注意：</strong>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句， </p>
<p>事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。 </p>
<p><strong>总结：</strong> </p>
<p>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取 </p>
<p>同一条数据在版本链上的不同版本数据。 </p>
<h2 id="5-mysql三大日志"><a href="#5-mysql三大日志" class="headerlink" title="5.mysql三大日志"></a>5.mysql三大日志</h2><p>地址：<a href="/2021/12/27/7.mysql/mysql三大日志" target="_blank">mysql三大日志</a></p>
<h2 id="6-redo日志"><a href="#6-redo日志" class="headerlink" title="6.redo日志"></a>6.redo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/redo日志" target="_blank">redo日志</a></p>
<h2 id="7-undo日志"><a href="#7-undo日志" class="headerlink" title="7.undo日志"></a>7.undo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/undo日志" target="_blank">undo日志</a></p>
<h2 id="8-能说下myisam-和-innodb的区别吗"><a href="#8-能说下myisam-和-innodb的区别吗" class="headerlink" title="8.能说下myisam 和 innodb的区别吗"></a>8.能说下myisam 和 innodb的区别吗</h2><table>
<thead>
<tr>
<th>区别</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引</td>
<td>聚簇索引和非聚簇索引</td>
<td>非聚簇索引</td>
</tr>
<tr>
<td>行锁</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储文件</td>
<td>frm(表结构)，ibd(数据和索引)</td>
<td>frm，myi(索引文件)，myd(数据文件)</td>
</tr>
<tr>
<td>具体行数</td>
<td>全表扫描统计行数</td>
<td>通过变量保存行数</td>
</tr>
</tbody></table>
<ul>
<li>MyISAM不支持事务，在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li>
<li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，(因为有mvcc机制)不会加锁。但是update、insert、delete操作会加行锁。简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</li>
</ul>
<h2 id="9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"><a href="#9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别" class="headerlink" title="9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"></a>9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别</h2><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
<h2 id="10-什么是覆盖索引和回表"><a href="#10-什么是覆盖索引和回表" class="headerlink" title="10.什么是覆盖索引和回表"></a>10.什么是覆盖索引和回表</h2><p>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助 索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为回表。也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树—-一次辅助索引，一次聚集索引。</p>
<h2 id="11-mysql的各种锁。-间隙锁"><a href="#11-mysql的各种锁。-间隙锁" class="headerlink" title="11.mysql的各种锁。  间隙锁"></a>11.mysql的各种锁。  间隙锁</h2><p>锁分类图解</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/SNv09f.png" alt="image-20220407172447222"></p>
<p><strong>按照兼容性分类</strong></p>
<p>InnoDB实现了以下两种类型的行锁。</p>
<p><strong>「共享锁（S)」</strong>：又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据， 但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>
<p><strong>「排他锁（X)」</strong>：exclusive lock（也叫writer lock）又称写锁。 若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前， 其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。 <strong>「排它锁是悲观锁的一种实现」</strong>。</p>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），<code>这两种意向锁都是表锁</code>。</p>
<p><strong>「意向共享锁（IS）」</strong>：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>「意向排他锁（IX）」</strong>：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p><strong>「InnoDB行锁模式兼容性列表」</strong></p>
<table>
<thead>
<tr>
<th>请求锁模式 是否兼容当前锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT写操作，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p>
<p>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p>
<p>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在， 并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作， 则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p>
<p>InnoDB在事务执行过程中，使用<code>两阶段锁协议</code>：</p>
<p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p>
<p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p>
<p><strong>按算法分类</strong></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/acUCbj.jpg" alt="img"></p>
<p><strong>「Record Lock」</strong>： 单个行记录上的锁</p>
<p>锁总会锁住索引记录，锁住的是key。</p>
<p>如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB会使用隐式的主键进行锁定。</p>
<p>如果要锁的没有索引，则会进行全表记录加锁。</p>
<p><strong>「Gap Lock」</strong> ：间隙锁，锁定一个范围，但不包含记录本身</p>
<p>锁定索引记录间隙，确保索引记录的间隙不变</p>
<p>间隙锁时针对事务隔离级别为可重复读或以上级别而配的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读</span><br></pre></td></tr></table></figure>

<p><strong>「Next-Key Lock」</strong>：临键锁，Gap Lock + Record Lock，锁定一个范围，并且包含记录本身</p>
<p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<p>当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。</p>
<h2 id="12-MRR"><a href="#12-MRR" class="headerlink" title="12.MRR"></a>12.MRR</h2><p>每次从二级索引中读取到一条记录后，就会根据该记录的主键值 执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些 </p>
<p>二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。 每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的 性能开销比较大。MySQL中提出了一个名为Disk-Sweep Multi-Range Read (MRR，多范围 读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执 行回表操作。 </p>
<p>相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个 MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。</p>
<h2 id="13-分库分表"><a href="#13-分库分表" class="headerlink" title="13.分库分表"></a>13.分库分表</h2><h2 id="14-分布式唯一id"><a href="#14-分布式唯一id" class="headerlink" title="14.分布式唯一id"></a>14.分布式唯一id</h2><h2 id="15-数据库三大范式是什么"><a href="#15-数据库三大范式是什么" class="headerlink" title="15.数据库三大范式是什么"></a>15.数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="16-InnoDB引擎的4大特性"><a href="#16-InnoDB引擎的4大特性" class="headerlink" title="16.InnoDB引擎的4大特性"></a>16.InnoDB引擎的4大特性</h2><p>插入缓冲（insert buffer)</p>
<p>二次写(double write)</p>
<p>自适应哈希索引(ahi)</p>
<p>预读(read ahead)</p>
<h2 id="17-索引失效的情况"><a href="#17-索引失效的情况" class="headerlink" title="17.索引失效的情况"></a>17.索引失效的情况</h2><p>谈到索引主要从两方面来分析：IO 和数据结构：不管索引数据还是行数据，都是存在磁盘里面的，我们尽可能少的取出数据</p>
<ul>
<li>IO—–&gt;读取次数少、量少——&gt;分块读取——&gt;局部性原理、磁盘预读</li>
<li>数据结构——&gt;B+树——&gt;二叉树、AVL树、红黑树、B树</li>
</ul>
<ol>
<li>组合索引不遵循最左匹配原则</li>
<li>组合索引前面索引列使用范围查询(&lt;,&gt;,like),会导致后续索引失效；</li>
<li>不要在索引上做任何操作（计算，函数，类型转换）</li>
<li>is null和is not null 无法使用索引</li>
<li>尽量少使用or操作符，否则连接时索引会失效</li>
<li>字符串不添加引号会导致索引失效（隐式类型转换）</li>
<li>两表关联使用的条件字段中字段的长度，编码不一致会导致索引失效</li>
<li>like语句中，以%开头的模糊查询会导致索引失效</li>
<li>如果mysql中使用全表扫描比索引快，也会导致索引失效 （force index:强制使用索引）</li>
</ol>
<h2 id="18-最左前缀原则。-联合索引使用分析实战"><a href="#18-最左前缀原则。-联合索引使用分析实战" class="headerlink" title="18.最左前缀原则。 联合索引使用分析实战"></a>18.最左前缀原则。 联合索引使用分析实战</h2><p>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p>实战？？</p>
<h2 id="19-sql优化之explain-详解"><a href="#19-sql优化之explain-详解" class="headerlink" title="19.sql优化之explain 详解"></a>19.sql优化之explain 详解</h2><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL </p>
<p>接下来我们将展示 explain 中每个列的信息</p>
<p><strong>19.1. id列</strong> </p>
<p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 </p>
<p>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。 </p>
<p><strong>19.2. select_type列</strong> </p>
<p>select_type 表示对应行是简单还是复杂的查询。 </p>
<p>1）simple：</p>
<p>简单查询。查询不包含子查询和union </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film where id = 2; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/T5Cula.png" alt="image-20220407160800996"></p>
<p>2）primary：</p>
<p>复杂查询中最外层的 select </p>
<p>3）subquery：</p>
<p>包含在 select 中的子查询（不在 from 子句中） </p>
<p>4）derived：</p>
<p>包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>用这个例子来了解 primary、subquery 和 derived 类型 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 </span><br><span class="line"></span><br><span class="line">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</span><br></pre></td></tr></table></figure>

<p> <img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/q2w4D3.png" alt="image-20220407161247159"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置 </span><br></pre></td></tr></table></figure>

<p>5）union：</p>
<p>在 union 中的第二个和随后的 select </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kCABNr.png" alt="image-20220407161256284"></p>
<p><strong>19.3. table列</strong> </p>
<p>这一列表示 explain 的一行正在访问哪个表。 </p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查 </p>
<p>询。</p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<p><strong>19.4. type列</strong> </p>
<p>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong> </p>
<p>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong> </p>
<p><strong>NULL</strong>：</p>
<p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可 </p>
<p>以单独查找索引来完成，不需要在执行时访问表 </p>
<p>1 mysql&gt; explain select min(id) from film; </p>
<p><strong>const, system</strong>：</p>
<p>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 </p>
<p>primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是</strong> </p>
<p><strong>const的特例</strong>，表里只有一条元组匹配时为system </p>
<p>1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp; </p>
<p>1 mysql&gt; show warnings; </p>
<p><strong>eq_ref</strong>：</p>
<p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 </p>
<p>const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。 </p>
<p>1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id; </p>
<p><strong>ref</strong>：</p>
<p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会 </p>
<p>找到多个符合条件的行。 </p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引） </li>
</ol>
<p>1 mysql&gt; explain select * from film where name = ‘film1’; </p>
<p>  2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。 </p>
<p>1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.fi </p>
<p>lm_id; </p>
<p><strong>range</strong>：</p>
<p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。 </p>
<p>1 mysql&gt; explain select * from actor where id &gt; 1;<strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接 </p>
<p>对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这 </p>
<p>种通常比ALL快一些。 </p>
<p>1 mysql&gt; explain select * from film; </p>
<p><strong>ALL</strong>：</p>
<p>即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。 </p>
<p>1 mysql&gt; explain select * from actor;</p>
<p><strong>19.5. possible_keys列</strong> </p>
<p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 </p>
<p>对此查询帮助不大，选择了全表查询。 </p>
<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 </p>
<p>高查询性能，然后用 explain 查看效果。 </p>
<p><strong>19.6. key列</strong> </p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force </p>
<p>index、ignore index。 </p>
<p><strong>19.7. key_len列</strong> </p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通 </p>
<p>过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id = 2; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/euMjk1.png" alt="image-20220407162337179"></p>
<p>key_len计算规则如下： </p>
<p><strong>字符串</strong>，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数，</strong>如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节 </p>
<p>​            char(n)：如果存汉字长度就是 3n 字节 </p>
<p>​            varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串 </p>
<p><strong>数值类型</strong></p>
<p>​            tinyint：1字节 </p>
<p>​            smallint：2字节 </p>
<p>​            int：4字节 </p>
<p>​            bigint：8字节 </p>
<p><strong>时间类型</strong></p>
<p>​            date：3字节timestamp：4字节 </p>
<p>​            datetime：8字节 </p>
<p>如果字段允许为 NULL，需要1字节记录是否为 NULL </p>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<p><strong>19.8. ref列</strong> </p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p>
<p><strong>19.9. rows列</strong> </p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </p>
<p><strong>19.10. Extra列</strong> </p>
<p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>1）<strong>Using index</strong>：使用覆盖索引 </p>
<p><strong>覆盖索引定义</strong>：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select film_id from film_actor where film_id = 1; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/HDa0QJ.png" alt="image-20220407162614921"></p>
<p>2）<strong>Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor where name = &#x27;a&#x27;; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TCOus4.png" alt="image-20220407162649995"></p>
<p>3）<strong>Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围； </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id &gt; 1; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/R67z2o.png" alt="image-20220407162726922"></p>
<p>4）<strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索 </p>
<p>引来优化。 </p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from actor; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/zN1qNX.png" alt="image-20220407162748356"></p>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from film; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TJBQvc.png" alt="image-20220407162804564"></p>
<p>5）<strong>Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。 </p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/bvNR53.png" alt="image-20220407162837176"></p>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index </li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film order by name; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/LmfAA3.png" alt="image-20220407162904215"></p>
<p>6）<strong>Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select min(id) from film; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/XKI9h9.png" alt="image-20220407162921288"></p>
<h2 id="20-mysql主从复制原理"><a href="#20-mysql主从复制原理" class="headerlink" title="20.mysql主从复制原理"></a>20.mysql主从复制原理</h2><ol>
<li><p>master提交完事务后，写入binlog</p>
</li>
<li><p>slave连接到master，获取binlog</p>
</li>
<li><p>master创建dump线程，推送binglog到slave</p>
</li>
<li><p>slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中</p>
</li>
<li><p>slave再开启一个sql线程读取relay log事件并在slave执行，完成同步</p>
</li>
<li><p>slave记录自己的binglog</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/yEQbgw.jpeg" alt="图片"></p>
</li>
</ol>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/wfHRhP.png"/>



<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="21-主从同步延时如何解决"><a href="#21-主从同步延时如何解决" class="headerlink" title="21.主从同步延时如何解决"></a>21.主从同步延时如何解决</h2><h2 id="22-隔离级别"><a href="#22-隔离级别" class="headerlink" title="22.隔离级别"></a>22.隔离级别</h2><p>首先回忆四种mysql隔离级别</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（Read uncommitted）</td>
<td>一个事务还没提交时，它做的变更就能被别的事务看到</td>
</tr>
<tr>
<td align="left">读提交（Read committed）</td>
<td>一个事务提交之后，它做的变更才会被其他事务看到。出 于性能考虑互联网公司会使用RC+乐观锁</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td>一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。<strong>InnoDB默认级别</strong>。</td>
</tr>
<tr>
<td align="left">串行化（Serializable ）</td>
<td>事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，隔离级别最高，牺牲系统并发性。</td>
</tr>
</tbody></table>
<p>查看当前数据库的事务隔离级别:show variables like ‘%tx_isolation%’;</p>
<p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p>
<p>不同的隔离级别是为了解决不同的问题。也就是脏读、幻读、不可重复读。</p>
<p><strong>脏读</strong>：事务A读取到了事务B已经修改但尚未提交的数据，。</p>
<p><strong>不可重复读</strong>：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。</p>
<p><strong>幻读</strong>：事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<p><strong>不可重复读&amp;&amp;幻读区别</strong></p>
<p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p>
<p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可以出现</td>
<td>可以出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>读提交</td>
<td>不允许出现</td>
<td>可以出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>可重复读</td>
<td>不允许出现</td>
<td>不允许出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>序列化</td>
<td>不允许出现</td>
<td>不允许出现</td>
<td>不允许出现</td>
</tr>
</tbody></table>
<p><strong>不同的隔离级别下，隔离性是靠锁机制和MVCC共同实现的。</strong></p>
<h2 id="23-RC和RR的本质区别。readview层面"><a href="#23-RC和RR的本质区别。readview层面" class="headerlink" title="23.RC和RR的本质区别。readview层面"></a>23.RC和RR的本质区别。readview层面</h2><p><strong>RC级别下每次都是重新生成read view，而在RR级别下则是一直使用事务内第一次查询时产生的read view。</strong></p>
<h2 id="24-什么是readview"><a href="#24-什么是readview" class="headerlink" title="24.什么是readview"></a>24.什么是readview</h2><p>ReadView可以理解为一个数据结构，在事务开始的时候会根据事务链表构造一个ReadView,初始化方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// readview 初始化</span><br><span class="line">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span><br><span class="line">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::memset(&amp;m_view_list, 0x0, sizeof(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>trx_ids</code>: 表示事务开启的时候, 其它未提交的活跃的事务ID. 这个集合中的事务对于当前事务来说, 一直都是不可见的.</p>
<p><code>low_limit_id</code>: 表示在生成ReadView时当前系统中最大事务id.</p>
<p><code>up_limit_id</code>: 表示未提交活跃事务Id(trx_ids)的最大值. 如果trx_ids为空, 则up_limit_id=low_limit_id.</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/vsg7bA.png" alt="readview"></p>
<p>通过该ReadView，新的事务可以根据查询到的所有活跃事务记录的事务ID来匹配能够看见该记录，从而实现数据库的事务隔离，主要逻辑如下：</p>
<p>通过聚簇索引的行结构中DB_TRX_ID隐藏字段可以知道最近被哪个事务ID修改过。一个新的事务开始时会根据事务链表构造一个ReadView。当前事务根据ReadView中的数据去跟检索到的每一条数据去校验,看看当前事务是不是能看到这条数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 判断数据对应的聚簇索引中的事务id在这个readview中是否可见</span><br><span class="line">bool changes_visible(</span><br><span class="line">        trx_id_t        id, // 记录的id</span><br><span class="line">    const table_name_t&amp; name) const</span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id &gt; 0);</span><br><span class="line">    // 如果当前记录id &lt; 事务链表的最小值或者等于创建该readview的id就是它自己,那么是可见的</span><br><span class="line">    if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    // 如果该记录的事务id大于事务链表中的最大值,那么不可见</span><br><span class="line">    if (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">        return(false);</span><br><span class="line">        // 如果事务链表是空的,那也是可见的</span><br><span class="line">    &#125; else if (m_ids.empty()) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ids_t::value_type*    p = m_ids.data();</span><br><span class="line"></span><br><span class="line">    //判断是否在ReadView中，如果在说明在创建ReadView时 此条记录还处于活跃状态则不应该查询到，否则说明创建ReadView是此条记录已经是不活跃状态则可以查询到</span><br><span class="line">    return(!std::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见性算法逻辑总结：</p>
<ol>
<li>当检索到的数据的事务ID小于事务链表中的最小值(数据行的DB_TRX_ID &lt; m_up_limit_id)表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li>
<li>当检索到的数据的事务ID表示的是当前事务自己修改的数据(数据行的DB_TRX_ID = m_creator_trx_id) 时，数据可见。</li>
<li>当检索到的数据的事务ID大于事务链表中的最大值(数据行的DB_TRX_ID &gt;= m_low_limit_id) 表示这个数据在当前事务开启后到下一次查询之间又被其他的事务修改过,那么就是不可见的。</li>
<li>如果事务链表为空,那么也是可见的,也就是当前事务开始的时候,没有其他任意一个事务在执行。</li>
<li>当检索到的数据的事务ID在事务链表中的最小值和最大值之间，从m_low_limit_id到m_up_limit_id进行遍历，取出DB_ROLL_PTR指针所指向的回滚段的事务ID，把它赋值给 trx_id_current ，然后从步骤1重新开始判断，这样总能最后找到一个可用的记录。</li>
</ol>
<h2 id="25-快照读与当前读的区别"><a href="#25-快照读与当前读的区别" class="headerlink" title="25.快照读与当前读的区别"></a>25.快照读与当前读的区别</h2><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<p><strong>快照读</strong>：就是select</p>
<ul>
<li>select * from table ….;</li>
</ul>
<p><strong>当前读</strong>：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert;</li>
<li>update ;</li>
<li>delete;</li>
</ul>
<h2 id="26-幻读和不可重复读区别"><a href="#26-幻读和不可重复读区别" class="headerlink" title="26.幻读和不可重复读区别"></a>26.幻读和不可重复读区别</h2><p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p>
<p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p>
<h2 id="27-MySQL在RR级别中完全解决了幻读的问题么？"><a href="#27-MySQL在RR级别中完全解决了幻读的问题么？" class="headerlink" title="27.MySQL在RR级别中完全解决了幻读的问题么？"></a>27.MySQL在RR级别中完全解决了幻读的问题么？</h2><h2 id="28-脏页是什么，刷脏页时机"><a href="#28-脏页是什么，刷脏页时机" class="headerlink" title="28.脏页是什么，刷脏页时机"></a>28.脏页是什么，刷脏页时机</h2><h2 id="29-bufferpool"><a href="#29-bufferpool" class="headerlink" title="29.bufferpool"></a>29.bufferpool</h2><h2 id="30-几大核心线程"><a href="#30-几大核心线程" class="headerlink" title="30.几大核心线程"></a>30.几大核心线程</h2><p><strong>purge线程</strong></p>
<p>对于一条delete语句 delete from t where a = 1，如果列a有聚集索引，则不会进行真正的删除，而只是在主键列等于1的记录delete flag设置为1，即记录还是存在在B+树中。而对于update操作，不是直接对记录进行更新，而是标识旧记录为删除状态，然后新产生一条记录。那这些旧版本标识位删除的记录何时真正的删除？怎么删除？</p>
<p>其实InnoDB是通过undo日志来进行旧版本的删除操作的，在InnoDB内部，这个操作被称之为purge操作，原来在srv_master_thread主线程中完成，后来进行优化，开辟了purge线程进行purge操作，并且可以设置purge线程的数量。purge操作每10s进行一次。</p>
<p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行连接，如下面的一种情况：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Zxv9V3.png" alt="purge"></p>
<p>在执行purge过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1所在的Undo page中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故再去history list中取查找，发现最尾端的记录时trx2，接着找到trx2所在的Undo page，依次把trx6、trx4清理，由于Undo page2中所有的记录都被清理了，因此该Undo page可以进行重用。</p>
<p>InnoDB存储引擎这种先从history list中找undo log，然后再从Undo page中找undo log的设计模式是为了避免大量随机读操作，从而提高purge的效率。</p>
<h2 id="31-事务传播机制"><a href="#31-事务传播机制" class="headerlink" title="31.事务传播机制"></a>31.事务传播机制</h2><h2 id="32-分布式事务通用方案"><a href="#32-分布式事务通用方案" class="headerlink" title="32.分布式事务通用方案"></a>32.分布式事务通用方案</h2><h2 id="33-成本分析"><a href="#33-成本分析" class="headerlink" title="33.成本分析"></a>33.成本分析</h2><h2 id="34-表中数据量如何计算总量"><a href="#34-表中数据量如何计算总量" class="headerlink" title="34.表中数据量如何计算总量"></a>34.表中数据量如何计算总量</h2><h2 id="35-count-1-count-count-id-count-字段-性能对比分析"><a href="#35-count-1-count-count-id-count-字段-性能对比分析" class="headerlink" title="35.count(1) count(*) count(id) count(字段) 性能对比分析"></a>35.count(1) count(*) count(id) count(字段) 性能对比分析</h2><p><strong>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</strong> </p>
<p><strong>字段有索引：count(*)≈count(1)&gt;count(字段)&gt;count(主键 id) //字段有索引，count(字段)统计走二级索引，二</strong> </p>
<p><strong>级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</strong> </p>
<p><strong>字段无索引：count(*)≈count(1)&gt;count(主键 id)&gt;count(字段) //字段没有索引count(字段)统计走不了索引，</strong> </p>
<p><strong>count(主键 id)还可以走主键索引，所以count(主键 id)&gt;count(字段)</strong> </p>
<p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出 </p>
<p>字段，所以理论上count(1)比count(字段)会快一点。 </p>
<p>count(*) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用 </p>
<p>count(列名)或count(常量)来替代 count(*)。 </p>
<p>为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引？因为二级索引相对主键索引存储数据更少，检索 </p>
<p>性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)。 </p>
<h2 id="36-mysql中in-和exists-区别"><a href="#36-mysql中in-和exists-区别" class="headerlink" title="36.mysql中in 和exists 区别"></a>36.mysql中in 和exists 区别</h2><h2 id="37-join查询原理"><a href="#37-join查询原理" class="headerlink" title="37.join查询原理"></a>37.join查询原理</h2><h2 id="38-索引下推"><a href="#38-索引下推" class="headerlink" title="38.索引下推"></a>38.索引下推</h2><p><strong>索引下推</strong>（Index Condition Pushdown，<strong>ICP</strong>), like KK%其实就是用到了索引下推优化 </p>
<p><strong>什么是索引下推了？</strong> </p>
<p>对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，<strong>SELECT * FROM employees WHERE name like ‘LiLei%’</strong> </p>
<p><strong>AND age = 22 AND position =’manager’</strong> 这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和 </p>
<p>position是无序的，无法很好的利用索引。 </p>
<p>在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索 </p>
<p>引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。 </p>
<p>MySQL 5.6引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可</strong> </p>
<p><strong>以有效的减少回表次数</strong>。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过 </p>
<p>滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。 </p>
<p>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全 </p>
<p>行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。 </p>
<p><strong>个人理解升华：</strong></p>
<p>我觉得like是这样，用到索引下推的场景，直接利用三个索引都过滤玩，然后回表查数据;</p>
<p>关闭索引下推，利用的第一个索引完成过滤，直接回表，然后继续在server层对第二三字段过滤,都是用到了三个字段，但是第二三个字段用的地方不一样</p>
<p><strong>为什么范围查找Mysql没有用索引下推优化？</strong> </p>
<p>然后理论上like和大于小于都是range类型，只不过大于小于这种有点正负无穷的感觉，所以mysql没有特殊处理，like ‘xx%’ mysql默认认为范围可控，就使用刚才的逻辑来处理，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。 </p>
<h2 id="39-两种排序方式"><a href="#39-两种排序方式" class="headerlink" title="39.两种排序方式"></a>39.两种排序方式</h2><p>1、MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index </p>
<p>效率高，filesort效率低。</p>
<h2 id="40-filesort排序原理"><a href="#40-filesort排序原理" class="headerlink" title="40.filesort排序原理"></a>40.filesort排序原理</h2><p><strong>Using filesort文件排序原理详解</strong> </p>
<p><strong>filesort文件排序方式</strong> </p>
<p>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可 </p>
<p>以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, </p>
<p>packed_additional_fields &gt; </p>
<p>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong> </p>
<p><strong>数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具 </p>
<p>可以看到sort_mode信息里显示&lt; sort_key, rowid &gt; </p>
<p>MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来 </p>
<h2 id="41-filesort判断使用哪种排序模式。-（单路or双路）"><a href="#41-filesort判断使用哪种排序模式。-（单路or双路）" class="headerlink" title="41.filesort判断使用哪种排序模式。 （单路or双路）"></a>41.filesort判断使用哪种排序模式。 （单路or双路）</h2><p>如果 字段的总长度小于max_length_for_sort_data ，那么使用 单路排序模式； </p>
<p>如果 字段的总长度大于max_length_for_sort_data ，那么使用 双路排序模∙式。 </p>
<h2 id="40-单路排序、双路排序详细过程"><a href="#40-单路排序、双路排序详细过程" class="headerlink" title="40.单路排序、双路排序详细过程"></a>40.单路排序、双路排序详细过程</h2><p>我们先看<strong>单路排序</strong>的详细过程： </p>
<ol>
<li><p>从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id </p>
</li>
<li><p>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中 </p>
</li>
<li><p>从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id </p>
</li>
<li><p>重复步骤 2、3 直到不满足 name = ‘zhuge’ </p>
</li>
<li><p>对 sort_buffer 中的数据按照字段 position 进行排序 </p>
</li>
<li><p>返回结果给客户端 </p>
</li>
</ol>
<p>我们再看下<strong>双路排序</strong>的详细过程： </p>
<ol>
<li><p>从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id </p>
</li>
<li><p>根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中 </p>
</li>
<li><p>从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id </p>
</li>
<li><p>重复 3、4 直到不满足 name = ‘zhuge’ </p>
</li>
<li><p>对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序 </p>
</li>
<li><p>遍历排序好的 id 和字段 position，按照 id 的值<strong>回到原表</strong>中取出 所有字段的值返回给客户端 </p>
</li>
</ol>
<p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p>
<h2 id="41-三星索引"><a href="#41-三星索引" class="headerlink" title="41.三星索引"></a>41.三星索引</h2><p>对于一个查询而言，一个三星索引，可能是其最好的索引。</p>
<p>索引将相关的记录放到一起则获得一星； </p>
<p>如果索引中的数据顺序和查找中的排列顺序一致则获得二星； </p>
<p>如果索引中的列包含了查询中需要的全部列则获得三星。 </p>
<h2 id="42-场景题"><a href="#42-场景题" class="headerlink" title="42.场景题"></a>42.场景题</h2><p>新建一张数据表user，后续所有操作都依托于初始化的这三条数据。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
</tbody></table>
<hr>
<p>操作1：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;<br>commit;</td>
</tr>
<tr>
<td>3</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
</tbody></table>
<p>此时不管是RC还是RR，t1的select都能够读取到t2update的值</p>
<p>因为在t1select的时刻才会去生成read view，根据可见性算法得出能看到最新的t2数据</p>
<hr>
<p>操作2:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>2</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;<br/>commit;</td>
</tr>
<tr>
<td>4</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
</tbody></table>
<p>此时RC级别下，t1的 第二次select能够查看到t2update的值，因为RC级别下每次select都会生成新的read view</p>
<p>在RR级别下，t1的 第二次不能查询到t2update的值，因为RR级别下的后面查询都是使用的第一次select生成的read view</p>
<p>同理，t2语句为insert时也是一样的情况。</p>
<hr>
<p>操作3:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into user values (4,’haha’,3);<br/>waiting~~~</td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>插入成功<br>commit;</td>
</tr>
</tbody></table>
<p>RR级别下，t1进行当前读时，会对数据加锁，具体是间隙锁｜行锁｜next-key，后面细说，此时t2的插入会waiting，直到t1释提交事务，来解决insert情况下的幻读问题</p>
<hr>
<p>那么，感觉RR就已经解决了幻读，为啥还需要串行化（Serializable ）？？？</p>
<p>操作4:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td></td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into user values (4,’haha’,1);<br/>commit;</td>
</tr>
<tr>
<td>5</td>
<td>update user set name=’zhangsan2’ where age=1;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>RR级别下，此时想象中的结果为下面，因为实际上在第五行如果不是update而是select，是肯定差不到新数据的</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>haha</td>
<td>1</td>
</tr>
</tbody></table>
<p>但是实际的数据库中结果为：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
</tbody></table>
<p>其实在 MySQL在RR级别中并不是完全解决了幻读的问题，对照操作2中t2使用insert、操作3、以及操作4可以看出某些场景下RR解决了幻读，但是MVCC 对于幻读的解决是不彻底的。（快照读和当前读的混合使用会产生幻读问题）</p>
<h1 id="四、缓存-Redis"><a href="#四、缓存-Redis" class="headerlink" title="四、缓存:Redis"></a>四、缓存:Redis</h1><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/FnBZnt.png"/>

<ol>
<li><p><strong>String</strong></p>
</li>
<li><p><strong>Hash</strong></p>
</li>
<li><p><strong>List</strong>：类似于数组</p>
</li>
<li><p><strong>Set</strong>：无序集合 用户列表，求集合的交集，并集等操作</p>
</li>
<li><p><strong>ZSet</strong>：有序集合</p>
<ul>
<li><p>1）点击新闻：ZINCRBY  hotNews:20190819  1  守护香港</p>
</li>
<li><p>2）展示当日排行前十：ZREVRANGE  hotNews:20190819  0  9  WITHSCORES </p>
</li>
<li><p>3）七日搜索榜单计算：ZUNIONSTORE  hotNews:20190813-20190819  7  hotNews:20190813  hotNews:20190814… hotNews:20190819</p>
</li>
<li><p>4）展示七日排行前十：ZREVRANGE hotNews:20190813-20190819  0  9  WITHSCORES</p>
</li>
</ul>
</li>
</ol>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/GdNIzS.png"/>

<h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3><p>Redis基于Reactor模式开发的网络事件处理器，这个文件事件处理器是单线程的，采用IO多路复用机制监听多个Socker，根据Socker上的事件类型选择对应的事件处理器处理这个事件，可以实现高性能的网络通信。文件事件处理器包含4个部分，多个Socker，IO多路复用程序，文件事件分派器和事件处理器(命令请求处理器，命令回复处理器，链接应答处理器)，多个Socket可能并发产生不同操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Socket，会将Socket放入一个队列，每次从队列中取出一个Socket给时间分派器，时间分派器把Socket给对应的事件处理器。</p>
<p>单线程快的原因：1.纯内存操作；2.核心是基于非阻塞的IO多路复用机制；3.单线程反而避免多线程的频繁上下文切换</p>
<h3 id="分布式锁怎么实现的？"><a href="#分布式锁怎么实现的？" class="headerlink" title="分布式锁怎么实现的？"></a>分布式锁怎么实现的？</h3><ol>
<li>基于数据库实现分布式锁：唯一索引，状态机唯一联合索引</li>
<li>基于缓存（Redis等）实现分布式锁：SET key value NX PX 30000</li>
<li>基于Zookeeper实现分布式锁；</li>
</ol>
<h3 id="setnx用到的参数"><a href="#setnx用到的参数" class="headerlink" title="setnx用到的参数"></a>setnx用到的参数</h3><p><code>SET key value NX PX 30000</code></p>
<p>第三个参数：把key、value set到redis中的策略</p>
<ul>
<li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li>
<li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li>
</ul>
<p>第四个参数：过期时间单位</p>
<ul>
<li>  ex ：seconds 秒</li>
<li>  px : milliseconds 毫秒</li>
</ul>
<p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error </p>
<p>第五个参数：有两种可选的值，</p>
<p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p>
<h3 id="缓存穿透，击穿，雪崩"><a href="#缓存穿透，击穿，雪崩" class="headerlink" title="缓存穿透，击穿，雪崩"></a>缓存穿透，击穿，雪崩</h3><ul>
<li><font color='red'>缓存雪崩</font>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol>
<li>过期时间随机，防止同一时间大量数据过期</li>
<li>缓存预热：项目启动加载缓存到redis</li>
<li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li>
<li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li>
</ol>
</li>
<li><font color='red'>缓存穿透</font>：指数据库没有数据，导致请求落到数据库上<ol>
<li>接口层增加校验，对id进行规则拦截</li>
<li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li>
<li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li>
</ol>
</li>
<li><font color='red'>缓存击穿</font>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol>
<li>key不过期</li>
<li>加互斥锁</li>
</ol>
</li>
</ul>
<h3 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h3><p>Redis对于过期键有三种清除策略：</p>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批<strong>已过期</strong>的key</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清理策略</strong></li>
</ol>
<p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）</p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p>
<ol>
<li>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</li>
<li>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</li>
</ol>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ol>
<li>RDB快照(snapshot)<ol>
<li>Redis 将内存数据快照保存在名字为 dump.rdb 的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据；**# save 60 1000    //** (60秒改1000次进行一次RDB持久化)关闭RDB只需要将所有的save保存策略注释掉即可。</li>
<li>问题：会阻塞客户端命令。</li>
<li>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</li>
<li><strong>bgsave的写时复制(COW)机制</strong>：Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，在这个过程中，主线程仍然可以修改原来的数据。</li>
</ol>
</li>
<li>AOF(append-only file)<ol>
<li>如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将<strong>修改的</strong>每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</li>
</ol>
</li>
</ol>
<h3 id="缓存与数据库数据一致性"><a href="#缓存与数据库数据一致性" class="headerlink" title="缓存与数据库数据一致性"></a>缓存与数据库数据一致性</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/HwOLrx.png" />

<p>解决方案：</p>
<ol>
<li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li>
<li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ol>
<h1 id="五、MQ"><a href="#五、MQ" class="headerlink" title="五、MQ"></a>五、MQ</h1><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/dvvBBU.png" />

<h3 id="Rabbitmq生产高可用怎么实现的"><a href="#Rabbitmq生产高可用怎么实现的" class="headerlink" title="Rabbitmq生产高可用怎么实现的"></a>Rabbitmq生产高可用怎么实现的</h3><ol>
<li>生产部署为集群模式：避免单机模式下MQ服务器挂了导致服务不可用，还可以承载更高的并发量，但是集群模式有个问题，就是在哪个节点上创建队列，该队列只会存在该节点上，其他集群节点不会备份该队列，一旦该节点宕机，该队列中的消息就会丢失(亲测设置持久化也丢失)</li>
<li>使用镜像队列：可以解决集群模式下，每个机器上只有一个队列的问题，让消息在其他节点再备份一份。开启方式：任何节点添加policy策略即可，该集群就具有镜像队列能力，可设置备份的份数和备份队列规则，即使其中一个节点宕机，也会保证整个集群中保存2份</li>
<li>高可用负载均衡：haproxy+keepalive，nginx，lvs等实现高可用负载均衡</li>
<li>其他：Federation Exchange联邦交换机插件解决两地接受消息确认消息延迟问题，也可以用Shovel来做数据同步，需要安装插件</li>
</ol>
<h1 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h1><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>死锁：是指一组互相竞争资源的线程，因为互相等待，导致永久阻塞的现象。</p>
</li>
<li><p>原因：必须同时满足以下四个条件</p>
<ol>
<li>共享互斥条件：共享资源x和y只能被一个线程占用</li>
<li>占有且等待：线程t1已经占有共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占：其他线程不能强行抢占线程t1占有的资源</li>
<li>循环等待：线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源</li>
</ol>
</li>
<li><p>如何避免死锁：</p>
<ol>
<li>既然产生死锁必然满足四个条件，那我们只要打破四个条件中的一个就可以避免，第一个互斥条件是无法被破坏的，因为锁本身就是通过互斥来解决线程安全的</li>
<li>针对后三个条件，我们逐一分析，占有且等待这个条件我们可以一次性申请所有资源，不存在等待；</li>
<li>不可抢占这个条件：占有部分资源的线程进一步申请其他资源的时候如果申请不到，可以主动释放已占有的资源，这样不可抢占这条件就破坏了；</li>
<li>循环等待这个条件：可以按照顺序去申请资源进行预防，就是说资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，线性化之后，就不存在循环等待了</li>
</ol>
</li>
</ul>
<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法</li>
<li>sleep方法不会释放锁，但是wait会释放，而且会加入到等待队列中</li>
<li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li>
<li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li>
<li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信</li>
<li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li>
</ol>
<p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</p>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<h3 id="Volitile作用"><a href="#Volitile作用" class="headerlink" title="Volitile作用"></a>Volitile作用</h3><ol>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。内存屏障-&gt;汇编Lock关键字-&gt;缓存一致性协议</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性</li>
</ol>
<h3 id="Volitile如何保证可见性"><a href="#Volitile如何保证可见性" class="headerlink" title="Volitile如何保证可见性"></a>Volitile如何保证可见性</h3><ol>
<li><strong>缓存一致性：</strong>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据在主内存和各处理器私有缓存同时存在。当数据的一个副本发生更改，其他副本需要感知到最新修改数据。缓存一致性的手段主要有：</li>
<li>总线锁定：总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li>
<li>总线窥探(Bus snooping)：是缓存中的一致性控制器窥探总线事务的一种方案（该方案由Ravishankar和Goodman于1983年提出）当数据被多个缓存共享时，一个处理器修改了共享数据的值，可以是刷新缓存块或使缓存块失效还可以通过缓存块状态的改变，来达到缓存一致性的目的，主要取决于窥探协议类型：<ol>
<li>写失效（Write-invalidate） ：当一个处理器写入共享缓存时，其他缓存中的所有共享副本都会通过总线窥探失效。确保处理器只能读写一个数据副本，其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</li>
<li>写更新（Write-update）：当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比写失效协议引起更大的总线流量，因此这种方法不常见。Dragon和firefly协议属于此类别。</li>
</ol>
</li>
</ol>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>Java语言规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义：：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行状态+运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p>在操作系统层面，有五种状态，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p>
<h3 id="linux查看线程命令"><a href="#linux查看线程命令" class="headerlink" title="linux查看线程命令"></a>linux查看线程命令</h3><ul>
<li><p>ps  - fe 查看所有进程</p>
</li>
<li><p>ps  - fT  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>kill 杀死进程</p>
</li>
<li><p>top 按大写  H  切换是否显示线程</p>
</li>
<li><p>top  - H  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>jps 命令查看所有  Java  进程</p>
</li>
<li><p>jstack <PID> 查看某个  Java  进程（ PID ）的所有线程状态</p>
</li>
<li><p>jconsole 来查看某个  Java  进程中线程的运行情况（图形界面）</p>
</li>
</ul>
<h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><ol>
<li>方式1：使用 Thread类或继承Thread类</li>
<li>实现 Runnable 接口配合Thread</li>
<li>使用有返回值的 Callable，借助线程池使用</li>
<li>使用 lambda</li>
</ol>
<p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p>
<h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><p><strong>sleep方法</strong></p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态，不会释放对象锁</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并且会清除中断标志</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>sleep当传入参数为0时，和yield相同</li>
</ul>
<p><strong>yield方法</strong></p>
<ul>
<li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li>
<li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
<h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal<br>实例，value为线程变量的副本</p>
<h3 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h3><ol>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，Session会话管理。<ul>
<li>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</li>
</ul>
</li>
</ol>
<h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><ol>
<li>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li>
<li>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</li>
<li>ThreadLocal正确的使用方法<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任<br>何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</li>
</ol>
<h3 id="synchronized和ReentranLock区别？"><a href="#synchronized和ReentranLock区别？" class="headerlink" title="synchronized和ReentranLock区别？"></a>synchronized和ReentranLock区别？</h3><p>synchronized是jvm层面的关键字，底层是通过monitor对象来完成，monitor对象底层依赖于操作系统的Mutex互斥量，底层调用的是操作系统的Pthread库，是由操作系统来维护的，而操作系统分为用户空间和内核空间的，JVM运行在用户空间，调用底层操作系统cpu会进行一轮状态切换，这个状态切换是比较重型操作，wait/notify等方法也依赖monitor对象只有在同步块或方法中才能调wait/notify等方法。</p>
<p>Lock是具体类（java.util.concurrent.Locks.Lock)是api层面的锁，是从jdk1.5开始引入的，那个时候synchronized性能还比较差，ReentranLock的出现是为了解决当时性能差的问题</p>
<ul>
<li><p>使用方法：synchronized不需要手动释放锁，ReentranLock则需要用户手动释放锁(需要lock()和unlock()配合try/finally使用)</p>
</li>
<li><p>等待是否可中断：synchronized不可中断，除非抛出异常或者执行完成，ReentranLock可中断</p>
</li>
</ul>
<ol>
<li>设置超时方法tryLock(long timeout, timeUnit unit)</li>
<li>lockInterruptibly()放代码块忠，调用interrupt()方法可中断</li>
</ol>
<ul>
<li><p>加锁是否公平：synchronized非公平锁；ReentranLock 两者都可以，默认非公平锁，构造方法传入true为公平锁，false为非公平锁</p>
</li>
<li><p>锁绑定多个条件Condition：synchronized 没有；ReentranLock  用来实现分组唤醒需要唤醒的线程，可以精确唤醒，不像synchronized要么随机唤醒一个线程，要么全部唤醒</p>
</li>
</ul>
<h3 id="线程池参数有，核心线程配置，原因？"><a href="#线程池参数有，核心线程配置，原因？" class="headerlink" title="线程池参数有，核心线程配置，原因？"></a>线程池参数有，核心线程配置，原因？</h3><ol>
<li>corePoolSize：线程池中的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务</li>
<li>keepAliveTime：核心线程外的线程存活超时时间</li>
<li>unit：时间单位</li>
<li>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口</li>
<li>threadFactory：用来创建新线程</li>
<li>线程池的饱和策略：( AbortPolicy：直接抛出异常，默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务)</li>
</ol>
<p><strong>CPU密集型（CPU-bound）</strong></p>
<p>CPU密集型也叫计算密集型，在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p><font color=red face="黑体">线程数 = CPU核数+1 (现代CPU支持超线程)</font> </p>
<p><strong>IO密集型（I/O bound）</strong></p>
<p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</p>
<p> <font color=red face="黑体">线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</font> </p>
<h1 id="七、spring"><a href="#七、spring" class="headerlink" title="七、spring"></a>七、spring</h1><p>spring是一个框架，更像是一个生态环境，在我们的开发流程中，所有的框架基本上都依赖于spring，spring起到了一个IOC容器的作用，用来承载我们整体的bean对象，它帮我们处理了bean对象从创建到销毁的整个生命周期的管理，我们在使用spring的时候，可以使用配置文件，也可以使用注解的方式进行相关开发。spring框架的工作主要流程是，当我们程序开始启动之后，spring把注解或者配置文件定义好的bean对象转化成为BeanDefinitionran，然后通BeanFactoryPostProcessor完成整个的BeanDefinitionran的解析和加载过程，然后根据BeanDefinitionran通过反射的方式创建bean对象，然后进行对象初始化，包括：aware接口相关操作，BeanPostProcessor操作，Init-methord操作完成整个bean的创建过程，之后我们就可以使用了。</p>
<h3 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uEApmP.png"  />



<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uyP4Yq.png"/>



<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="AOP的顺序"><a href="#AOP的顺序" class="headerlink" title="AOP的顺序"></a>AOP的顺序</h3><p>  spring4和spring5是不一样的</p>
<h3 id="springMVC处理请求流程"><a href="#springMVC处理请求流程" class="headerlink" title="springMVC处理请求流程"></a>springMVC处理请求流程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/ig6fc0.png" />

<h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><ol>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：支持当前事务，如果没有事务会创建一个新的事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果没有事务的话以非事务方式执行</li>
<li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：支持当前事务，如果没有事务抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：创建一个新的事务并挂起当前事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务则将当前事务挂起</li>
<li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：以非事务方式进行，如果存在事务则抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<h1 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h1><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul>
<li>第一层：物理层</li>
<li>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY </li>
<li>第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP </li>
<li>第四层：传输层 TCP、UDP、SPX </li>
<li>第五层：会话层 <strong>RPC</strong>、SQL、NFS 、X WINDOWS、ASP</li>
<li>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG </li>
<li>第七层：应用层 HTTP,FTP,SNMP等</li>
</ul>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/jafyuK.png"/>

<ol>
<li>物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；</li>
<li>数据链路层：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控。可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</li>
<li>网络层：网络层负责在源和终点之间建立连接。可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</li>
<li>传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</li>
<li>会话层：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;</li>
<li>表示层：表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</li>
<li>应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;</li>
</ol>
<h3 id="http1-0和http1-1区别"><a href="#http1-0和http1-1区别" class="headerlink" title="http1.0和http1.1区别"></a>http1.0和http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h3 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>
</ul>
<h3 id="http三次握手四次挥手"><a href="#http三次握手四次挥手" class="headerlink" title="http三次握手四次挥手"></a>http三次握手四次挥手</h3><p>其实这么说是不太准确的，应该说是tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说，tcp可以提供全双工的数据流传输服务</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h1 id="十、Dubbo"><a href="#十、Dubbo" class="headerlink" title="十、Dubbo"></a>十、Dubbo</h1><h3 id="你知道的json序列化方式？"><a href="#你知道的json序列化方式？" class="headerlink" title="你知道的json序列化方式？"></a>你知道的json序列化方式？</h3><ol>
<li>谷歌的Gson</li>
<li>json-smart：号称是速度最快的JSON解析器</li>
<li>Common Lang3(3.1)的SerializationUtils</li>
<li>阿里巴巴的 FastJson、以及 Jackson</li>
</ol>
<h3 id="两个系统之间怎么交互的？"><a href="#两个系统之间怎么交互的？" class="headerlink" title="两个系统之间怎么交互的？"></a>两个系统之间怎么交互的？</h3><ol>
<li> 套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
<li> 可以通过RPC框架（dubbo、feign等）进行远程调用</li>
<li> 也可以引入消息队列等消息中间件作为系统之间信息交互的桥梁</li>
<li> 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更</li>
</ol>
<h3 id="dubbo的序列化？"><a href="#dubbo的序列化？" class="headerlink" title="dubbo的序列化？"></a>dubbo的序列化？</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。 hessian 是其默认的序列化协议</p>
<p>dubbo</p>
<ul>
<li>提供者(Provider)启动时，会向注册中心写入自己的元数据信息(调用方式)。</li>
<li>消费者(Consumer)启动时，也会在注册中心写入自己的元数据信息，并且订阅服务提供者，路由和配置元数据的信息。</li>
<li>服务治理中心(duubo-admin)启动时，会同时订阅所有消费者，提供者，路由和配置元数据的信息。</li>
<li>当提供者离开或者新提供者加入时，注册中心发现变化会通知消费者和服务治理中心。</li>
</ul>
<h1 id="十一、Netty"><a href="#十一、Netty" class="headerlink" title="十一、Netty"></a>十一、Netty</h1><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p> <strong>Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</strong></p>
<ol>
<li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li>
<li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li>
<li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li>
</ol>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现boss和work两个线程池，其中boss的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，交由对应的Handler处理。</p>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5cJC8M.png" />

<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5N67yC.png"/> 

<ol>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</li>
<li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li>
<li>NioEventLoopGroup 相当于一个事件循环<strong>线程组</strong>, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</li>
<li>每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</li>
<li> 每个BossNioEventLoop线程内部循环执行的步骤有 3 步</li>
<li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li>
<li>将NioSocketChannel注册到某个worker  NIOEventLoop上的selector</li>
<li>处理任务队列的任务 ， 即runAllTasks</li>
<li>每个workerNIOEventLoop线程循环执行的步骤<ol>
<li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件</li>
<li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务</li>
<li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处理，这样不影响数据在 pipeline 中的流动处理</li>
</ol>
</li>
</ol>
<h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul>
<li><p><strong>Bootstrap、ServerBootstrap</strong>：Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
</li>
<li><p><strong>Future、ChannelFuture</strong>：正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
</li>
<li><p><strong>Channel</strong>：Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ol>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
</li>
<li><p>网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p>
</li>
<li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p>
</li>
<li><p>支持关联 I/O 操作与对应的处理程序。</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p>
</li>
<li><pre><code>NioSocketChannel，异步的客户端 TCP Socket 连接。
NioServerSocketChannel，异步的服务器端 TCP Socket 连接。
NioDatagramChannel，异步的 UDP 连接。
NioSctpChannel，异步的客户端 Sctp 连接。
NioSctpServerChannel，异步的 Sctp 服务器端连接。
这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。
</code></pre>
</li>
</ol>
</li>
<li><p><strong>Selector</strong>：Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
</li>
<li><p><strong>NioEventLoop</strong>：NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p>
</li>
<li><p><strong>NioEventLoopGroup</strong>：NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p>
</li>
<li><p><strong>ChannelHandler</strong>：ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p>
</li>
<li><p><strong>ChannelHandlerContext</strong>：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p>
</li>
<li><p><strong>ChannelPipline</strong>：保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
</li>
</ul>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/OnweVR.png"/> 

<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p>
</li>
<li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</p>
</li>
<li><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p>
<p>Netty提供了多个解码器，可以进行分包的操作，如下：</p>
<ol>
<li>LineBasedFrameDecoder （回车换行分包）</li>
<li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li>
<li>FixedLengthFrameDecoder（固定长度报文来分包）</li>
</ol>
</li>
</ol>
<h1 id="十二、zookeeper"><a href="#十二、zookeeper" class="headerlink" title="十二、zookeeper"></a>十二、zookeeper</h1><h4 id="zookeeper的理解"><a href="#zookeeper的理解" class="headerlink" title="zookeeper的理解"></a>zookeeper的理解</h4><ol>
<li>集群管理：提供了CP模型来保证集群中每个节点的数据一致性</li>
<li>分布式锁</li>
<li>集群选举</li>
</ol>
<h4 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h4><ul>
<li>LeaderElection  </li>
<li>AuthFastLeaderElection</li>
<li>FastLeaderElection （最新默认）</li>
</ul>
<p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ul>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。</li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li>
<li>服务器5启动，后面的逻辑同服务器4成为小弟。</li>
</ul>
<h1 id="十三、理论"><a href="#十三、理论" class="headerlink" title="十三、理论"></a>十三、理论</h1><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>​        CAP 理论又叫 Brewer 理论，这是加州大学伯克利分校的埃里克 · 布鲁尔（Eric Brewer）教授，在 2000 年 7 月“ACM 分布式计算原理研讨会（PODC）”上提出的一个猜想。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~brewer%2Fcs262b-2004%2FPODC-keynote.pdf">CAP理论原稿</a>（那时候还只是猜想）然后到了 2002 年，麻省理工学院的赛斯 · 吉尔伯特（Seth Gilbert）和南希 · 林奇（Nancy Lynch）就以严谨的数学推理证明了这个 CAP 猜想。在这之后，CAP 理论就正式成为了分布式计算领域公认的著名定理。这个定理里，描述了一个分布式的系统中，当涉及到共享数据问题时，以下三个特性最多只能满足其中两个：</p>
<ol>
<li>一致性（Consistency）：代表在任何时刻、任何分布式节点中，我们所看到的数据都是没有矛盾的。这与 ACID 中的 C 是相同的单词，但它们又有不同的定义（分别指 Replication 的一致性和数据库状态的一致性）。在分布式事务中，ACID 的 C 要以满足 CAP 中的 C 为前提。</li>
<li>可用性（Availability）：代表系统不间断地提供服务的能力。</li>
<li>分区容忍性（Partition Tolerance）：代表分布式环境中，当部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</li>
</ol>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>ddd不是一种架构风格，而是一种方法论，什么是方法论，每个人按照自己的想法来设计就是一套方法论；ddd是一种业务比较认可，对于微服务拆分的一种方法论。</p>
<h1 id="十四、项目"><a href="#十四、项目" class="headerlink" title="十四、项目"></a>十四、项目</h1><ol>
<li>最近做的比较熟悉的项目是哪个？画一下项目技术架构图</li>
<li>写两个类，能够实现堆内存溢出和栈内存溢出</li>
<li>写一个线程安全的单例。</li>
<li>两个可变有序链表放到新数组中，有序</li>
</ol>
<h3 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h3><p>ES他是建立在全文搜索引擎库ApacheLucene基础上的一个开源搜索和分析引擎，ES本身具有一个分布式存储，检索速度快的特性，所以我们经常用它去实现全文检索这一类的场景，比如像网站搜索，公司内部用ELK做日志聚集和检索，来去快速查找服务器的日志记录，去定位问题，基本上涉及到TB级别的数据场景，用ES是一个比较好的选择</p>
<h4 id="ES查询快的原因"><a href="#ES查询快的原因" class="headerlink" title="ES查询快的原因"></a>ES查询快的原因</h4><ol>
<li>第一、Lucene是擅长管理大量的索引数据的，另一方面他会对数据进行分词以后在保存索引，这样能搞提升数据的检索效率</li>
<li>第二、ES采用倒排索引，所谓倒排索引，就是通过属性值来确定数据记录的位置的索引，来避免全表扫描这样一个问题，</li>
<li>第三、ES采用分片存储机制</li>
<li>第四、ES扩展性好，我们可以水平扩展增加服务器，提升ES处理性能，可以达到百台服务器节点扩展</li>
<li>第五、ES内部提供了数据汇总和索引生命周期管理的一些功能，可以方便我们更加高效的存储和搜索数据</li>
</ol>
<h4 id="使用ES注意事项"><a href="#使用ES注意事项" class="headerlink" title="使用ES注意事项"></a>使用ES注意事项</h4><ol>
<li>ES里面不建议使用复杂的关联查询，会对性能影响很大</li>
<li>避免深度分页查询，因为ES分页是支持front和size参数，在查询的时候，每个分片必须构造一个长度为front加size的优先队列，然后回传到网关节点，网关节点再对这些队列进行排序再找到正确的size文档。而当front足够大的时候容易造成OOM以及网络传输性能差的一些问题</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">https://zhangxin66666.github.io/2022/03/31/12.面试/常见面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/%E9%9D%A2%E8%AF%95.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"><img class="prev-cover" src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ConcurrentHashMap源码解读</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><img class="next-cover" src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构和算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88"><span class="toc-text">1.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1ConcurrentHashMap"><span class="toc-text">1.1ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2xxx"><span class="toc-text">1.2xxx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-List-Map%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">Set,List,Map有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HashMap和HashTable有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">HashMap底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-put%E6%B5%81%E7%A8%8B"><span class="toc-text">HashMap put流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-text">HashMap扩容流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">为什么选择用红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHaspMap"><span class="toc-text">ConcurrentHaspMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">面向对象的特征?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84RuntimeException"><span class="toc-text">常见的RuntimeException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见的引用类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM"><span class="toc-text">二、JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jvm%E5%9F%BA%E7%A1%80"><span class="toc-text">1.jvm基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.1jvm内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">对象创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Root%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">GC Root有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">CMS运行过程，缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">G1运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-text">G1适合什么场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%A9%BA%E9%97%B4%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-text">判断元空间是无用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">安全点和安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%8C%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-text">类加载器？双亲委派，好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YGC%E5%92%8CFGC%E5%8F%91%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">YGC和FGC发生的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack%EF%BC%8Cjmap%EF%BC%8CJstat%E4%BD%9C%E7%94%A8"><span class="toc-text">jstack，jmap，Jstat作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">三、Mysql数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-amp-%E8%A1%8C%E6%A0%BC%E5%BC%8F-amp-%E9%A1%B5%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.索引底层结构&amp;行格式&amp;页格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E6%9D%A1-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.一条 SQL 的执行过程详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3.ACID及实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MVCC"><span class="toc-text">4.MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="toc-text">5.mysql三大日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-redo%E6%97%A5%E5%BF%97"><span class="toc-text">6.redo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-undo%E6%97%A5%E5%BF%97"><span class="toc-text">7.undo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%83%BD%E8%AF%B4%E4%B8%8Bmyisam-%E5%92%8C-innodb%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">8.能说下myisam 和 innodb的区别吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B4%E4%B8%8Bmysql%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%A7%EF%BC%8C%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8"><span class="toc-text">10.什么是覆盖索引和回表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-mysql%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E3%80%82-%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">11.mysql的各种锁。  间隙锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-MRR"><span class="toc-text">12.MRR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">13.分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id"><span class="toc-text">14.分布式唯一id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">15.数据库三大范式是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-InnoDB%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">16.InnoDB引擎的4大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">17.索引失效的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E3%80%82-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-text">18.最左前缀原则。 联合索引使用分析实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-sql%E4%BC%98%E5%8C%96%E4%B9%8Bexplain-%E8%AF%A6%E8%A7%A3"><span class="toc-text">19.sql优化之explain 详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">20.mysql主从复制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">21.主从同步延时如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">22.隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-RC%E5%92%8CRR%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E3%80%82readview%E5%B1%82%E9%9D%A2"><span class="toc-text">23.RC和RR的本质区别。readview层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%BB%80%E4%B9%88%E6%98%AFreadview"><span class="toc-text">24.什么是readview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">25.快照读与当前读的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%B9%BB%E8%AF%BB%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-text">26.幻读和不可重复读区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-MySQL%E5%9C%A8RR%E7%BA%A7%E5%88%AB%E4%B8%AD%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%B9%BB%E8%AF%BB%E7%9A%84%E9%97%AE%E9%A2%98%E4%B9%88%EF%BC%9F"><span class="toc-text">27.MySQL在RR级别中完全解决了幻读的问题么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E8%84%8F%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%B7%E8%84%8F%E9%A1%B5%E6%97%B6%E6%9C%BA"><span class="toc-text">28.脏页是什么，刷脏页时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-bufferpool"><span class="toc-text">29.bufferpool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%87%A0%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B"><span class="toc-text">30.几大核心线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">31.事务传播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-text">32.分布式事务通用方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">33.成本分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%80%BB%E9%87%8F"><span class="toc-text">34.表中数据量如何计算总量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-count-1-count-count-id-count-%E5%AD%97%E6%AE%B5-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-text">35.count(1) count(*) count(id) count(字段) 性能对比分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-mysql%E4%B8%ADin-%E5%92%8Cexists-%E5%8C%BA%E5%88%AB"><span class="toc-text">36.mysql中in 和exists 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-join%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="toc-text">37.join查询原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">38.索引下推</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">39.两种排序方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-filesort%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-text">40.filesort排序原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-filesort%E5%88%A4%E6%96%AD%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%BC%8F%E3%80%82-%EF%BC%88%E5%8D%95%E8%B7%AFor%E5%8F%8C%E8%B7%AF%EF%BC%89"><span class="toc-text">41.filesort判断使用哪种排序模式。 （单路or双路）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F%E3%80%81%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B"><span class="toc-text">40.单路排序、双路排序详细过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95"><span class="toc-text">41.三星索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">42.场景题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%AD%98-Redis"><span class="toc-text">四、缓存:Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">Redis数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">分布式锁怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setnx%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">setnx用到的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存穿透，击穿，雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">Redis过期键删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">Redis持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">缓存与数据库数据一致性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81MQ"><span class="toc-text">五、MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rabbitmq%E7%94%9F%E4%BA%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">Rabbitmq生产高可用怎么实现的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">六、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="toc-text">sleep和wait区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E4%BD%9C%E7%94%A8"><span class="toc-text">Volitile作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">Volitile如何保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Java线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="toc-text">linux查看线程命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">Java线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Thread常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">ThreadLocal应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-text">ThreadLocal内存泄露原因，如何避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CReentranLock%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">synchronized和ReentranLock区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E6%9C%89%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">线程池参数有，核心线程配置，原因？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81spring"><span class="toc-text">七、spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">Bean的初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">AOP的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">springMVC处理请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">spring事务的传播机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C"><span class="toc-text">八、网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-0%E5%92%8Chttp1-1%E5%8C%BA%E5%88%AB"><span class="toc-text">http1.0和http1.1区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-text">HTTPS与HTTP的一些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">http三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">四次挥手</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">九、设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Dubbo"><span class="toc-text">十、Dubbo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84json%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">你知道的json序列化方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="toc-text">两个系统之间怎么交互的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dubbo%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">dubbo的序列化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Netty"><span class="toc-text">十一、Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">NIO三大核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Netty线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-text">Netty模块组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-text">Netty粘包拆包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81zookeeper"><span class="toc-text">十二、zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">zookeeper的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">zookeeper选举机制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%90%86%E8%AE%BA"><span class="toc-text">十三、理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="toc-text">CAP理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD"><span class="toc-text">DDD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E9%A1%B9%E7%9B%AE"><span class="toc-text">十四、项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%AE%80%E4%BB%8B"><span class="toc-text">ES简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E6%9F%A5%E8%AF%A2%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">ES查询快的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ES%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用ES注意事项</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql执行流程"/></a><div class="content"><a class="title" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程">mysql执行流程</a><time datetime="2022-04-01T16:00:00.000Z" title="发表于 2022-04-02 00:00:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读"><img src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap源码解读"/></a><div class="content"><a class="title" href="/2022/03/31/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读">ConcurrentHashMap源码解读</a><time datetime="2022-03-31T02:55:44.587Z" title="发表于 2022-03-31 10:55:44">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试知识点总结"><img src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试知识点总结"/></a><div class="content"><a class="title" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试知识点总结">面试知识点总结</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法"><img src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法">数据结构和算法</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/" title="业务架构-稳定性建设方法论"><img src="/images/cover/%E6%96%B9%E6%B3%95%E8%AE%BA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="业务架构-稳定性建设方法论"/></a><div class="content"><a class="title" href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/" title="业务架构-稳定性建设方法论">业务架构-稳定性建设方法论</a><time datetime="2022-01-16T16:00:00.000Z" title="发表于 2022-01-17 00:00:00">2022-01-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>