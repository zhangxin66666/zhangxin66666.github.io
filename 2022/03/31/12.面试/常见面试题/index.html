<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识点总结 | 金子爸爸の家</title><meta name="keywords" content="面试"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点总结">
<meta property="og:url" content="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="常见面试题，按照知识点分类整理，带答案">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png">
<meta property="article:published_time" content="2022-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-29T03:02:16.615Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-29 11:02:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-29T03:02:16.615Z" title="更新于 2023-08-29 11:02:16">2023-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">77.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>248分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-ConcurrentHashMap"><a href="#1-ConcurrentHashMap" class="headerlink" title="1.ConcurrentHashMap"></a>1.ConcurrentHashMap</h2><p><a href="../../1.基础知识/ConcurrentHashMap" target="_blank">ConcurrentHashMap</a></p>
<h2 id="2-Set-List-Map有什么区别"><a href="#2-Set-List-Map有什么区别" class="headerlink" title="2.Set,List,Map有什么区别"></a>2.Set,List,Map有什么区别</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/abkwex.png" alt="image-20220331111150319"></p>
<ul>
<li>结构特点<ol>
<li>List 和 Set 是存储单列数据的集合， Map 是存储键和值这样的双列数据的集合;</li>
<li>List中存储的数据是有顺序，并且允许重复; Map 中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的， Set 中存储的数据是无序的，且不允许有重复，但元素在集合中的位置由元素的hashcode决定，位置是固定的(Set集合根据 hashcode 来进行数据的存储，所以位置是固定的，但是位置不是用户可以控制的，所以对于用户来说 set 中的元素还是无序的);</li>
</ol>
</li>
</ul>
<h2 id="3-HashMap和HashTable有什么区别？"><a href="#3-HashMap和HashTable有什么区别？" class="headerlink" title="3.HashMap和HashTable有什么区别？"></a>3.HashMap和HashTable有什么区别？</h2><p>区别：</p>
<ol>
<li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li>
<li>HashMap允许key和value为null，而HashTable不允许</li>
</ol>
<h2 id="4-HashMap底层实现"><a href="#4-HashMap底层实现" class="headerlink" title="4.HashMap底层实现"></a>4.HashMap底层实现</h2><ol>
<li>jdk1.7底层采用的是数组+链表实现；jdk1.8底层采用数组+链表+红黑树实现，相对于1.7提升了查询的性能</li>
<li>链表过度到红黑树的阈值为8，红黑树退化为链表的阈值是6，原因在源码中332行给了明确解释(Poisson distribution)泊松分布，这是数学里面类似于正态分布的一个问题，这是统计学里面的一些东西</li>
<li>HashMap初始化的数组长度为16(算法导论中的除法散列法讲到 K取模m得到一个对应的位置，根据具体位置插入一个数据值，假如长度是16，长度范围就是0<del>15，取模之后我的余数为0</del>15之间，而算法导论中指出，一个不太接近2的整数幂的素数（质数：只能被1和它本身整出的数），常常是m的最好选择。但是hashMap中未采用素数，而是采用2的n次方(合数)作为数组长度)，原因为：1、更便于位置计算；2、方便做数据迁移。</li>
<li>为了保证存入的数据均匀的散列分布在数组中，需要设计良好的hash散列算法(hashMap中采用扰动函数来做的：移位和异或相关操作ConcurrentHashMap源码中684行spread方法，即：让int的高16位异或它本身)，尽可能的避免hash冲突(概率问题)，具体落到数组哪个节点并非是通过取模运算得出，而是通过与上数组长度-1即可(只需要int类型数32位的后四位参与运算)，即可得到0~15之间的数，因为取模运算效率远低于位运算，所以这也是hashMap要求底层数组长度必须为2的n次方的原因之一（ConcurrentHashMap源码中514行规定）。</li>
</ol>
<h2 id="5-HashMap-put流程"><a href="#5-HashMap-put流程" class="headerlink" title="5.HashMap put流程"></a>5.HashMap put流程</h2><ol>
<li>HashMap/ConcurrentHashMap 并不是通过构造函数创建默认空间的，而是通过put数据的时候获取到对应的数据空间的，如果数组长度是0，则通过CAS操作后初始化数组，如果有线程正在做初始化数组操作，其他线程则让出时间片</li>
<li></li>
</ol>
<h2 id="6-HashMap扩容流程"><a href="#6-HashMap扩容流程" class="headerlink" title="6.HashMap扩容流程"></a>6.HashMap扩容流程</h2><ol>
<li>hashMap规定了当我的数组快放满的时候就要开始扩容了，什么时候算是快放满？HashMap是通过扩容因子来规定的</li>
<li>HashMap规定扩容因子是0.75，如果默认长度是16，也就是说当HashMap底层数组的容量达到12的时候进行扩容操作。0.75则是根据统计学得来的。<code>private static final float LOAD_FACTOR = 0.75f;</code></li>
<li>扩容首先要创建新的数组（原来大小左移1位）ConcurrentHaspMap源码2367行开始扩容操作</li>
<li>转移旧数据到新的数组中去（怎么计算扩容后数据下标位置？）原来：h&amp;(n-1)计算下标位置，扩容后 h$(31)，原来占用4个二进制位，扩容后占用5个二进制位，所以只需要看第五位即可，如果第五位是0，扩容后的的下标跟原位置一样，如果是1，新下标位置在原数组的位置的基础上加上原来数组长度即可，这也是数组长度采用2的N次方扩容的第二个原因</li>
<li>假设原来长度是128，扩容后是256，整体扩容方式是通过多线程方式运行的，但是要保证数据不能乱，将原来数组分段，规定每个线程最少负责16个桶的迁移工作，8个线程可以并行执行，如果小于16个桶，直接单线程执行</li>
</ol>
<h2 id="7-为什么选择用红黑树"><a href="#7-为什么选择用红黑树" class="headerlink" title="7.为什么选择用红黑树"></a>7.为什么选择用红黑树</h2><p>二叉树在极端情况下会退化为链表，查询时间复杂度跟链表相似，而AVL树，SB树，红黑树，都属于平衡二叉树，尽量保持左子树和右子树的高度差不要相差太大，而这三种树的差别就在于左树和右树的高度规则不同。</p>
<ul>
<li>AVL树：严格意义平衡树，的要求左子树和右子树的高度差不能超过1，损失了部分插入性能，带来了高效的查询</li>
<li>SB树：</li>
<li>红黑树：要求最长子树不能超过最短子树的2倍即可，损失了部分查询性能，使得查询效率高于链表的同时，相比于其他树提升了插入性能，尽量做到了插入和查询的一个平衡点，而HashMap则是查多，插入少(这里的插入指的是产生Hash冲突下的插入)，所以红黑树更适合HashMap来做底层的存储结构。</li>
</ul>
<h2 id="8-面向对象的特征"><a href="#8-面向对象的特征" class="headerlink" title="8.面向对象的特征?"></a>8.面向对象的特征?</h2><p>面向对象的特征:封装、继承、多态、抽象。 封装:就是把对象的属性和行为(数据)结合为一个独立的整体，并尽可能隐藏对象的内 部实现细节，就是把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。 继承:子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代 码的复用性。 多态:指允许不同的对象对同一消息做出相应。即同一消息可以根据发送对象的不同而采 用多种不同的行为方式(发送消息就是函数调用)。封装和继承几乎都是为多态而准备 的，在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法。 抽象:表示对问题领域进行分析、设计中得出的抽象的概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。在 Java 中抽象用 abstract 关键字来修饰，用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类(接口)就是为了继承而存在的。</p>
<h2 id="9-常见的RuntimeException"><a href="#9-常见的RuntimeException" class="headerlink" title="9.常见的RuntimeException"></a>9.常见的RuntimeException</h2><ol>
<li>java.lang.NullPointerException 空指针异常;出现原因:调用了未经初始化的对象或者是不存在 的对象。</li>
<li>java.lang.ClassNotFoundException 指定的类找不到;出现原因:类的名称和路径加载错误;通常 都是程序试图通过字符串来加载某个类时可能引发异常。</li>
<li>java.lang.NumberFormatException 字符串转换为数字异常;出现原因:字符型数据中包含非数 字型字符。</li>
<li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。</li>
<li>java.lang.IllegalArgumentException 方法传递参数错误。</li>
<li>java.lang.ClassCastException 数据类型转换异常。 </li>
<li>java.lang.NoClassDefFoundException 未找到类定义错误。</li>
<li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误。</li>
<li>java.lang.InstantiationException实例化异常。</li>
<li>java.lang.NoSuchMethodException方法不存在异常。</li>
</ol>
<h2 id="10-常见的引用类型"><a href="#10-常见的引用类型" class="headerlink" title="10.常见的引用类型"></a>10.常见的引用类型</h2><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<ul>
<li><strong>强引用</strong>：普通的变量引用</li>
<li><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></li>
<li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li>
<li><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li>
</ul>
<h1 id="二、JVM"><a href="#二、JVM" class="headerlink" title="二、JVM"></a>二、JVM</h1><h2 id="1-jvm内存模型"><a href="#1-jvm内存模型" class="headerlink" title="1.jvm内存模型"></a>1.jvm内存模型</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/0Wv4TH.png" style="zoom:67%;" />

<p><strong>堆</strong>：堆Java虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为Yound区年轻代和Old区老年代，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是8:1:1的大小。</p>
<p><strong>栈</strong>：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。</p>
<p>局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，他的参数会被传递至从0开始的连续的局部变量表中。</p>
<p>操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。</p>
<p>动态连接用于将符号引用表示的方法转换为实际方法的直接引用。</p>
<p><strong>元数据</strong>：在Java1.7之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。</p>
<p>Class文件就是类和接口的定义信息。</p>
<p>运行时常量池就是类和接口的常量池运行时的表现形式。</p>
<p><strong>本地方法栈</strong>：主要用于执行本地native方法的区域</p>
<p><strong>程序计数器</strong>：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址</p>
<h2 id="2-对象创建过程"><a href="#2-对象创建过程" class="headerlink" title="2.对象创建过程"></a>2.对象创建过程</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/4jwdVI.png" alt="image-20220331111041423" style="zoom:67%;" />

<ol>
<li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li>
<li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li>
<li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li>
<li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li>
</ol>
<h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3.类的加载过程"></a>3.类的加载过程</h2><p>加载-&gt;链接（验证，准备，解析）-&gt;初始化</p>
<p>1）<strong>加载</strong></p>
<p>通过全限定类名加载一个类的二进制字节流，将静态结构转化为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象</p>
<p>加载.class文件的方式：</p>
<p>从本地系统中直接加载</p>
<p>通过网络获取，典型场景：Web Applet</p>
<p>从zip压缩包中读取，成为日后jar ，war格式的基础</p>
<p>运行时计算生成，使用最多的是：动态代理技术</p>
<p>其他文件生成：典型场景JSP</p>
<p>从专有数据库提取.class文件，比较少见</p>
<p>从加密文件中获取，典型的防Class文件被反编译的保护措施</p>
<p>2）<strong>链接</strong></p>
<p>1.验证：确保class文件内容不会危害到当前虚拟机</p>
<p>2.准备：为类变量分配内存并设置初始值，不会为实例变量分配空间初始化，类变量分配在方法区，实例变量分配在堆空间。</p>
<p>3.解析：将常量池的符号引用转换为直接引用</p>
<p>3）<strong>初始化</strong></p>
<p>执行类构造器方法（完成静态属性和静态代码块变量的赋值操作）的过程，此方法不需要定义，是javac完成的。</p>
<p>clinit()不同于类的构造器,他只会加载一次。若该类具有父类，JVM会保证子类的clinit()执行前，父类的clinit()已经执行完毕。</p>
<p>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。 任何一个类声明以后，内部至少存在一个类的构造器</p>
<h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4.类加载器"></a>4.类加载器</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/n30NxU.jpeg" alt="图片" style="zoom:67%;" />

<p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p>
<p>1）<strong>引导类加载器</strong></p>
<p>启动类加载器 BootStrap ClassLoader</p>
<p>加载java核心类库，只加载java javax sun开头的类</p>
<p>2）<strong>系统类加载器</strong></p>
<p>extends ClassLoader java ClassLoader.getSystemClassLoader();</p>
<p>加载用户自定义类，父类加载器为扩展类加载器</p>
<p>3）<strong>拓展类加载器</strong></p>
<p>extends ClassLoader java SystemClassLoader.getParent();</p>
<p>4）<strong>用户自定义类加载器</strong></p>
<p>extends ClassLoader</p>
<p>1.为什么要用户自定义类加载器？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">隔离加载类` `修改类加载的方式` `扩展加载源` `防止源码泄露</span><br></pre></td></tr></table></figure>

<p>2.用户自定义类加载器步骤？</p>
<p>jdk1.2之前，继承ClassLoader重写loadClass().jdk1.2之后建议重写findClass()</p>
<p>也可以继承URLClassLoader,避免了自己编写findClass()以及获取自己码流的方式。</p>
<p>3.ClassLoader</p>
<p>它是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">getParent()</span> <span class="string">返回父类加载器</span></span><br><span class="line"><span class="meta">loadClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">findClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">defineClass(String</span> <span class="string">name,byte[] b ,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</span></span><br></pre></td></tr></table></figure>



<h2 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5.双亲委派机制"></a>5.双亲委派机制</h2><p>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p>
<p>java虚拟机对class文件采用的是按需加载，而且加载某个类的class文件时，java虚拟机采用的是双亲委派机制，就是把请求交由父类加载器处理，它是一种任务委派模式</p>
<p>1）<strong>工作原理</strong></p>
<p>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</p>
<p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器。</p>
<p>如果父加载器可以完成类加载任务，就成功返回，倘若父加载器无法完成此类加载任务，子加载器才会尝试自己去加载。</p>
<p>2）<strong>举例</strong></p>
<p>调用JDBC接口，接口是引导类加载器加载的，但是实现类是系统类加载器加载的。</p>
<p>3）<strong>优点</strong></p>
<p>1、安全性，避免自己写的类替换掉java核心类；</p>
<p>2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p>
<h2 id="6-沙箱安全机制"><a href="#6-沙箱安全机制" class="headerlink" title="6.沙箱安全机制"></a>6.沙箱安全机制</h2><p>自定义的String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件，报错信息说没有main方法，就是因为加载的是jdk的String，这样可以保证对Java核心API源码的保护，这就是沙箱安全机制。</p>
<h2 id="7-程序计数器-PC"><a href="#7-程序计数器-PC" class="headerlink" title="7.程序计数器-PC"></a>7.程序计数器-PC</h2><p>JVM中的程序计数器，命名源于CPU的寄存器，寄存器存储相关的现场信息，CPU只有把数据装载到寄存器才能运行，这里，也不是指广义上的物理寄存器，或许将其翻译为PC计数器，会更贴切，并且也不容易引起一些不必要的误会，JVM中的PC寄存器是对物理PC寄存器的一种抽象。</p>
<p>程序计数器是用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令。</p>
<p>运行速度最快的区域。线程私有的，生命周期与线程的生命周期一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址，或者，如果在执行native方法，则为空。</p>
<p>引用自jvm规范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the method currently being executed by the thread is native, the value of the Java Virtual Machine&#x27;s pc register is undefined</span><br></pre></td></tr></table></figure>



<p><strong>程序计数器存放的是Java字节码的地址，而native方法的方法体是非Java的，所以程序计数器的值才未定义。</strong></p>
<p>那在native方法执行后，线程又如何确保下一次执行的位置？</p>
<p>这是因为每个Java线程都直接映射到一个OS线程上执行。所以native方法就在本地线程上执行，无需理会JVM规范中的程序计数器的概念。仔细看一下JVM规范，如果一个线程执行Native方法，程序计数器的值未定义，可不是一定为空，任何值都可以。native方法执行后会退出(栈帧pop)，方法退出返回到被调用的地方继续执行程序。</p>
<p>循环，分支跳转，异常处理，线程恢复都是依赖于程序计数器</p>
<p>字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
<p>JVM规范中唯一一个没有内存溢出错误的区域</p>
<p>1.使用PC寄存器存储字节码指令地址有什么作用？</p>
<p>因为cpu需要不停地切换各个线程，这时候切换回来以后，就得知道接着从哪里继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p>2.pc寄存器为什么要设置成线程私有的？</p>
<p>每一个线程都需要一个PC线程计数器来记录执行到了哪条字节码指令。</p>
<p>cpu时间片</p>
<p>CPU分配给各个程序的时间，每个线程被分配一个时间段，称作他的时间片。微观上，由于只有一个cpu，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p>并行vs串行</p>
<p>并行：几个线程同时执行</p>
<p>串行：几个线程一个一个执行</p>
<p>并发：垃圾回收线程和用户线程同时执行</p>
<h2 id="8-虚拟机栈"><a href="#8-虚拟机栈" class="headerlink" title="8.虚拟机栈"></a>8.虚拟机栈</h2><p>1，虚拟机栈出现的背景</p>
<p>由于跨平台性的设计，java的指令集架构是基于栈的指令集架构。不同平台cpu架构不同，所以不能设计为基于寄存器的指令集架构。</p>
<p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>2．内存中的栈与堆</p>
<p>栈是运行时单位，堆是存储的单位。</p>
<p>栈解决的是程序的运行问题，既程序如何执行，或者说如何处理数据，堆解决的是数据存储的问题，既数据怎么放，放在哪里。</p>
<p><strong>栈中可以存放方法内的基本类型变量和引用变量的地址。</strong></p>
<p>3．虚拟机栈基本内容</p>
<p>每个线程创建的时候都会创建一个ｊａｖａ虚拟机栈，其内部保存一个个的栈帧，对应着一次次方法的调用（一个栈帧对应着一个ｊａｖａ方法）。</p>
<p>栈顶的方法被称为当前方法。栈是线程私有的，生命周期和线程一致。</p>
<p>1）作用</p>
<p>主管ｊａｖａ程序的运行，他保存方法的局部变量（８种数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。</p>
<p>2）栈的特点</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅仅次于程序计数器</p>
<p>jvm堆栈的直接操作只有两个 ：方法执行，入栈；方法结束，出栈。</p>
<p>对于栈来说，不存在垃圾回收问题。</p>
<p>4.栈的常见异常和参数设置</p>
<p>jvm规范允许栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的java栈，那每一个线程的虚拟机容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过java虚拟机允许的最大容量，jvm会抛出<code>StackOverFlowError</code>（递归没有出口）。</p>
<p>特别的，在hotspot虚拟机中，如果在为栈分配内存时，内存不足，抛出的异常并不是oom，而是<code>StackOverFlowError</code>。</p>
<p>如果java虚拟机栈可以动态扩容，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程是没有足够的内存去创建对应的虚拟机栈，那java虚拟机会抛出oom。</p>
<p><strong>设置栈的大小</strong></p>
<p>-Xss 设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss256k</span><br></pre></td></tr></table></figure>



<p>5．栈的存储结构和运行原理</p>
<p>每个线程都有自己的栈，栈中的数据都是以栈帧的形式存在。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中各种数据信息。</p>
<p>１）栈的运行原理</p>
<p>一个线程中，一个时间点上，只会有一个活动的栈帧，既只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧。与这个栈帧对应的方法是当前方法，定义当前方法的类叫做当前类。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧被创建出来，放在栈顶，成为新的当前栈帧。</p>
<p>不同线程中所包含的栈帧是不允许相互引用的，既不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令，另一种是抛出异常，不管使用哪种方式，栈帧都会弹出。</p>
<p>２）栈帧的内部结构</p>
<p>每个栈帧中存储着　局部变量表　操作数栈　动态链接（指向运行时常量池的方法引用）　方法返回地址　一些附加信息</p>
<p>３）局部变量表</p>
<p>本地变量表：定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各种基本数据类型，对象引用，以及返回地址类型。</p>
<p>由于局部变量表是建立在线程的栈上的，是线程私有数据，因此不存在数据安全问题。</p>
<p>局部变量表所需容量大小是在编译器确定下来的，并保存在方法的Ｃｏｄｅ属性的ｍａｘｉｍｕｎ　ｌｏｃａｌ　ｖａｒｉａｂｌｅｓ数据项，方法运行期间变量表的大小是不会改变的。</p>
<p>参数值的存放总是在局部变量数组的ｉｎｄｅｘ０开始，到数组长度－１的索引结束。</p>
<p>局部变量表，最基本的存储单元是变量槽。</p>
<p>局部变量表中存放编译期间可知的各种基本数据类型，引用类型，ｒｅｔｕｒｎＡｄｄｒｅｓｓ类型。</p>
<p>方法嵌套的次数由栈的大小决定，局部变量表中的变量只在当前方法调用中有效，局部变量表随着栈帧销毁。</p>
<p>４）关于ｓｌｏｔ的理解</p>
<p>参数值的存放总是在局部变量表的ｉｎｄｅｘ０开始，到数组长度－１的索引结束。</p>
<p>局部变量表，最基本的存储单元是变量槽　ｓｌｏｔ</p>
<p>局部变量表中存放着编译期可知的各种基本数据类型，引用类型，ｒｅｔｕｒｎＡｄｄｒｅｓｓ的变量。</p>
<p>在局部变量表里，３２位以内的类型只占用一个ｓｏｒｔ，６４占用两个ｓｏｒｔ。</p>
<p>ｊｖｍ会为局部变量表中的每一个ｓｌｏｔ都分配一个访问索引，通过这个索引就可以成功访问到局部变量表中指定的局部变量值。</p>
<p>当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上。</p>
<p>如果需要访问一个局部变量表中64bit的局部变量值时，只需要使用一个索引即可。</p>
<p>如果当前帧是由构造方法或者实例方法(非static)创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</p>
<p>为什么静态方法不能使用ｔｈｉｓ？</p>
<p>静态方法的局部变量表没有ｔｈｉｓ</p>
<p>ｓｌｏｔ的重复利用：栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么再其作用域之后声明的新的局部变量就很有可能会复用过期的局部变量的槽位，从而达到节省资源的目的。</p>
<p>面试题：为什么if建议写大括号？</p>
<p>为了栈帧局部变量表里的slot槽能够最大可能的重复利用</p>
<p>6．静态变量与局部变量的对比</p>
<p>变量按照数据类型：基本数据类型和引用数据类型</p>
<p>变量按照类中声明位置：成员变量（类变量　ｓｔａｔｉｃ　，局部变量）　局部变量</p>
<p>成员变量　在使用前都经过默认赋值，ｉｎｔ显式赋值。</p>
<p>实例变量　随着对象创建会在堆空间中分配实例变量空间，并进行默认赋值。</p>
<p>局部变量显式赋值，否则没法使用。</p>
<p>在栈帧中，与性能调优最为密切的就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>在局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收。</p>
<p>7．操作数栈</p>
<p>栈的结构可以是数组或者单向链表，操作数栈是数组实现的。</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或者提取数据。</p>
<p>某些字节码指令将数值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。</p>
<p>执行复制，操作，求和。</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新ＰＣ寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期间就定义好了，保存在方法的ｃｏｄｅ属性，为ｍａｘ＿ｓｔａｃｋ的值。</p>
<p>栈中的任何元素都是可以任意的ｊａｖａ数据类型。</p>
<p><strong>ｊａｖａ虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</strong></p>
<p><strong>涉及操作数栈的字节码指令执行分析</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201201004544361.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>8．栈顶缓存技术</p>
<p>由于操作数是存储在内存中，因此频繁的执行内存读写必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p>
<p>9．动态链接</p>
<p>指向运行时常量池的方法引用。</p>
<p>每一个栈帧的内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。</p>
<p>在ｊａｖａ源文件在编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在ｃｌａｓｓ文件的常量池里。比如描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201004615443.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>为什么需要常量池？为了提供一些符号和常量，便于指令识别。</p>
<p>10.方法的调用</p>
<p>在ｊｖｍ中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。</p>
<p>1）动态链接与静态链接</p>
<p>静态链接：当一个字节码文件被装载到JVM内部时，如果被调用的 目标方法在编译期可知 ，且运行期保持不变时，这种情况下调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
<p>动态链接：如果 被调用的方法在编译期无法被确定下来 ，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
<p>2）对应方法的绑定机制</p>
<p><strong>早期绑定(Early Binding)和晚期绑定(Late Binding)。 绑定是一个字段(属性)、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p>
<p>1.早期绑定就是指被调用的 目标方法如果在编译期可知，且运行期保持不变时 ，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<p>2.如果 被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法 ，这种绑定方式也就被称之为晚期绑定。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C语言中的虚函数(C中则需要使用关键字virtual 来显示定义)。</p>
<p>如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p>3）4种方法调用指令区分非虚方法与虚方法</p>
<p><strong>虚方法与非虚方法</strong></p>
<p>如果方法在编译期就确定了具体的调用版本，这个版本再运行时是不可变的。这样的方法称为非虚方法。</p>
<p>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。</p>
<p>(子类对象的多态性的使用前提：①类的继承关系 ②方法的重写)</p>
<p><strong>动态类型语言和静态类型语言</strong></p>
<p>1、动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>2、静态类型语言是判断变量自身的类型信息</p>
<p>3、动态类型语言是判断变量值的类型信息。变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
<p>4）方法重写的本质与虚方法表的使用</p>
<p><em>方法重写的本质</em></p>
<p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做Ｃ。</p>
<p>如果在类型Ｃ中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过则返回java.lang.IllegalAccessError。</p>
<p>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p>
<p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p><em>java.lang.IllegalAccessError</em></p>
<p>程序试图访问或者修改一个属性或调用一个方法，这个属性或者方法，你没有权限访问，一般的，这个会引起编译期异常，这个错误 如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<p><strong>补充：多态的本质就是指向同一个虚方法表的引用。</strong></p>
<p>11.方法返回地址</p>
<p>存放着调用该方法的pc寄存器的值</p>
<p>一个方法结束，有两种方式：</p>
<p>1.正常执行完成</p>
<p>2.出现未处理的异常，非正常退出</p>
<p>无论通过哪种方式退出，在方法退出后都要返回到该方法被调用的位置，方法正常退出时，调用者的PC寄存器的值作为返回地址；即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回的地址需要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p><strong>当一个方法开始执行后，只有两种方式可以退出方法</strong>：</p>
<p>1.当执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口。</p>
<p>一个方法在正常执行完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际参数类型而定。</p>
<p>在字节码指令中，返回指令包含ireturn（int），lreturn（long），freturn（float），dreturn（double），areturn是引用类型，另外还有一个return指令供声明为void的方法，实例初始化方法，类和接口初始化方法使用。</p>
<p>在方法执行过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本地方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p><strong>总结</strong></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程，此时，需要回复上层方法的局部变量表，操作栈数，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法能够继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何返回值。</p>
<p>12.栈帧中的一些附加信息</p>
<p>栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<p>13.虚拟机的五道面试题</p>
<p>1.栈溢出的情况？</p>
<p>递归没有出口，方法无限循环调用</p>
<p>主要从两个方面考虑，申请固定内存但是内存不足，动态扩容内存不足。</p>
<p>2.调整栈的大小，就能保证栈不溢出嘛？</p>
<p>不是，比如递归没有出口</p>
<p>3.分配的栈内存越大越好么？</p>
<p>不是</p>
<p>4.垃圾回收是否涉及到虚拟机栈？</p>
<p>不是，但是局部变量表的引用属于垃圾回收的根节点。</p>
<p>5.方法中定义的局部变量是否是线程安全的？</p>
<p>不一定，只有内部生内部死的变量才是线程安全的，不是内部产生的（方法参数），内部产生又返回到外面的（返回值），是线程不安全的。</p>
<h2 id="9-本地方法接口和本地方法栈"><a href="#9-本地方法接口和本地方法栈" class="headerlink" title="9.本地方法接口和本地方法栈"></a>9.本地方法接口和本地方法栈</h2><p><img src="https://img-blog.csdnimg.cn/20201201004652601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>什么是本地方法？</p>
<p>1、简单讲：一个Native Method 就是一个Java调用非Java代码的接口。一个 Native Method是这样的一个Java方法：该方法的实现由非Java语言实现，比如 C 。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C中，可以用 extern “C” 告知C 编译器去调用一个C 的函数。</p>
<p>2、“A native method is a Java method whose implementation is provided by non-java code.”</p>
<p>3、在定义一个native method 时，并不提供实现体(有些像定义一个Java interface )，因为其实现体是由非Java语言在外面实现的。</p>
<p>4、本地接口的作用是融合不同的编程语言为Java 所用，它的初衷是融合 C/C++程序。</p>
<p>5、标识符native可以与所有其他的Java标识符连用(除了abstract)。</p>
<p>为什么使用本地方法？</p>
<p>1.java虽然使用方便，但是有一些层次的任务用java实现并不容易，或者我们对程序的效率很在意时，问题会出现。</p>
<p>2.目前该方法的使用越来越少了，除非是与硬件有关的应用，比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用中已经少见，因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用WebService等。</p>
<p>本地方法栈的理解</p>
<p>java虚拟机栈用于管理java方法的使用，而本地方法栈用于管理本地方法的调用，本地方法栈也是线程私有的，它允许被实现成固定或者可动态扩展的内存大小（在内存溢出方面是相通的）。本地方法主要是使用c语言来实现的，它的具体做法是在本地方法栈中登记本地方法，在执行引擎执行的时候加载本地方法库。</p>
<p><strong>本地方法栈，本地接口和本地方法库之间的联系</strong></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/hBx4Ye.png" alt="img"></p>
<p>当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，他和虚拟机拥有同样的权限，本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。他甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存。</p>
<p>并不是所有的jvm都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p>
<p>在hotspot虚拟机中直接将本地方法栈和java虚拟机栈合二为一。</p>
<h2 id="10-堆"><a href="#10-堆" class="headerlink" title="10.堆"></a>10.堆</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/205FY3.jpeg" alt="img"></p>
<h2 id="11-堆的核心概念"><a href="#11-堆的核心概念" class="headerlink" title="11.堆的核心概念"></a>11.堆的核心概念</h2><p>一个jvm实例只存在一个堆空间，他是java内存管理的核心区域。他在jvm启动时创建，空间大小也就确定了，是jvm管理的最大一块内存空间，堆内存的大小是可以调节的，jvm规范规定，堆可以处于物理上内存不连续的空间，但是在逻辑上他应该被视为连续的。所有线程共享java堆，在这里还可以划分线程私有的缓冲区（TLAB）。</p>
<p>jvm规范中对java堆的描述是：几乎所有的对象实例以及数组都应当在运行时分配在堆上。数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。在方法结束后，堆中对象不会马上移除，仅仅在垃圾收集的时候才会被移除。堆是GC垃圾回收的重点区域。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/4hjb2u.jpeg" alt="img"></p>
<h2 id="12-堆的内存细分"><a href="#12-堆的内存细分" class="headerlink" title="12.堆的内存细分"></a>12.堆的内存细分</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/N2IRUx.jpeg" alt="img"></p>
<p>现代垃圾收集器大部分基于分代收集理论，堆空间细分为：新生代（伊甸园区，幸存者0和幸存者1），老年代，永久代（jdk8改名叫元空间）</p>
<p>3.设置堆内存大小与OOM</p>
<h3 id="1）堆空间的大小设置"><a href="#1）堆空间的大小设置" class="headerlink" title="1）堆空间的大小设置"></a>1）堆空间的大小设置</h3><p>java堆用于存储java实例对象，那么堆的大小在jvm启动的时候就已经设定好了，可以通过-Xms和-Xmx来设置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xms用于表示堆的起始内存</span></span><br><span class="line"><span class="attr">-Xmx用于表示堆区的最大内存</span></span><br><span class="line"><span class="attr">-X是jvm的运行参数</span></span><br><span class="line"><span class="meta">ms是memory</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>



<p>一旦堆区中的内存大小超过-Xms所指定的最大内存时，将会抛出OutOfMemoryError异常。通常将起始内存和最大内存设置相同的值，其目的是为了能够在垃圾回收机制清理完堆空间后不需要重新分隔计算堆空间的大小，从而提高性能。</p>
<p>默认情况下，初始内存：物理内存/64，最大内存大小物理内存/4，查看设置的参数JPS  或者 jstat -gc 进程id</p>
<p>-XX:+PrintGCDetails 打印垃圾回收细节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回java虚拟机中的堆内存总量</span></span><br><span class="line"><span class="keyword">long</span> initMemory=Runtime.getRuntime().totalMemory()/<span class="number">1024</span>/<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//返回java虚拟机试图使用的最大堆内存量</span></span><br><span class="line"><span class="keyword">long</span> maxMemory=Runtime.getRuntime().maxMemory()/<span class="number">1024</span>/<span class="number">1024</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;-Xms:&quot;</span>+initMemory);</span><br><span class="line">System.out.println(<span class="string">&quot;-Xmx:&quot;</span>+maxMemory);</span><br></pre></td></tr></table></figure>



<h3 id="2）OutOfMemoryError"><a href="#2）OutOfMemoryError" class="headerlink" title="2）OutOfMemoryError"></a>2）OutOfMemoryError</h3><p>集合或者数组创建过大，导致堆空间超出内存。</p>
<h2 id="13-年轻代和老年代"><a href="#13-年轻代和老年代" class="headerlink" title="13.年轻代和老年代"></a>13.年轻代和老年代</h2><p>存储在jvm中的java对象可以被划分为两类</p>
<p>生命周期比较短的和生命周期比较长的。</p>
<p>java堆区进一步细分的话，可以划分为年轻代和老年代（1:2），其中年轻代又可以划分为Eden，幸存者0，幸存者1（8:1:1）。默认自适应，其实并不是8:1:1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-NewRatio=2 设置新生代与老年代的比例，默认是2</span><br><span class="line">-XX：SurvivorRatio=8 设置新生代中Eden区与Survivor区的比例</span><br></pre></td></tr></table></figure>



<p>几乎所有的对象都是在Eden区被new出来的。绝大多数java对象的销毁都是在新生代进行的，80%的对象都是朝生夕死，可以使用-Xmn设置新生代最大内存，一般使用默认。</p>
<h2 id="14-对象分配过程"><a href="#14-对象分配过程" class="headerlink" title="14.对象分配过程"></a>14.对象分配过程</h2><p>1.new的对象先放在伊甸园区，此区有大小限制。</p>
<p>2.当伊甸园的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区的不在被其他对象所引用的对象销毁，在加载新的对象放在伊甸园区。</p>
<p>3.然后将伊甸园区剩余的对象移动到幸存者0.</p>
<p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，接着再去幸存者1区。</p>
<p>5.啥时候去养老区呢？可以设置次数，默认是15次。-XX:MaxTenuringThreshold=</p>
<p>(伊甸园区满了会触发ygc，将幸存者区域和伊甸园区都回收一下，但是幸存者区满了不会触发垃圾回收)</p>
<p>总结：针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区或者元空间收集。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/ZaOcEV.jpeg" alt="img"></p>
<h2 id="15-常用调优工具"><a href="#15-常用调优工具" class="headerlink" title="15.常用调优工具"></a>15.常用调优工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.JDK命令行</span><br><span class="line">2.Jconsole</span><br><span class="line">3.VisualVM</span><br><span class="line">4.Jprofiler</span><br><span class="line">5.Java Flight Recorder</span><br><span class="line">6.GCViewer</span><br><span class="line">7.GC Easy</span><br></pre></td></tr></table></figure>



<h2 id="16-Minor-GC-Major-GC-fULL-GC"><a href="#16-Minor-GC-Major-GC-fULL-GC" class="headerlink" title="16.Minor GC,Major GC,fULL GC"></a>16.Minor GC,Major GC,fULL GC</h2><p>jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分回收都是指新生代。</p>
<p>针对hotSpotVM的实现，它里面的GC按照回收区域分为两大类型：一种是部分收集，一种是FullGC</p>
<p>1.部分收集：不是完整收集整个Java堆的垃圾回收，又分为：</p>
<p>1）新生代收集Minor GC：只是新生代的垃圾收集</p>
<p>2）老年代收集Major GC：只是老年代的垃圾收集</p>
<p>目前只有CMSGC拥有单独收集老年代的行为，很多时候Minor GC会和FullGC混淆使用，需要具体分辨老年代回收还是整堆回收。</p>
<p>3）混合收集：收集整个新生代以及部分老年代的垃圾</p>
<p>2.整堆收集：收集整个java堆和方法区的垃圾</p>
<h2 id="17-分代式GC策略触发条件"><a href="#17-分代式GC策略触发条件" class="headerlink" title="17.分代式GC策略触发条件"></a>17.分代式GC策略触发条件</h2><h3 id="1）年轻代触发机制"><a href="#1）年轻代触发机制" class="headerlink" title="1）年轻代触发机制"></a>1）年轻代触发机制</h3><p>1.当年轻代空间不足时，就会出发minorGC，这里的年轻代指的是Eden满，Survivor满不会触发GC</p>
<p>2.因为java对象大多数存活时间比较短暂，所以MinorGC非常频繁，一般回收速度也比较快。</p>
<p>3.MinorGC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
<p><img src="https://img-blog.csdnimg.cn/2020120100490853.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="2）老年代GC触发机制"><a href="#2）老年代GC触发机制" class="headerlink" title="2）老年代GC触发机制"></a>2）老年代GC触发机制</h3><p>1.指的是发生在老年代的GC，对象从老年代消失时，我们说的MajorGC和FullGC发生了。</p>
<p>2.出现了MajorGC，经常会伴随至少一次的MinorGC，也就是在老年代空间不足的时候，会先尝试触发minorGC，如果之后空间还是不足，则会触发MajorGC。</p>
<p>3.MajorGC的速度一般会比MinorGC慢10倍以上，STW时间更长。</p>
<p>4.如果MajorGC后，内存还是不足，就会OOM。</p>
<h3 id="3）FullGC触发条件"><a href="#3）FullGC触发条件" class="headerlink" title="3）FullGC触发条件"></a>3）FullGC触发条件</h3><p>1.System.gc() 不是一定执行的。</p>
<p>2.老年代空间不足</p>
<p>3.方法区空间不足</p>
<p>4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</p>
<p>5.Eden区，survivor0 区向survivor1区复制时，对象大小大于To Space可用区域，则把该对象转存到老年代，且老年代的可用内存小于该对象的内存就会触发GC。</p>
<p>Full GC是开发或者调优中尽量要避免的，这样暂停时间会短一些。</p>
<h2 id="18-堆空间分代思想"><a href="#18-堆空间分代思想" class="headerlink" title="18.堆空间分代思想"></a>18.堆空间分代思想</h2><p>研究表明，堆空间百分之七十以上的对象是临时对象，其实不分代完全可以，分代的唯一理由就是优化GC性能，如果没有分代，所有对象都在一块，GC的时候要找到哪些对象没用，这样就会造成整堆扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一块区域，当GC时先把这块区域存储朝生夕死对象的区域进行回收，这样就会腾出很大空间。</p>
<h2 id="19-对象分配原则"><a href="#19-对象分配原则" class="headerlink" title="19.对象分配原则"></a>19.对象分配原则</h2><p>针对不同年龄段对象分配原则如下</p>
<p>优先分配到伊甸园区，大对象直接分配到老年代，尽量避免程序中出现过多的大对象，长期存活的对象分配到老年代，动态对象年龄判断，如果幸存者区中相同年龄的所有对象大小的总和大于幸存者空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到达到16.</p>
<p>空间分配担保： -XX：HandlePromotionFailure</p>
<h2 id="20-TLAB"><a href="#20-TLAB" class="headerlink" title="20.TLAB"></a>20.TLAB</h2><p>堆空间为每个线程分配的TLAB</p>
<p>堆空间是线程共享区域，任何线程都可以访问到堆区中的共享资源。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/FYl0lQ.jpeg" alt="img"></p>
<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每一个线程分配了一个线程私有的缓存区域，它包含在伊甸园区内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配的方式称为快速分配策略</p>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是JVM确实是将TLAB作为内存分配的首选。</p>
<p>在程序中，可以通过-XX:UseTLAB设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅仅占整个Eden空间的百分之一，当然我们可以通过选项-XX：TLABWasteTargetPercent设置Tlab空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM会尝试通过加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
<p><img src="https://img-blog.csdnimg.cn/2020120100500789.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="21-堆空间的参数设置"><a href="#21-堆空间的参数设置" class="headerlink" title="21.堆空间的参数设置"></a>21.堆空间的参数设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial 查看所有的参数的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 查看所有的参数的最终值</span><br><span class="line">-Xms: 初始化堆空间大小</span><br><span class="line">-Xmx: 最大堆空间内存</span><br><span class="line">-Xmn: 设置新生代的大小</span><br><span class="line">-XX:NewRatio 配置新生代与老年代在堆结构的占比</span><br><span class="line">-XX:SurvivorRatio:设置新生代中Eden和s0/s1空间的比例</span><br><span class="line">-XX:MaxTenuringThreshold 设置新生代垃圾的最大年龄</span><br><span class="line">-XX:+PrintGCDetails 输出详细的GC处理日志</span><br><span class="line">打印gc简要信息：XX:+PrintGC -verbose:gc</span><br><span class="line">-XX:HandlePromotionFailure 是否设置空间分配担保</span><br></pre></td></tr></table></figure>



<p>在发生MinorGC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则此次GC是安全的。如果小于，虚拟机会查看空间分配担保的策略参数是否为true，如果为true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。如果大于，则尝试进行老年代GC，但是这次GC依然是有风险的；如果小于，则改为进行FullGC。如果空间分配担保的策略参数为false，直接FullGC。</p>
<h2 id="22-从逃逸分析角度分析对象内存分配"><a href="#22-从逃逸分析角度分析对象内存分配" class="headerlink" title="22.从逃逸分析角度分析对象内存分配"></a>22.从逃逸分析角度分析对象内存分配</h2><h3 id="1）堆是分配对象存储的唯一选择嘛？"><a href="#1）堆是分配对象存储的唯一选择嘛？" class="headerlink" title="1）堆是分配对象存储的唯一选择嘛？"></a>1）堆是分配对象存储的唯一选择嘛？</h3><p>在java虚拟机中，对象在java堆中分配内存的，这是一个普遍的常识。但是有一个特殊的情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能优化成栈上分配。这样就无需再堆上分配内存，也无须进行垃圾回收了。这是最常见的堆外存储技术。</p>
<h3 id="2）逃逸分析"><a href="#2）逃逸分析" class="headerlink" title="2）逃逸分析"></a>2）逃逸分析</h3><p>1.如果将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>2.这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>3.通过逃逸分析，hotspot编译器能够分析出一个新的对象的引用的适用范围从而决定是否要将这个对象分配到堆上。</p>
<p>4.逃逸分析的基本行为就是分析对象动态作用域：</p>
<p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
<p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
<p>5.没有发生逃逸的对象，则可以分配到栈上，随着方法的执行结束，栈空间就被移除，栈空间指向堆空间对象的引用就没了，等到年轻代GC，对象就会被回收。</p>
<h3 id="3）补充"><a href="#3）补充" class="headerlink" title="3）补充"></a>3）补充</h3><p>其实主要就是解决了循环引用，没有逃逸分析，这个对象可能一直不被回收，但是有了逃逸分析，栈帧销毁，这个对象就是垃圾了。</p>
<h2 id="23-使用逃逸分析堆代码进行优化"><a href="#23-使用逃逸分析堆代码进行优化" class="headerlink" title="23.使用逃逸分析堆代码进行优化"></a>23.使用逃逸分析堆代码进行优化</h2><h3 id="1）栈上分配"><a href="#1）栈上分配" class="headerlink" title="1）栈上分配"></a>1）栈上分配</h3><p>将堆分配转换为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束后，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见的栈上分配场景：在逃逸分析中，已经说明了。分别是给成员变量赋值，方法返回值，实例引用传递。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis //默认开启</span><br></pre></td></tr></table></figure>



<h3 id="2）同步省略"><a href="#2）同步省略" class="headerlink" title="2）同步省略"></a>2）同步省略</h3><p>如果一个对象被发现只能从一个线程被访问到，那么这个对象的操作可以不考虑同步。线程同步的代价是相当高的，同步的后果是降低并发和性能。在动态编译同步代码块的时候，jit编译器可以借助逃逸分析来判断同步块所使用的锁的对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性能，这个取消的性能就叫做同步省略，也叫锁消除。</p>
<h3 id="3）分离对象或标量替换"><a href="#3）分离对象或标量替换" class="headerlink" title="3）分离对象或标量替换"></a>3）分离对象或标量替换</h3><p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不存储在内存，而是存储在CPU寄存器中</p>
<p>1.标量是指一个无法在分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量，java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<p>2.标量替换的参数设置</p>
<p>参数-XX：+EliminateAllocations开启了标量替换，允许将对象打散分配在栈上。</p>
<p>3.逃逸分析技术并不成熟，其根本原因就是无法保证逃逸分析的性能消耗一定高于他的消耗。虽然经过逃逸分析可以做标量替换，栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程，虽然并不成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p><strong>通过逃逸分析，jvm会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于jvm设计者的选择。HotSpot虚拟机中并未这么做，所以可以明确所有的对象实力都是创建在堆上。</strong></p>
<p>intern字符串的缓存和静态变量曾经都被分配到永久带上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配 ，所以这一点同样符合前面的一点结论：对象实例都是分配在堆上。</p>
<h2 id="24-栈，堆，方法区的交互关系"><a href="#24-栈，堆，方法区的交互关系" class="headerlink" title="24.栈，堆，方法区的交互关系"></a>24.栈，堆，方法区的交互关系</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/OExPTq.jpeg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person=<span class="keyword">new</span> Person();</span><br><span class="line">Person这个运行时的大Class实例放在方法区</span><br><span class="line">person这个在java虚拟机栈的某个栈帧的局部变量表</span><br><span class="line"><span class="keyword">new</span> Person();结构在堆中。</span><br></pre></td></tr></table></figure>



<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/535vpG.jpeg" alt="img"></p>
<h2 id="25-方法区的理解"><a href="#25-方法区的理解" class="headerlink" title="25.方法区的理解"></a>25.方法区的理解</h2><p>尽管所有方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾回收或者压缩，对于hotspot而言，方法区还有一个别名叫非堆，目的就是要和堆分开。所以方法区可以看做是一块独立于java堆的内存空间。方法区与堆空间一样，是多线程共享的，方法区在jvm启动的时候被创建，并且他的实际物理内存空间中和java堆区一样都可以是物理上不连续的。方法区的大小和堆一样可以选择固定大小和扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会OOM。关闭jvm就会释放这个区域的内存。</p>
<p>加载大量第三方jar</p>
<p>tomcat部署的工程太多</p>
<p>大量动态的生成反射类</p>
<p>关闭jvm就会释放这个区域的内存</p>
<h2 id="26-设置方法区大小的参数"><a href="#26-设置方法区大小的参数" class="headerlink" title="26.设置方法区大小的参数"></a>26.设置方法区大小的参数</h2><p>方法区的大小不必是固定的，jvm可以根据应用需要动态调整。</p>
<p>1.元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。</p>
<p>2.默认值依赖于平台，win下，元空间默认大小是21M，最大值是-1，代表没有限制。</p>
<p>3.与永久代不同，默认情况下，如果指定大小，虚拟机会耗尽所有的可用系统内存。如果元数据去发生溢出，虚拟机一样会OOM。</p>
<p>4.-XX:MetaspaceSize：设置初始元空间大小。这就是一个水平线，达到这个线就会触发FullGC，如果设置小了就会频繁GC，所以尽量设置大点，每次GC，会卸载没用的类(即对应的类加载器不在存活)，然后这个水平线将会被重置。新的水位线取决于GC释放了多少空间。如果释放空间不足，那么在不超过最大值时，他会适当调高，如果释放空间过多，则适当降低该值。</p>
<h2 id="27-如何解决OOM"><a href="#27-如何解决OOM" class="headerlink" title="27.如何解决OOM"></a>27.如何解决OOM</h2><p>1.要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具堆dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。</p>
<p>2.如果是内存泄漏，可以进一步通过工具查看泄露对象到GC ROOTS的引用链，于是就能找到泄露对象到底是通过怎么样的路径与GC ROOTS相关联导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC ROOTS引用链的信息，就可以比较准确的定位出泄露代码的位置。</p>
<p>3.如果不存在内存泄漏，换句话说就是内存中的对象却是还必须存活着，那就应当检查虚拟机堆参数，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h2 id="28-方法区的内部结构"><a href="#28-方法区的内部结构" class="headerlink" title="28.方法区的内部结构"></a>28.方法区的内部结构</h2><p><img src="https://img-blog.csdnimg.cn/20201201005102641.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201201005119763.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>他用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等。</p>
<h3 id="1）类型信息"><a href="#1）类型信息" class="headerlink" title="1）类型信息"></a>1）类型信息</h3><p>对每个加载的类型，jv必须在方法区存储一下类型信息。</p>
<p>全限定类名，直接父类的全限定类名，这个类型的修饰符，这个类型直接接口的一个有序列表</p>
<h3 id="2）域信息"><a href="#2）域信息" class="headerlink" title="2）域信息"></a>2）域信息</h3><p>jvm必须在方法区中保存类型的所有域的信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称，域类型，域修饰符。</p>
<h3 id="3）方法信息"><a href="#3）方法信息" class="headerlink" title="3）方法信息"></a>3）方法信息</h3><p>jvm必须保存所有方法的以下信息，同域信息一样包括声明顺序</p>
<p>方法名称，返回类型，参数的数量和类型，顺序，方法的修饰符，方法的字节码，操作数栈，局部变量表以及大小，异常表</p>
<p>每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-12:09</span></span><br><span class="line"><span class="comment"> * 1.静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。</span></span><br><span class="line"><span class="comment"> * 2.类变量被类的所有实例共享，即使没有实例时你也可以放问他。</span></span><br><span class="line"><span class="comment"> * 3.全局常量 static final</span></span><br><span class="line"><span class="comment"> * 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</span></span><br><span class="line"><span class="comment"> *图：final-static</span></span><br><span class="line"><span class="comment"> * javap -v Order.class</span></span><br><span class="line"><span class="comment"> * javap -v  -p DemoE.class &gt; DemoE.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order=<span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a+<span class="string">&quot;----&quot;</span>+<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/l2fAui.jpeg" alt="img"></p>
<h3 id="4）class文件中常量池的理解"><a href="#4）class文件中常量池的理解" class="headerlink" title="4）class文件中常量池的理解"></a>4）class文件中常量池的理解</h3><p>方法区内部包含了运行时常量池，字节码文件内部包含了常量池。</p>
<p>为什么需要常量池？</p>
<p>java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在动态链接的时候就会用到运行时常量池。</p>
<p>一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池表，包含各种字面量和对应类型，域和方法的符号引用。</p>
<p>总结：常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。</p>
<h3 id="5）运行时常量池"><a href="#5）运行时常量池" class="headerlink" title="5）运行时常量池"></a>5）运行时常量池</h3><p>方法区的一部分，class文件的常量池被类加载器加载到运行时数据区就会在方法区生成对应的运行时常量池，JVM为每一个已经加载的类或接口都维护了一个常量池。池子中的数据就像数组一样，都是通过索引访问的，运行时常量池包括多种不同的变量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换位真实地址。</p>
<p>运行时常量池动态性，当创建类或者接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则会OOM。</p>
<h2 id="29-图解常量池操作"><a href="#29-图解常量池操作" class="headerlink" title="29.图解常量池操作"></a>29.图解常量池操作</h2><p><img src="https://img-blog.csdnimg.cn/20201201005201718.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a=x/y;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1）运行时常量池"><a href="#1）运行时常量池" class="headerlink" title="1）运行时常量池"></a>1）运行时常量池</h3><p>运行时常量池是方法区的一部分。</p>
<p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<h2 id="30-方法区的演进"><a href="#30-方法区的演进" class="headerlink" title="30.方法区的演进"></a>30.方法区的演进</h2><p><img src="https://img-blog.csdnimg.cn/20201201005219766.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>只有hotspot才有永久代。hotspot中方法区的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk1.6 有永久代，静态变量存放在永久代</span><br><span class="line">jdk1.7 有永久代，但已经逐步‘去永久带’，字符串常量池，静态变量移除，保存在堆</span><br><span class="line">jdk1.8 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但是字符串常量池，静态变量仍在堆。</span><br></pre></td></tr></table></figure>



<p>永久代为什么要被元空间替换？</p>
<p>以前使用虚拟机内存，现在使用本地内存</p>
<p>①为永久代设置空间大小很难确定</p>
<p>②对永久代调优困难</p>
<p>方法区的垃圾收集主要分两部分</p>
<p>常量池中废弃的常量和不再使用的类型</p>
<h2 id="31-StringTable为什么调整位置"><a href="#31-StringTable为什么调整位置" class="headerlink" title="31.StringTable为什么调整位置"></a>31.StringTable为什么调整位置</h2><p>jdk7将StringTable放到了堆空间。因为永久代的垃圾回收效率低，在full gc的时候才会触发。而full gc是老年代空间不足，永久代不足的时候才会触发。这就导致了StringTable的回收效率不高。而我们在开发的时候会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h2 id="32-静态变量放在哪里"><a href="#32-静态变量放在哪里" class="headerlink" title="32.静态变量放在哪里"></a>32.静态变量放在哪里</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-15:38</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 1.new出来的结构，也就是对象实例都在堆空间</span></span><br><span class="line"><span class="comment"> * 2.1.6：obj1随着DemoG的类型信息放在方法区；1.7：放在堆空间</span></span><br><span class="line"><span class="comment"> * 3.obj2是实例变量，在堆空间</span></span><br><span class="line"><span class="comment"> * 4.obj3在foo方法对应的栈帧的局部变量表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Order obj1=<span class="keyword">new</span> Order(); <span class="comment">//jdk7以前放在永久代，7开始放在堆空间</span></span><br><span class="line">        Order obj2=<span class="keyword">new</span> Order(); <span class="comment">//实例变量  堆空间</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; </span><br><span class="line">            Order obj3=<span class="keyword">new</span> Order();  <span class="comment">//方法内部局部变量   栈帧里面的局部变量表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="33-方法区的垃圾回收"><a href="#33-方法区的垃圾回收" class="headerlink" title="33.方法区的垃圾回收"></a>33.方法区的垃圾回收</h2><p>1.一般来说，方法区的回收效果不好，特别是类型的卸载，但是有时候回收又是必要的</p>
<p>2.方法区的垃圾回收主要是两部分：废弃的常量和不再使用的类型</p>
<p>3.方法区常量池主要存放：字面量和符号引用</p>
<p><strong>符号引用包括：1.类和接口的全限定类名2.字段的名称和描述符3.方法的名称和描述符</strong></p>
<p>4.只要常量池中的常量没有被任何地方引用，就可以被回收</p>
<p>5.判断一个类是否可以被回收</p>
<p>1.该类所属的实例都已经被回收</p>
<p>2.加载该类的类加载器已经被回收</p>
<p>3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的对象</p>
<h2 id="34-创建对象的方式"><a href="#34-创建对象的方式" class="headerlink" title="34.创建对象的方式"></a>34.创建对象的方式</h2><h3 id="1）new"><a href="#1）new" class="headerlink" title="1）new"></a>1）new</h3><p>new（直接new ，工厂模式，构建者模式）</p>
<h3 id="2）Class-forName-newInstance"><a href="#2）Class-forName-newInstance" class="headerlink" title="2）Class.forName().newInstance()"></a>2）Class.forName().newInstance()</h3><p>反射的方式，只能调用空参构造器，权限是public</p>
<h3 id="3）Constructor-newInstance-xxx"><a href="#3）Constructor-newInstance-xxx" class="headerlink" title="3）Constructor.newInstance(xxx)"></a>3）Constructor.newInstance(xxx)</h3><p>反射的方式，可以调用空参，带参的构造器，权限没要求</p>
<h3 id="4）使用clone（）"><a href="#4）使用clone（）" class="headerlink" title="4）使用clone（）"></a>4）使用clone（）</h3><p>不调用任何构造器，当前需要实现Cloneable接口，实现clone（）；分为深克隆和浅克隆  对象嵌套</p>
<h3 id="5）使用反序列化"><a href="#5）使用反序列化" class="headerlink" title="5）使用反序列化"></a>5）使用反序列化</h3><p>从文件，网络中获取一个对象的二进制流</p>
<h3 id="6）第三方库Objenesis"><a href="#6）第三方库Objenesis" class="headerlink" title="6）第三方库Objenesis"></a>6）第三方库Objenesis</h3><h2 id="35-创建对象的步骤"><a href="#35-创建对象的步骤" class="headerlink" title="35.创建对象的步骤"></a>35.创建对象的步骤</h2><h3 id="1）首先判断对应的类是否已经加载，链接，初始化"><a href="#1）首先判断对应的类是否已经加载，链接，初始化" class="headerlink" title="1）首先判断对应的类是否已经加载，链接，初始化"></a>1）首先判断对应的类是否已经加载，链接，初始化</h3><h3 id="2）为对象分配内存"><a href="#2）为对象分配内存" class="headerlink" title="2）为对象分配内存"></a>2）为对象分配内存</h3><p>内存规整-指针碰撞</p>
<p>所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是吧指针想空闲那边挪动一段与对象大小相等的距离罢了，如果垃圾收集器选择的是基于压缩算法的，虚拟机采用这种分配方式。一般使用带有整理过程的收集器时，使用指针碰撞。</p>
<p>内存不规整-空闲列表分配</p>
<p>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。虚拟机维护一个列表，记录哪块内存可用，有多大，在分配的时候找到一块内存足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为空闲列表。选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h3 id="3）处理并发安全问题"><a href="#3）处理并发安全问题" class="headerlink" title="3）处理并发安全问题"></a>3）处理并发安全问题</h3><p>采用cas配上失败重试保证更新的原子性，每个线程预先分配一块tlab</p>
<h3 id="4）初始化分配到空间"><a href="#4）初始化分配到空间" class="headerlink" title="4）初始化分配到空间"></a>4）初始化分配到空间</h3><p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p>
<p>给对象属性赋值的步骤：显式初始化/代码块初始化 ，构造器初始化</p>
<h3 id="5）设置对象头"><a href="#5）设置对象头" class="headerlink" title="5）设置对象头"></a>5）设置对象头</h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/CsPWv6.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/KBdhXF.jpeg" alt="img"></p>
<h3 id="6）执行init方法初始化"><a href="#6）执行init方法初始化" class="headerlink" title="6）执行init方法初始化"></a>6）执行init方法初始化</h3><p>属性的显示初始化，代码块初始化，构造器初始化</p>
<h2 id="36-对象访问定位"><a href="#36-对象访问定位" class="headerlink" title="36.对象访问定位"></a>36.对象访问定位</h2><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p>定位，通过栈上reference访问。创建对象的目的是为了使用它。对象访问方式主要有两种：</p>
<h3 id="1）句柄访问"><a href="#1）句柄访问" class="headerlink" title="1）句柄访问"></a>1）句柄访问</h3><p><img src="https://img-blog.csdnimg.cn/20201201005301621.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>优点：引用中存储稳定句柄地址，对象被移动时只会改变句柄中实例数据指针即可，引用本身不需要被修改。</p>
<p>缺点：需要额外维护一个句柄，效率低。</p>
<h3 id="2）直接指针-HotSpot采用"><a href="#2）直接指针-HotSpot采用" class="headerlink" title="2）直接指针(HotSpot采用)"></a>2）直接指针(HotSpot采用)</h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/iyABm8.jpeg" alt="img"></p>
<p>优点：效率高</p>
<h2 id="37-直接内存"><a href="#37-直接内存" class="headerlink" title="37.直接内存"></a>37.直接内存</h2><p>不是虚拟机运行时数据区的一部分，也不是jvm规范中定义的内存区域。</p>
<p>直接内存是在java堆外，直接向系统申请的内存空间。</p>
<p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存，通常，访问直接内存的速度会优于java堆，即读写性能高，因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存，java的NIO库允许java程序使用直接内存，用于数据缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoH</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer BUFFER=<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(BUFFER);</span><br><span class="line">        sc.next();</span><br><span class="line">        byteBuffer=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>也可能导致OOM异常，由于直接内存在java堆外，因此它的大小不会受限于-Xmx指定的最大堆的大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<p>缺点：分配回收成本高，不受JVM内存回收管理，直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致，简单理解java进程内存=java堆+本地内存。</p>
<h2 id="38-执行引擎"><a href="#38-执行引擎" class="headerlink" title="38.执行引擎"></a>38.执行引擎</h2><p>1.虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面的，而虚拟机的执行引擎是由软件自行实现的，因此可以不受物理条件制约的定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/wEYnMw.jpeg" alt="img"></p>
<p>2.jvm的主要作用负责装在字节码到其内部，但是字节码不能直接运行在操作系统之上，执行引擎就是将字节码指令编译为对应平台上的本地机器指令。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201005358144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>3.外观上看：jvm的执行引擎输入输出都是一致的，输入的是字节码二进制流，处理过程是字节码解析执行的过程，输出的是执行结果。</p>
<h2 id="39-java代码的编译和执行过程"><a href="#39-java代码的编译和执行过程" class="headerlink" title="39.java代码的编译和执行过程"></a>39.java代码的编译和执行过程</h2><p><img src="https://img-blog.csdnimg.cn/20201201005418960.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>大部分的程序代码转换为物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的步骤。</p>
<p>为什么java称为半解释型半编译型语言？</p>
<p>因为jvm的执行引擎是解释器和jit即时编译器交互工作的。</p>
<p>什么是解释器？什么是JIT编译器？</p>
<p>解释器：将字节码指令逐行翻译成机器指令并执行</p>
<p>编译器：将源代码直接编译成对应的机器指令。</p>
<h2 id="40-机器码，指令，汇编语言"><a href="#40-机器码，指令，汇编语言" class="headerlink" title="40.机器码，指令，汇编语言"></a>40.机器码，指令，汇编语言</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/cLlemE.jpeg" alt="img"></p>
<p>1.机器码：二进制编码方式表示的机器指令</p>
<p>2.指令，指令集：将机器中特定的0和1简化成对应的指令。每个平台所支持的指令就叫做指令集</p>
<p>3.汇编语言：用助记符代替机器指令的操作码，所以汇编编写的程序还需要翻译成机器指令码</p>
<p>4.高级语言：需要把程序解释和编译成机器的指令码</p>
<p>5.字节码：一种中间状态的二进制文件，实现特定软件运行和软件环境，与硬件环境无关</p>
<h2 id="41-解释器"><a href="#41-解释器" class="headerlink" title="41.解释器"></a>41.解释器</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/nS4szZ.jpeg" alt="img"></p>
<p>解释器其实就是一个运行时翻译者，将字节码文件中的内容翻译为对应平台的本地机器指令执行。当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<p>解释器分类</p>
<p>1.字节码解释器：纯软件代码模拟字节码的执行</p>
<p>2.模板解释器：将每一条字节码指令和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码</p>
<p>基于解释器执行已经沦落为低效的代名词，JIT编译的目的是为了避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行，只执行编译后的机器码即可。</p>
<h2 id="42-JIT即时编译器"><a href="#42-JIT即时编译器" class="headerlink" title="42.JIT即时编译器"></a>42.JIT即时编译器</h2><p><strong>HotSpot采用解释器与即时编译器共存的架构。由JVM决定何时使用哪种方式执行。</strong></p>
<p>解释器可以边解释边执行，这样程序启动时间就会变快，及时编译器是都编译好了在执行，程序启动时间慢。但是一旦jit编译器把越来越多的代码编译成本地代码，执行效率立马起飞。</p>
<p><img src="https://img-blog.csdnimg.cn/20201201005515372.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/rlYdQt.jpeg" alt="img"></p>
<h3 id="1）热点代码以及探测方式"><a href="#1）热点代码以及探测方式" class="headerlink" title="1）热点代码以及探测方式"></a>1）热点代码以及探测方式</h3><p>判断是否启动jit编译器将字节码直接编译为对应平台的本地机器指令，需要根据执行的频率而定。热点代码就是需要被编译为本地代码的字节码，jit在运行时会针对频繁调用的热点代码直接编译为对应平台的本地机器指令，提升性能。</p>
<h3 id="2）OSR编译"><a href="#2）OSR编译" class="headerlink" title="2）OSR编译"></a>2）OSR编译</h3><p>一个方法被多次调用，或者一个方法体内部循环次数较多的循环体都可以被称为热点代码，因此都可以通过jit编译器编译为本地机器指令，也就是栈上替换.hotspot采用的热点探测方式是基于计数器的热点探测。</p>
<p>为每个方法建立2个不同类型的计数器，分别为方法调用计数器和回边计数器</p>
<p>1.方法调用计数器：统计方法调用次数，默认client模式下1500，server模式下100002.回边计数器：统计循环执行次数</p>
<p>当一个方法被调用时，先判断有没有jit编译过，有的话直接使用jit编译后的机器指令，没有的话计数器+1，然后判断两个计数器之和是否超过方法调用计数器的阈值。如果超过，就会向jit发出即时编译申请。</p>
<p>热度衰减是在虚拟机进行垃圾回收的时候顺便进行的，也就是在一段时间方法一直没有执行，计数器的计数就会减半。</p>
<p>可以自己手动设置虚拟机采用哪种编译模式</p>
<h3 id="3）JDK9引入了AOT编译器"><a href="#3）JDK9引入了AOT编译器" class="headerlink" title="3）JDK9引入了AOT编译器"></a>3）JDK9引入了AOT编译器</h3><p>aot编译器在程序执行之前，就将字节码转换为机器码过程。</p>
<p>好处：可以直接运行，不必预热。</p>
<p>坏处：由于提前编译成了机器指令，无法实现java一次编译到处运行。</p>
<h3 id="4）JDK10的Graal编译器"><a href="#4）JDK10的Graal编译器" class="headerlink" title="4）JDK10的Graal编译器"></a>4）JDK10的Graal编译器</h3><p>全新的即时编译器，实验阶段，需要手动开启，前景大好</p>
<h2 id="43-StringTable"><a href="#43-StringTable" class="headerlink" title="43.StringTable"></a>43.StringTable</h2><h2 id="44-String的基本特征"><a href="#44-String的基本特征" class="headerlink" title="44.String的基本特征"></a>44.String的基本特征</h2><p>String字符串使用一对引号引起来表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=“yhd”;</span><br><span class="line">String s2=<span class="keyword">new</span> String(“yhd”);</span><br><span class="line">jdk8:<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">jdk9:<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> value[];</span><br></pre></td></tr></table></figure>



<p>String声明为final，不可被继承。</p>
<p>String类实现了序列化接口，可以跨jvm进行传输，实现了Conparable接口，支持比较大小。</p>
<p>String代表不可变的字符序列，简称不可变性。</p>
<p>1）当对字符串重新赋值，需要重新指定内存区域赋值，不能使用原有的value值。</p>
<p>2）当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有value赋值。</p>
<p>3）当调用String的replace方法修改指定的字符或者字符串时，也需要重新指定内存区域赋值。</p>
<p><strong>一方面数组的长度一旦确定了，就不能再改变，一方面存储在字符串常量池的数据不可发生变化。</strong></p>
<p>通过字面量的方式给一个字符串赋值，此时的字符串值声明在字符串常量池。</p>
<p>字符串常量池不会存储两个相同内容的字符串。</p>
<p>String的底层是一个固定大小的hashtable，默认长度是1009，如果放入StringPool的String特别多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了会影响String.intern的性能。</p>
<p>使用<code>-XX:StringTableSize设置StringTable</code>的长度。</p>
<p>jdk6 StringTable长度固定为1009，字符串多就会造成性能下降。</p>
<p>jdk7 StringTable的长度默认值是60013,jdk8开始1009是可设置的最小值。</p>
<h2 id="45-String内存的分配"><a href="#45-String内存的分配" class="headerlink" title="45.String内存的分配"></a>45.String内存的分配</h2><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：</p>
<p>1）直接使用双引号声明出来的String对象会直接存储在常量池中</p>
<p>2）如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</p>
<p>所有的字符串都保存在堆中，这样调优的时候仅仅需要调整堆的大小就可以了。</p>
<p>StringTable为什么要调整？</p>
<p>1）permSize默认比较小</p>
<p>2）永久代垃圾回收频率低</p>
<h2 id="46-String的基本操作"><a href="#46-String的基本操作" class="headerlink" title="46.String的基本操作"></a>46.String的基本操作</h2><p>java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符串序列，并且必须是指向同一个String类实例。</p>
<h2 id="47-字符串拼接"><a href="#47-字符串拼接" class="headerlink" title="47.字符串拼接"></a>47.字符串拼接</h2><p>1）常量与常量的拼接结果在常量池，原理是编译期优化</p>
<p>2）.常量池中不会存在相同内容的常量</p>
<p>3）只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</p>
<p>4）如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。</p>
<p>5）字符串拼接底层原理分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s4=s1+s2;</span><br><span class="line">    System.out.println(s3==s4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如下的s1+s2的执行细节：</span></span><br><span class="line"><span class="comment">     * ① StringBuilder  s= new StringBuilder();</span></span><br><span class="line"><span class="comment">     * ② s.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">     * ③ s.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">     * ④ s.toString(); //类似于new String(&quot;ab&quot;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">     * 如果拼接符号左右两边都是字符串常量或常量引用。则仍然使用编译器优化，即非</span></span><br><span class="line"><span class="comment">     * StringBuilder的方式。</span></span><br><span class="line"><span class="comment">     * 2.针对于final修饰类，方法，基本数据类型，引用数据类型的结构时，能使用上final</span></span><br><span class="line"><span class="comment">     * 的时候建议使用上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String s1=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String s2=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4=s1+s2;</span><br><span class="line">        System.out.println(s3==s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拼接操作和append操作的效率对比</span><br><span class="line">StringBuilder  s= <span class="keyword">new</span> StringBuilder();<span class="comment">//每次直接编译器优化</span></span><br><span class="line">s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">src+=<span class="string">&quot;a&quot;</span>;<span class="comment">//每次都会创建一个新的StringBuilder 而且还会new String()</span></span><br><span class="line">总结：实际开发，尽量少用空参的list和StringBuilder，防止不断扩容。</span><br></pre></td></tr></table></figure>



<h2 id="48-intern（）的使用"><a href="#48-intern（）的使用" class="headerlink" title="48.intern（）的使用"></a>48.intern（）的使用</h2><p>intern()方法就是确保字符串在内存中只有一份，这样可以节约内存空间，加快字符串操作任务的执行速度，这个值会被存放在字符串内部池。</p>
<p>如何保证变量s指向的是字符串常量池的数据呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span>：String s=“shkstart”;<span class="comment">//字面量定义的方式</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>：String s=<span class="keyword">new</span> String(“shkstart”).intern();</span><br><span class="line"></span><br><span class="line">String s=<span class="keyword">new</span> StringBuilder(“shkstart”).toString().intern();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="keyword">new</span> String(“a”);<span class="comment">//底层创建了两个对象，一个在堆空间，一个在字符串常量池</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> String(“a”)+<span class="keyword">new</span> String(“b”);<span class="comment">//创建了几个对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象1：new StringBuilder();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象2：new String(“a”);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象3：常量池中的a</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象4：new String(“b”);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象5：常量池中的b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对象6：new Sring(“ab”);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>toString()的调用，在字符串常量池中，没有生成”ab”。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String str=<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  <span class="comment">//str指向堆空间的引用地址</span></span><br><span class="line">	String intern = str.intern(); <span class="comment">//intern 指向字符串常量池的引用地址</span></span><br><span class="line">	String str2=<span class="string">&quot;1&quot;</span>; <span class="comment">//指向常量池的地址</span></span><br><span class="line">	System.out.println(str==str2);<span class="comment">//false</span></span><br><span class="line">	System.out.println(intern==str2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	String str3=<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>); <span class="comment">//str3指向堆空间</span></span><br><span class="line">	<span class="comment">//new StringBuilder().append().append().toString();</span></span><br><span class="line">	String intern1 = str3.intern();<span class="comment">//intern1指向字符串常量池</span></span><br><span class="line">	String str4=<span class="string">&quot;11&quot;</span>; <span class="comment">// 常量池</span></span><br><span class="line">	System.out.println(str3==str4);<span class="comment">//false</span></span><br><span class="line">	System.out.println(intern1==str4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	String str5=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);<span class="comment">//str5指向堆空间</span></span><br><span class="line">	String str6=<span class="string">&quot;aa&quot;</span>; <span class="comment">//str6常量池</span></span><br><span class="line">	String intern2 = str5.intern(); <span class="comment">//intern2指向常量池的副本地址</span></span><br><span class="line">	System.out.println(str5==str6);<span class="comment">//false</span></span><br><span class="line">	System.out.println(str6==intern2); <span class="comment">//true</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结String的intern()的使用：</p>
<p>jdk1.6中，将这个字符串对象尝试放入字符串常量池。</p>
<p>1）如果字符串常量池有，则并不会放入。返回已经有的字符串常量池中的对象的地址。</p>
<p>2）如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址。</p>
<p>jdk1.7起，将这个字符串对象尝试放入字符串常量池。</p>
<p>1）如果字符串常量池有，则并不会放入。返回已经有的字符串常量池中的对象的地址。</p>
<p>2）如果没有，则会把对象的引用地址复制一份，放入串池，并返回字符串常量池中的引用地址，所以相当于指向的是对象的引用。</p>
<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String s=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//堆</span></span><br><span class="line">	<span class="comment">//执行完上一行代码，字符串常量池中并没有 ab</span></span><br><span class="line">	String s2=s.intern();<span class="comment">//6：字符串常量池  8：没有创建字符串，而是创建一个引用指向堆中的ab</span></span><br><span class="line">	<span class="comment">//ab 常量池</span></span><br><span class="line">	System.out.println(s2==<span class="string">&quot;ab&quot;</span>); <span class="comment">//8：true 6：true</span></span><br><span class="line">	System.out.println(s==<span class="string">&quot;ab&quot;</span>); <span class="comment">//8：true  6：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String x=<span class="string">&quot;ab&quot;</span>; <span class="comment">//常量池</span></span><br><span class="line">	String s=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//堆</span></span><br><span class="line">	</span><br><span class="line">	String s2=s.intern();<span class="comment">//6：字符串常量池  8：指向常量池ab的引用</span></span><br><span class="line">	<span class="comment">//ab 常量池</span></span><br><span class="line">	System.out.println(s2==<span class="string">&quot;ab&quot;</span>); <span class="comment">//8：true 6：true</span></span><br><span class="line">	System.out.println(s==<span class="string">&quot;ab&quot;</span>); <span class="comment">//8：false  6：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String s1=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">//会在字符串常量池生成 ab，但是str指向的是堆</span></span><br><span class="line">	String s=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>); <span class="comment">//不会再字符串常量池生成 ab</span></span><br><span class="line">	s1.intern();</span><br><span class="line">	String s2=<span class="string">&quot;ab&quot;</span>; <span class="comment">//常量池</span></span><br><span class="line">	System.out.println(s1==s2); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>开发中推荐使用intern（），节省内存空间。</p>
<h2 id="49-StringTable的垃圾回收"><a href="#49-StringTable的垃圾回收" class="headerlink" title="49.StringTable的垃圾回收"></a>49.StringTable的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEachOrdered(i -&gt; String.valueOf(i).intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="50-G1中的String去重操作"><a href="#50-G1中的String去重操作" class="headerlink" title="50.G1中的String去重操作"></a>50.G1中的String去重操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">String s2=<span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>此时s1和s2在堆空间new了两个一模一样的对象，两个对象在同时指向字符串常量池的同一个字符串a，此时G1就会删除一个堆空间的对象，让s1和s2都指向同一个堆空间的对象。</p>
<p><strong>实现</strong></p>
<p>1）当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</p>
<p>2）如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</p>
<p>3）使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会检查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</p>
<p>4）如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</p>
<p>5）如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</p>
<p><strong>命令行选项</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UseStringDeduplication <span class="comment">//开启String去重，默认不开启</span></span><br><span class="line">PrintStringDeduplicationStatistics <span class="comment">//打印详细的去重统计信息</span></span><br><span class="line">StringDeduplicationAgeThreshold <span class="comment">//打到这个年龄的String对象被认为是去重的候选对象</span></span><br></pre></td></tr></table></figure>



<h2 id="51-什么是垃圾？"><a href="#51-什么是垃圾？" class="headerlink" title="51.什么是垃圾？"></a>51.什么是垃圾？</h2><p>在ｊｖｍ进行垃圾回收之前，会先判断哪些对象是垃圾，也就是说，要判断哪些对象可以被销毁了，其占有的空间是可以被回收的。根据ｊｖｍ的架构划分，ｊａｖａ中几乎所有的对象实例都在堆空间中存放，所以垃圾回收也主要是针对堆空间进行垃圾回收。</p>
<p>在ｊｖｍ眼中，垃圾就是指那些在堆空间中存在的，已经死亡的对象，而对于死亡的定义，我们可以简单的将他理解为<strong>不可能再被任何途径使用的对象</strong>。那怎么才能确定一个对象是存活还是死亡呢？这就涉及到了垃圾判断算法，其主要包括引用计数法和可达性分析算法。</p>
<h2 id="52-为什么需要GC？"><a href="#52-为什么需要GC？" class="headerlink" title="52.为什么需要GC？"></a>52.为什么需要GC？</h2><p>对于高级语言来讲，如果不进行GC，内存迟早会消耗殆尽，除了<strong>释放没用的对象</strong>，垃圾回收也可以<strong>清理内存里的记录碎片</strong>。碎片整理将所占用的堆内存移动到堆的一端，以便JVM将整理出的内存分配给新的对象，<strong>没有GC不能保证程序的正常运行</strong>。</p>
<h2 id="53-早期的垃圾回收"><a href="#53-早期的垃圾回收" class="headerlink" title="53.早期的垃圾回收"></a>53.早期的垃圾回收</h2><p>new：申请内存</p>
<p>delete：释放内存</p>
<p>优点：灵活控制内存释放的时间</p>
<p>缺点：频繁申请和释放内存的管理负担，一旦忘记释放，可能会引发内存泄漏从而导致内存溢出，使程序崩溃。</p>
<h2 id="54-Java垃圾回收机制"><a href="#54-Java垃圾回收机制" class="headerlink" title="54.Java垃圾回收机制"></a>54.Java垃圾回收机制</h2><p>1）自动内存管理，降低内存泄漏和内存溢出的风险</p>
<p>2）使程序员更专注与业务代码的开发</p>
<h2 id="55-垃圾判断算法"><a href="#55-垃圾判断算法" class="headerlink" title="55.垃圾判断算法"></a>55.垃圾判断算法</h2><h3 id="１）引用计数法"><a href="#１）引用计数法" class="headerlink" title="１）引用计数法"></a>１）引用计数法</h3><p>在这种算法中，假设堆中每个对象都有一个引用计数器。当一个对象被创建并且初始化赋值以后，对象的计数器就会设置为１，每当有一个地方引用他，计数器的值就会＋１，例如将对象Ｂ赋值给对象Ａ，那么Ｂ被引用，Ｂ的引用计数器就会＋１.</p>
<p>反之，当引用失效的时候，比如一个对象的某个引用被设置了新的值，则之前被引用的对象的计数器就会－１.而那些引用计数为０的对象，就可以称之为垃圾，可以被收集。</p>
<p>特别的，当一个对象被当做垃圾收集时，他引用的任何对象的计数器的值都－１.</p>
<p>优点：实现简单，对程序不被长时间打断的实时环境比较有利</p>
<p>缺点：需要额外的空间来存储计数器，难以检测对象之间的循环依赖</p>
<p>java并没有选择引用计数，是因为其存在一个基本难题，也就是很难处理循环引用关系。</p>
<p>Python如何解决循环引用？手动解决（在合适的时机，接触引用关系）使用弱引用weakref（weakref是Python提供的标准库，为了解决循环依赖）</p>
<h3 id="２）可达性分析算法"><a href="#２）可达性分析算法" class="headerlink" title="２）可达性分析算法"></a>２）可达性分析算法</h3><p>可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。</p>
<p>对象成为可达对象的两个条件：</p>
<p>对象属于跟集中的对象　　　　　对象被一个可达的对象引用</p>
<p><strong>在java语言中，GC ROOTS 包括以下几类元素</strong>：</p>
<p>虚拟机栈中引用的对象（各个线程被调用的方法中使用到的参数，局部变量等）</p>
<p>本地方法栈内JNI（通常说的本地方法）引用的对象</p>
<p>方法区中类静态属性引用的对象（java类的引用类型静态变量）</p>
<p>方法区中常量引用的对象（字符串常量池（String Table）里的引用）</p>
<p>所有被同步锁synchronized持有的对象</p>
<p>java虚拟机内部的引用（基本数据类型对应的class对象，一些常驻的异常对象，系统类加载器）</p>
<p>本地代码缓存</p>
<p>临时的（分代收集，局部回收）</p>
<p><strong>如何判断一个root</strong></p>
<p>由于root采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那他就是一个root。</p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须<code>Stop the World</code>的一个重要原因。</p>
<p>优点：可以解决循环引用的问题，不需要占用额外的空间</p>
<p>缺点：多线程场景下，其他线程可能会更新已经访问过的对象的引用。</p>
<h2 id="56-对象的finalization机制"><a href="#56-对象的finalization机制" class="headerlink" title="56.对象的finalization机制"></a>56.对象的finalization机制</h2><p>java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize方法。finalize方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作。</p>
<p>应该交给垃圾回收机制调用（永远不要主动调用某个对象的finalize方法）</p>
<p>1.在finalize时可能会导致对象复活</p>
<p>2.finalize（）方法的执行时间是没有保障的，他完全由GC线程决定，极端情况下，若不发生GC，则finalize（）将没有执行的机会。</p>
<p>3.一个糟糕的finalize（）会严重影响GC的性能。</p>
<p>从功能上来说，finalize（）与c中的析构函数比较相似，但是java采用的是基于垃圾回收期的自动内存管理机制，所以finalize（）方法在本质上不同于c中西沟函数。</p>
<p><strong>由于finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态</strong>。</p>
<p>可触及的：从根节点开始，可以到达这个对象。</p>
<p>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</p>
<p>不可触及的：对象的finalize（）方法被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize（）只会被调用一次。</p>
<p><strong>判定一个对象是否可回收，至少需要经历两次标记过程</strong></p>
<p>1）如果该对象到GC Roots没有引用链，则进行第一次标记。</p>
<p>2）进行筛选，判断该对象是否有必要执行finalize()</p>
<p>①如果对象没有重写该方法，或者该方法已经被虚拟机调用过，则虚拟机认为没有必要执行，该对象为不可触及</p>
<p>②如果该对象重写了该方法，且没有执行过，那么对象会被插入到一个队列中，由一个虚拟机自动创建的，低优先级的Finalizer线程触发finalize（）执行。</p>
<p>③finalize()是对象逃脱死亡的最后机会，GC线程会对队列中的对象进行第二次标记，如果对象在finalize()中与引用链上的任何一个对象建立了联系，那么在第二次标记时，对象会被移出即将回收集合。之后，对象会再次出现没有引用存在的情况，在这个情况下，finalize()不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()只会被调用一次。</p>
<h2 id="57-使用MAT查看GC-Root"><a href="#57-使用MAT查看GC-Root" class="headerlink" title="57.使用MAT查看GC Root"></a>57.使用MAT查看GC Root</h2><p>MAT是一款功能强大的java堆内存分析器，用于查找内存泄漏以及内存消耗情况。</p>
<h3 id="1）获取dump文件"><a href="#1）获取dump文件" class="headerlink" title="1）获取dump文件"></a>1）获取dump文件</h3><h4 id="①命令行使用jmap"><a href="#①命令行使用jmap" class="headerlink" title="①命令行使用jmap"></a>①命令行使用jmap</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>:<span class="string">\Users\ASUS\Ideaproject\project03\gc&gt;jps</span></span><br><span class="line"><span class="attr">16912</span> <span class="string">Launcher</span></span><br><span class="line"><span class="attr">5056</span> <span class="string">RemoteMavenServer36</span></span><br><span class="line"><span class="attr">13636</span> <span class="string">Jps</span></span><br><span class="line"><span class="attr">14876</span> <span class="string">GetDump</span></span><br><span class="line"><span class="attr">15132</span></span><br><span class="line"></span><br><span class="line"><span class="attr">C</span>:<span class="string">\Users\ASUS\Ideaproject\project03\gc&gt;jmap -dump:format=b,live,file=test1.bin 14876</span></span><br><span class="line"><span class="attr">Dumping</span> <span class="string">heap to C:\Users\ASUS\Ideaproject\project03\gc\test1.bin ...</span></span><br><span class="line"><span class="attr">Heap</span> <span class="string">dump file created</span></span><br></pre></td></tr></table></figure>



<h4 id="②JvisualVM"><a href="#②JvisualVM" class="headerlink" title="②JvisualVM"></a>②JvisualVM</h4><p><img src="https://img-blog.csdnimg.cn/20210319035634941.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="2）使用MAT分析dump文件"><a href="#2）使用MAT分析dump文件" class="headerlink" title="2）使用MAT分析dump文件"></a>2）使用MAT分析dump文件</h3><h4 id="①查看GC-Roots"><a href="#①查看GC-Roots" class="headerlink" title="①查看GC Roots"></a>①查看GC Roots</h4><p><img src="https://img-blog.csdnimg.cn/20210319035702875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="58-使用Jprofiler进行GCRoots淑源"><a href="#58-使用Jprofiler进行GCRoots淑源" class="headerlink" title="58.使用Jprofiler进行GCRoots淑源"></a>58.使用Jprofiler进行GCRoots淑源</h2><h2 id="59-使用Jprofiler分析OOM"><a href="#59-使用Jprofiler分析OOM" class="headerlink" title="59.使用Jprofiler分析OOM"></a>59.使用Jprofiler分析OOM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError //发生OOM时生成dump文件日志</span><br></pre></td></tr></table></figure>



<h2 id="60-标记清除算法"><a href="#60-标记清除算法" class="headerlink" title="60.标记清除算法"></a>60.标记清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法，复制算法，标记-压缩算法。</p>
<p>当堆中的有效内存空间被耗尽时，就会停止整个程序，然后进行两项工作，第一项是标记，第二项则是清除。</p>
<p>标记：从引用跟节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<p>清除：对堆内存从头到尾进行线性遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收。</p>
<p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，存活对象比较多的情况下极为高效。</p>
<p>缺点：标记和清除过程的效率都不高，这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小，对空闲列表的管理会增加分配对象时的工作量；标记清除后会产生大量不连续的内存碎片，虽然空闲区域的大小是足够的，但却可能没有一个单一的区域能满足这次分配所需大小，分配还会失败，不得不触发再一次的垃圾回收。</p>
<p>何为清除：<strong>所谓清除，并不是并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新的对象需要加载时，判断垃圾的位置空间是够够，够就存放</strong>。</p>
<h2 id="61-标记整理算法"><a href="#61-标记整理算法" class="headerlink" title="61.标记整理算法"></a>61.标记整理算法</h2><p>算法标记的过程与标记清除算法中的标记过程一样，但是对标记后出的垃圾对象的处理情况有所不同，他不是直接对可回收对象进行清理，而是让所有的对象都像一端移动，然后直接清理掉端边界以外的内存。在基于标记整理算法的收集齐实现中，一般增加句柄和句柄表。</p>
<p>优点：经过整理之后，新对象的分配只需要通过指针碰撞便能完成，比较简单；使用这种方法，空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p>
<p>缺点：ＧＣ暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新他们的引用地址。</p>
<h2 id="62-复制算法"><a href="#62-复制算法" class="headerlink" title="62.复制算法"></a>62.复制算法</h2><p>复制算法主要是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按照容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还活着的对象复制到另一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p>
<p>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低。所以老年代一般会选用其他算法，如标记整理算法。一种典型的基于复制算法的垃圾回收是<code>stop-and-copy</code>算法，他将堆分为对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。</p>
<p>优点：标记阶段和复制阶段可以同时进行，每次只对一块内存进行回收，运行高效，只需要移动栈顶指针，按顺序分配内存即可，实现简单，内存回收时，不用考虑内存碎片的出现。</p>
<p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p>
<h2 id="63-分代收集算法"><a href="#63-分代收集算法" class="headerlink" title="63.分代收集算法"></a>63.分代收集算法</h2><p>将堆内存划分为新生代，老年代和永久代。新生代又被进一步划分为伊甸园区和幸存者0，幸存者1区。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xms和-Xmx来控制。分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收，以便提高回收效率。</p>
<p>新生代：几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。新生代大小可以由<code>-Xmn</code>来控制，也可以用<code>-XX:SurvivorRatio</code>来控制 Eden 和 Survivor 的比例。</p>
<p>老年代：在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。</p>
<p>永久代：用于存放静态文件（<code>class</code>类、方法）和常量等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些<code>class</code>，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。永久代在 Java SE8 特性中已经被移除了，取而代之的是元空间（<code>MetaSpace</code>），因此也不会再出现<code>java.lang.OutOfMemoryError: PermGen error</code>的错误了。</p>
<p>特别的，在分代收集算法中，对象的存储具有以下特点：</p>
<p>1.对象优先在伊甸园区分配</p>
<p>2.大对象直接进入老年代</p>
<p>3.长期存活的对象将进入老年代，默认为15岁</p>
<p>对于晋升老年代的年龄阈值，为什么是15岁？</p>
<p>实际上，HotSpot虚拟机的对象头其中一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称为<code>mark word</code>。在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么<code>Mark Word</code>的 32bit 空间中 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，其中对象的分代年龄占 4 位，也就是从<code>0000</code>到<code>1111</code>，而其值最大为 15，所以分代年龄也就不可能超过 15 这个数值了。</p>
<p><strong>GC的分类</strong></p>
<p>新生代GC Minor GC ：发生在新生代的垃圾收集动作，因为java对象大多具有朝生夕灭的特性，因此MinorGC非常频繁，一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可以选用复制算法。</p>
<p>老年代GC Major GC：发生在老年代的垃圾回收动作。Major GC 经常会伴随至少一次Minor GC。由于老年代中的对象的生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了之后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”算法或“标记-整理”算法来进行回收。新生代采用空闲指针的方式来控制 GC 触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发 GC。当连续分配对象时，对象会逐渐从 Eden 到 Survivor，最后到老年代。</p>
<h2 id="64-增量收集算法"><a href="#64-增量收集算法" class="headerlink" title="64.增量收集算法"></a>64.增量收集算法</h2><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种STW的状态，在该状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统稳定性。为了解决这个问题，即对实时垃圾收集算法的亚久直接导致增量收集算法的产生。</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程 和应用程序线程交替执行。每次，垃圾收集线程值收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，一直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或复制工作。</p>
<p>缺点：线程切换和上下文的转换消耗性能，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h2 id="65-分区算法"><a href="#65-分区算法" class="headerlink" title="65.分区算法"></a>65.分区算法</h2><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小空间。每一个小空间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<h2 id="66-System-gc-的理解"><a href="#66-System-gc-的理解" class="headerlink" title="66.System.gc()的理解"></a>66.System.gc()的理解</h2><p>在默认情况下，通过system.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行垃圾回收，尝试释放被丢弃对象占用的内存。然而，System.gc()无法保证一定对垃圾收集器的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        <span class="comment">//提醒jvm的垃圾回收期进行垃圾收集，但是不一定马上进行垃圾回收</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用是一样的。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//调用finalize()方法</span></span><br><span class="line">        System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="67-内存溢出与内存泄漏"><a href="#67-内存溢出与内存泄漏" class="headerlink" title="67.内存溢出与内存泄漏"></a>67.内存溢出与内存泄漏</h2><h3 id="1）内存溢出"><a href="#1）内存溢出" class="headerlink" title="1）内存溢出"></a>1）内存溢出</h3><p>内存溢出是相对于内存泄漏来说的，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。大多数情况下，GC会进行各种年龄段的垃圾回收实在不行了就放大招，来一次Full GC操作，这时候会回收大量内存，供应用程序继续使用。javadoc对OOM的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>堆内存不够的原因有两个：java虚拟机的堆内存设置不够。代码中创建了大量的大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
<p>OOM之前，通常垃圾收集器会先进行GC，当然也不是任何情况下垃圾收集器都会被触发：比如我们创建一个超过堆空间大小的对象。</p>
<h3 id="2）内存泄漏"><a href="#2）内存泄漏" class="headerlink" title="2）内存泄漏"></a>2）内存泄漏</h3><p>只有对象不在被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。实际上一些导致对象生命周期变得很长甚至OOM的操作，也称为内存泄漏。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM，导致程序崩溃。</p>
<p>这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存取决于磁盘交换区设定的大小。</p>
<p>Example：</p>
<p>1.单例模式，单例的生命周期默认和应用程序一样长，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，否则会导致内存泄漏的产生。</p>
<p>2.一些提供close的资源未关闭导致内存泄漏（数据库连接，网络连接，io连接）</p>
<h2 id="68-Stop-The-World"><a href="#68-Stop-The-World" class="headerlink" title="68.Stop The World"></a>68.Stop The World</h2><p>指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被停掉，没有任何响应。</p>
<p>STW事件和采用哪款垃圾收集器无关，所有GC都有这个事件。它是由JVM在后台自动发起和自动完成的。</p>
<h2 id="69-垃圾回收的并行与并发"><a href="#69-垃圾回收的并行与并发" class="headerlink" title="69.垃圾回收的并行与并发"></a>69.垃圾回收的并行与并发</h2><h3 id="1）并行"><a href="#1）并行" class="headerlink" title="1）并行"></a>1）并行</h3><p>当系统有一个以上cpu，当一个cpu执行一个进程时，另一个cpu可以执行另一个进程，两个进程互不抢占cpu资源，可以同时进行，我们称之为并行。</p>
<p>其实决定并行因素不是cpu数量，而是cpu的核心数，比如一个cpu多个核也可以并行</p>
<h3 id="2）并发"><a href="#2）并发" class="headerlink" title="2）并发"></a>2）并发</h3><p>一个cpu核心在一个时间段同时处理多个任务，某一个时间点只处理一个任务。</p>
<p>两者对比</p>
<p>并发指的是多个事情在同一时间段同时发生了。</p>
<p>并行指的是多个事情在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。</p>
<p>并行的多个任务之间是不互相抢占资源的。</p>
<p>只有在多cpu或者一个cpu多核的情况下，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
<p>垃圾回收的并发与并行</p>
<p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</p>
<p>串行：相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动垃圾回收器进行垃圾收集。回收完，在启动程序的线程。</p>
<p>并发：指用户线程和垃圾回收线程同时执行。垃圾回收线程在执行时不会停顿用户程序的运行。</p>
<h2 id="70-安全点与安全区域"><a href="#70-安全点与安全区域" class="headerlink" title="70.安全点与安全区域"></a>70.安全点与安全区域</h2><h3 id="1）安全点"><a href="#1）安全点" class="headerlink" title="1）安全点"></a>1）安全点</h3><p>程序执行过程中并不是在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点。</p>
<p>安全点太少可能导致GC等待时间太长，太多可能导致程序运行时的性能问题。</p>
<p>方法调用，循环跳转，异常跳转。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停下来呢？</p>
<p><strong>抢先式中断</strong>（目前没有虚拟机采用了）中断所有线程，哪个没到安全点就恢复线程，让线程跑到安全点。</p>
<p><strong>主动式中断</strong>设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<h3 id="2）安全区域"><a href="#2）安全区域" class="headerlink" title="2）安全区域"></a>2）安全区域</h3><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入的GC安全点，但是假如程序处于sleep状态，这时候线程无法响应jvm的中断请求，走到安全点去中断挂起，jvm也不太可能的等待线程被唤醒。对于这种情况，就需要安全区域来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</p>
<p>实际执行时</p>
<p>当线程运行到安全区域的代码时，首先标识已经进入了安全区域，如果这段时间内发生GC，JVM会忽略标识为安全区域状态的线程。</p>
<p>当线程即将离开安全区域时，会检查jvm是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开安全区域的信号为止。</p>
<h2 id="71-引用"><a href="#71-引用" class="headerlink" title="71.引用"></a>71.引用</h2><p>强引用：<code>Object obj=new Object();</code>　只要强引用还存在，垃圾回收器就永远不会回收掉引用的对象。</p>
<p>软引用：可能还有用，但并非必须的对象，系统内存不足时，这类引用关联的对象将被回收。</p>
<p>弱引用：被弱引用关联的对象只能存活到下一次垃圾回收。</p>
<p>虚引用：就是为了在这个对象被垃圾回收的时候能够获得一个系统通知。</p>
<p>终结器引用：用来实现对象的finalize（）无需手动编码，内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用他的finalize（），第二次GC时才能回收被引用对象。</p>
<h2 id="72-垃圾回收分类"><a href="#72-垃圾回收分类" class="headerlink" title="72.垃圾回收分类"></a>72.垃圾回收分类</h2><p>按照垃圾回收线程分：串行垃圾回收器和并行垃圾回收器</p>
<p>串行回收是指在同一时间段内只允许有一个cpu执行垃圾回收操作，此时工作线程被暂停，直至垃圾回收结束。</p>
<p>并行则是允许运用多个cpu同时执行垃圾回收操作。</p>
<p>按照工作模式分：并发式垃圾回收器和独占式垃圾回收器</p>
<p>并发式垃圾回收器与应用程序线程交替，尽可能减少应用程序暂停时间。</p>
<p>独占式垃圾回收器一旦运行，就禁止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</p>
<p>按照碎片处理方式分类，压缩垃圾回收器和非压缩垃圾回收器</p>
<p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p>
<p>非压缩式的垃圾回收器不进行这步操作。</p>
<p>按照工作的内存区间分：又可分为年轻代的垃圾回收器和老年代的垃圾回收器。</p>
<h2 id="73-评估GC的性能指标"><a href="#73-评估GC的性能指标" class="headerlink" title="73.评估GC的性能指标"></a>73.评估GC的性能指标</h2><p>吞吐量：运行用户代码的时间占总运行时间的比例。（总运行时间=程序运行时间+垃圾回收时间）</p>
<p>暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间。</p>
<p>收集频率：相对于应用程序的执行，收集发生的频率。</p>
<p>内存占用：java堆区所占内存大小。</p>
<p>三者总体表现会随着技术进步越来越好，主要抓住两点：吞吐量和暂停时间。</p>
<p>如果以吞吐量优先，那么必然需要降低内存回收的执行效率，但是这样会导致GC需要更长的时间来执行内存回收。如果选择低延迟优先，为了降低每次内存回收时的暂停时间，也只能频繁的执行内存回收，但又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>
<p>标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
<h2 id="74-不同的垃圾回收器概述"><a href="#74-不同的垃圾回收器概述" class="headerlink" title="74.不同的垃圾回收器概述"></a>74.不同的垃圾回收器概述</h2><h3 id="1）垃圾收集器发展历史"><a href="#1）垃圾收集器发展历史" class="headerlink" title="1）垃圾收集器发展历史"></a>1）垃圾收集器发展历史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.3发布Serial GC 他是第一款GC。ParNew是Serial 的多线程版本。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.4发布Parallel GC 和 Concurrent Mark Sweep GC。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK6之后Parallel GC称为HotSpot默认垃圾回收器。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.7引入G1。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK9把G1变为默认垃圾收集器，替代CMS。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK10中G1垃圾收集器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK11引入Epsilon GC。同时引入ZGC。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK12增强G1，自动返回未使用堆内存给操作系统，同时引入Shenandoah GC。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK13增强ZGC。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK14删除CMS，并拓展ZGC的平台兼容性。</span><br></pre></td></tr></table></figure>



<h3 id="2）垃圾收集器分类"><a href="#2）垃圾收集器分类" class="headerlink" title="2）垃圾收集器分类"></a>2）垃圾收集器分类</h3><p>串行回收器：<code>Serial，Serial Old</code></p>
<p>并行回收器：<code>ParNew，Parallel Scavenge，Parallel Old</code></p>
<p>并发回收器：<code>CMS,Gl</code></p>
<p>新生代收集器：<code>Serial，ParNew，Parallel Scavenge</code></p>
<p>老年代收集器：<code>Serial Old，Parallel Old，CMS</code></p>
<p>整堆收集器：<code>G1</code></p>
<p><strong>为什么要有很多收集器？</strong></p>
<p>因为java使用场景很多，移动端，服务端等。所以就需要针对不同的场景，提供不同的垃圾回收器，提高垃圾收集的性能。</p>
<p>对垃圾收集器进行比较只是对具体应用场景选择最合适的收集器。</p>
<p><strong>如何查看默认的垃圾收集器？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags  查看命令行相关参数（包含垃圾收集器）</span><br><span class="line"></span><br><span class="line">使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</span><br><span class="line"></span><br><span class="line">Parallel Scavenge 和 Parallel Old</span><br></pre></td></tr></table></figure>



<h2 id="75-Serial-回收器（串行回收器）"><a href="#75-Serial-回收器（串行回收器）" class="headerlink" title="75.Serial 回收器（串行回收器）"></a>75.Serial 回收器（串行回收器）</h2><p>jdk1.3之前回收新生代的唯一选择（HotSpot在Client模式下的默认新生代垃圾收集器）</p>
<p>Serial 收集器采用复制算法，串行回收和STW机制的方式执行内存回收。</p>
<p>除了年轻代，Serial收集器还提供用于执行老年代垃圾回收的Serial Old收集器。Serial Old 收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。</p>
<p>Serial Old在Server模式下主要有两个用途：1.与新生代的Parallel Scavenge配合使用 2.作为老年代CMS收集器的后备垃圾收集方案。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/lwcN7o.jpeg" alt="img"></p>
<p>这个收集器是一个单线程的收集器，但他的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到他收集结束。</p>
<p>优势：简单而高效，对于限定单个CPU的环境来讲，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。（运行在Client模式下的虚拟机是个不错的选择）</p>
<p>在HotSpot虚拟机中，使用<code>-XX:UseSerialGC</code> 参数可以指定年轻代和老年代都是用串行收集器。（等价于新生代使用Serial GC，老年代使用Serial Old GC），一般在java web程序中是不会使用这种垃圾回收器的。</p>
<h2 id="76-ParNew回收器（并行回收）"><a href="#76-ParNew回收器（并行回收）" class="headerlink" title="76.ParNew回收器（并行回收）"></a>76.ParNew回收器（并行回收）</h2><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。（Par是Parallel的缩写 New只能处理新生代）</p>
<p>ParNew收集器除了采用并行回收方式执行内存回收外，两款垃圾收集器之间几乎没有差别，也是STW，也是复制算法。</p>
<p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/21K01T.jpeg" alt="img"></p>
<p>对于新生代，回收次数频繁，使用并行高效。对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
<p>由于ParNew收集器是并行回收，那么是否可以断定在任何场景下他的回收效率都比Serial收集器更高效？</p>
<p>1.多核系统下，充分利用系统资源，可以快速完成垃圾收集，提升程序吞吐量。</p>
<p>2.但是单个CPU下，他不一定有Serial收集器更高效。避免了线程切换。</p>
<p><strong>除了Serial 外，目前只有ParNew 能与CMS收集器配合工作。</strong></p>
<p>在程序中，开发人员可以通过选项<code>-XX:UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务 。他表示年轻代使用并行收集器并不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数相同的线程数。</p>
<h2 id="77-Parallel-Scavenge-回收器（吞吐量优先）"><a href="#77-Parallel-Scavenge-回收器（吞吐量优先）" class="headerlink" title="77.Parallel Scavenge 回收器（吞吐量优先）"></a>77.Parallel Scavenge 回收器（吞吐量优先）</h2><h3 id="1）概述"><a href="#1）概述" class="headerlink" title="1）概述"></a>1）概述</h3><p>HotSpot的年轻代除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法，并行回收和STW机制。</p>
<p>那么他的出现是否多此一举呢？</p>
<p>1.和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，他也被称为吞吐量优先的垃圾收集器。</p>
<p>2.自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p>
<p>高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：那些执行批量处理，订单处理，工资支付，科学计算的应用程序。</p>
<p>Parallel 收集器在jdk1.6的时候提供了用于执行老年代垃圾搜集的Parallel Old收集器，用来替代老年代的Serial Old收集器。Parallel Old收集器采用了标记-压缩算法，但是同样也是基于并行回收和STW机制。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203171318542.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>在程序吞吐量优先的场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾回收器。</p>
<h3 id="2）参数配置"><a href="#2）参数配置" class="headerlink" title="2）参数配置"></a>2）参数配置</h3><p><code>-XX:UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
<p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收器。（分别适用于新生代和老年代。默认是JDK8开启的）</p>
<p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般的最好与CPU数量相等，避免线程数影响收集器性能。（默认情况下，CPU数小于8，ParallelGCThreads的值等于CPU数量，当cpu数大于8个的时候，ParallelGCThreads值=3+[5*cpu数]/8 ）</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（STW的时间，单位是ms）</p>
<p>为了尽可能把停顿时间控制在<code>MaxGCPauseMills</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于用户来讲，停顿时间越短，体验越好。但是在服务器端，我们注重高并发，整体的吞吐量，所以服务端适合Parallel，进行控制。（该参数谨慎使用）</p>
<p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间比例（=1/(N+1)）用于衡量吞吐量大小。</p>
<p><code>-XX:UseAdaptiveSizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略</p>
<p>在这种模式下，年轻代的大小，Eden和幸存者的比例，晋升老年代的对象年龄等参数会被自动调整，已经达到在堆大小，吞吐量和停顿时间之间的平衡点。</p>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅仅指定虚拟机的最大堆，目标吞吐量和停顿时间，让虚拟机自己完成调优工作。</p>
<h2 id="78-CMS回收器（低延迟）"><a href="#78-CMS回收器（低延迟）" class="headerlink" title="78.CMS回收器（低延迟）"></a>78.CMS回收器（低延迟）</h2><h3 id="1）概述-1"><a href="#1）概述-1" class="headerlink" title="1）概述"></a>1）概述</h3><p>JDK1.5，这款收集器是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短就越适合于用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>目前很大一部分的java应用集中在互联网或者B/S架构系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停段时间最短，以给用户较好的体验感。</p>
<p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会STW。</strong></p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Parial收集器中的一个。</p>
<p>在G1出现之前，CMS还是非常广泛的，一直到今天，仍然有许多系统使用CMS GC。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/XZSksi.jpeg" alt="img"></p>
<h3 id="2）CMS工作原理"><a href="#2）CMS工作原理" class="headerlink" title="2）CMS工作原理"></a>2）CMS工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始标记：标记出GCROOTS能直接关联到的对象（速度快）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发标记：从GCROOTS的直接关联对象开始遍历整个对象图的过程（耗时长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新标记：修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（时间比初始标记稍微长）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并发清除：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。（由于不需要移动存活的对象，所以这个阶段也是可以与用户线程并发执行的）</span><br></pre></td></tr></table></figure>



<p>初始化标记和再次标记仍然要STW机制，目前所有的来收集器都做不到完全不需要STW，只是尽可能的缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>在CMS回收过程中，还应该确保应用程序线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序在运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动预备方案，临时启动Serial Old收集器来重新收集老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS的垃圾收集算法使用的是标记清除算法，不可避免的会产生内存碎片，无法使用指针碰撞，只能选择空闲列表。</p>
<p>标记清除算法会造成内存碎片，为什么不把算法换成标记整理算法呢？</p>
<p>因为当并发清除时，用标记整理算法整理内存的话，原来的用户线程使用的内存无法继续使用，要保证用户线程还能继续执行，前提是他运行的资源不受影响。</p>
<p>优点：并发收集，低延迟</p>
<p>缺点：会产生内存碎片，对CPU资源敏感（并发阶段，占用了一部分线程导致应用程序变慢，总吞吐量降低），无法处理浮动垃圾（在并发阶段如果产生新的垃圾对象，CMS无法对这些垃圾对象进行标记，最终会导致这些新产生 的垃圾对象没有及时回收，只能在下一次GC的时候释放这些之前未被回收的内存空间）</p>
<h3 id="3）参数设置"><a href="#3）参数设置" class="headerlink" title="3）参数设置"></a>3）参数设置</h3><p><code>-XX:+UseConcMarkSweepGC</code>  手动指定使用CMS收集器执行内存回收任务</p>
<p><code>-XX:CMSlnitiatingOccupanyFraction</code> 设置堆使用率的阈值，一旦达到阈值，便开始垃圾回收</p>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>  用于指定在执行完<code>Full GC</code>后堆内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的的问题就是停顿时间变得更长了。</p>
<p><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置在执行了多少次Full GC后对内存进行压缩整理。</p>
<p><code>-XX:ParallelCMSThreads</code>  设置CMS线程数。CMS默认启动线程数是 <code>（ParallelGCThreads+3）/4</code>，<code>ParallelGCThreads</code> 是年轻代并行收集器的线程数。当CPU资源紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收节点可能会非常糟糕。</p>
<h3 id="4）小技巧"><a href="#4）小技巧" class="headerlink" title="4）小技巧"></a>4）小技巧</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC，Parallel GC，Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<p>最小化的使用内存和并行开销 Serial GC</p>
<p>最大化应用程序的吞吐量 Parallel GC</p>
<p>最小化GC的中断或停顿时间 CMS GC</p>
<h3 id="5）后续版本变化"><a href="#5）后续版本变化" class="headerlink" title="5）后续版本变化"></a>5）后续版本变化</h3><p>JDK9 声明CMS为过时，JDK14直接删掉了，如果使用不会报错，只是会给出警告，并使用默认的垃圾收集器。</p>
<h2 id="79-G1回收器（区域分代化）"><a href="#79-G1回收器（区域分代化）" class="headerlink" title="79.G1回收器（区域分代化）"></a>79.G1回收器（区域分代化）</h2><h3 id="1）概述-2"><a href="#1）概述-2" class="headerlink" title="1）概述"></a>1）概述</h3><p>G1是在java7引入的垃圾回收器，为了适应不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量。</p>
<p>为什么叫G1回收器？</p>
<p>因为G1是一个并行回收器，他把堆内存分割成很多不相关的区域。G1有计划的避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个区域里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间，所以我们给G1一个名字，垃圾优先。</p>
<p>G1主要针对配备多核CPU以及大容量内存的机器，是JDK9以后的默认垃圾回收器，在JDK8还不是默认的垃圾回收器，需要使用<code>-XX:UseGmentGC</code>来启用。</p>
<p>与其他垃圾回收器相比，G1使用了全新的分区算法：</p>
<h3 id="2）特点"><a href="#2）特点" class="headerlink" title="2）特点"></a>2）特点</h3><h4 id="①并行与并发"><a href="#①并行与并发" class="headerlink" title="①并行与并发"></a>①并行与并发</h4><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</p>
<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会再整个回收阶段发生完全阻塞应用程序的情况。</p>
<h4 id="②分代收集"><a href="#②分代收集" class="headerlink" title="②分代收集"></a>②分代收集</h4><p>从分代上看，G1依然属于分代型垃圾回收器，他会区分年轻代和老年代，年轻代依然有Eden区和幸存者区。但从堆的结构上看，他不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
<p>将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代。</p>
<p>和之前的各类回收器不同，他同时兼顾年轻代和老年代。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/xxnV8p.jpeg" alt="img"></p>
<h4 id="③空间整合"><a href="#③空间整合" class="headerlink" title="③空间整合"></a>③空间整合</h4><p>CMS：标记清除算法，内存碎片，若干次GC后进行一次碎片整理。</p>
<p>G1将内存划分为一个个小区域，内存的回收是以一个个小区域为单位的。区域之间是复制算法，但是整体上可以看成标记压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当java堆非常大的时候，G1的优势更加明显。</p>
<h4 id="④可预测的停顿时间"><a href="#④可预测的停顿时间" class="headerlink" title="④可预测的停顿时间"></a>④可预测的停顿时间</h4><p>每次根据允许的收集时间，优先回收价值最大的区域，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h3 id="3）缺点"><a href="#3）缺点" class="headerlink" title="3）缺点"></a>3）缺点</h3><p>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高。</p>
<p>经验上来讲：在小内存应用上CMS的表现大概率会优先于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8G之间。</p>
<h3 id="4）参数设置"><a href="#4）参数设置" class="headerlink" title="4）参数设置"></a>4）参数设置</h3><p><code>-XX:+UseG1GC</code> 手动指定使用G1垃圾收集器执行内存回收任务</p>
<p><code>-XX:G1HeapRegionSize</code> 设置每个区域的大小。值是2的幂，范围是1M-32M之间。</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标</p>
<p><code>-XX:ParallelGCThread</code> 设置STW工作线程数，最多设置为8</p>
<p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数</p>
<p><code>-XX:InitiatingHeapOccupancyPercent</code>  设置触发并发GC周期的java堆占用率阈值。超过此值，就会出发GC。</p>
<h3 id="5）G1调优的步骤"><a href="#5）G1调优的步骤" class="headerlink" title="5）G1调优的步骤"></a>5）G1调优的步骤</h3><p>开启垃圾收集器</p>
<p>设置堆的最大内存</p>
<p>设置最大停顿时间</p>
<p>G1提供了三种垃圾收集模式：YoungGC，Mixed GC和Full GC，在不同的条件下被触发。</p>
<h3 id="6）适用场景"><a href="#6）适用场景" class="headerlink" title="6）适用场景"></a>6）适用场景</h3><p>面向服务端应用，针对具有大内存，多处理器的机器</p>
<p>需要低GC延迟，并具有大堆的应用程序提供解决方案</p>
<p>用来替换掉jdk5的cms</p>
<p>HotSpot垃圾收集器，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾收集过程。</p>
<p>所有的区域都大小相同，并且在JVM生命周期内不会被改变，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离了，他们都是一部分区域的集合。通过区域的动态分配的方式实现逻辑上的连续。</p>
<h3 id="7）Humongous"><a href="#7）Humongous" class="headerlink" title="7）Humongous"></a>7）Humongous</h3><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous，主要存储大对象，如果超过1.5个区域，就放到H。</p>
<p>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果他是一个短期的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个H区，他专门用来存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<h3 id="8）回收过程"><a href="#8）回收过程" class="headerlink" title="8）回收过程"></a>8）回收过程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节</p>
<p>年轻代GC</p>
<p>老年代并发标记过程</p>
<p>混合回收</p>
<p>如果需要，单线程，独占式，高强度的Full GC还是继续存在的。他针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>
<p><img src="https://img-blog.csdnimg.cn/20201203171415489.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年代区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值的时候，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的区域就可以了。同时，这个老年代的区域是和新生代一起被回收的。</p>
<h4 id="①记忆集与写屏障"><a href="#①记忆集与写屏障" class="headerlink" title="①记忆集与写屏障"></a>①记忆集与写屏障</h4><p>一个对象被不同区域引用的问题</p>
<p>一个区域不可能是孤立的，一个区域中的对象可能被其他任意区域中的对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题</p>
<p>回收新生代也不得不同时扫描老年代？</p>
<p>这样的话会降低Minor GC的效率</p>
<p><strong>解决方法</strong></p>
<p>无论G1还是其他垃圾收集器，Jvm都是使用Remembered Set 来避免全局扫描。</p>
<p>每个区域都有一个对应的Remembered Set ；</p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的区域</p>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在区域对应的Remembered Set 中；</p>
<p>当进行垃圾收集时，在GC跟节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<h4 id="②年轻代GC"><a href="#②年轻代GC" class="headerlink" title="②年轻代GC"></a>②年轻代GC</h4><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收Eden区和幸存者区。</p>
<p>首先G1停止应用程序的执行，G1创建回收集，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和幸存者区所有的内存字分段。然后开始进行如下回收：扫描根  更新RSet  处理RSet  复制对象  处理引用</p>
<p>第一阶段，扫描根。</p>
<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，更新RSet。</p>
<p>处理dirty card queue( 见备注)中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>第三阶段，处理RSet.</p>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。第四阶段，复制对象。</p>
<p>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 01d区中空的内存分段。如果Survivor空间不够，Eden空 间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段，处理引用。</p>
<p>处理Soft，Weak，Phantom, Final, JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h4 id="②并发标记过程"><a href="#②并发标记过程" class="headerlink" title="②并发标记过程"></a>②并发标记过程</h4><p>初始标记阶段  根区域扫描  并发标记  再次标记  独占标记  独占清理  并发清理阶段</p>
<p>1.初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发- - 次年轻代GC。</p>
<p>2.根区域扫描(Root Region Scanning) : G1 GC扫描Survivor区直接可达的老年代， 区域对象，并标记被引用的对象。这一-过程必须在young GC之前完成。</p>
<p>3.并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)， 此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p>4.再次标记(Remark):由 于应用程序持续进行，需要修正上一- 次的标记结果。是STW 的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5.独占清理(cleanup,STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p>
<p>➢这个阶段并不会实际上去做垃圾的收集。</p>
<p>6.并发清理阶段:识别并清理完全空闲的区域。</p>
<h4 id="③混合回收"><a href="#③混合回收" class="headerlink" title="③混合回收"></a>③混合回收</h4><p>当越来越多的对象晋升到老年代，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集。从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</p>
<p>混合回收的回收集(Collection Set)包括八分之- -的老年代内存分段，Eden区 内存 分段，Survivor区 内存分段。混合回收的算法和年轻代回收的算法完全一样， 只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<h4 id="④Full-GC"><a href="#④Full-GC" class="headerlink" title="④Full GC"></a>④Full GC</h4><p>G1的初衷就是要避免Full GC的出现，但是如果上述方式不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况下可以通过增大内存解决。</p>
<p>导致G1Full GC的原因可能有两个</p>
<p>Evacuation的时候没有足够的to-space来存放晋升的对象    并发处理过程完成之前空间耗尽</p>
<h4 id="⑤G1回收器优化建议"><a href="#⑤G1回收器优化建议" class="headerlink" title="⑤G1回收器优化建议"></a>⑤G1回收器优化建议</h4><p><strong>年轻代大小</strong></p>
<p>避免使用-Xmn或者-XX:NewRatio等相关选项显式设置年轻代的大小</p>
<p>固定年轻代的大小会覆盖暂停时间目标</p>
<p><strong>暂停时间目标不要太过严苛</strong></p>
<p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p>
<p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
<h2 id="80-垃圾回收器总结"><a href="#80-垃圾回收器总结" class="headerlink" title="80.垃圾回收器总结"></a>80.垃圾回收器总结</h2><h3 id="1）对比"><a href="#1）对比" class="headerlink" title="1）对比"></a>1）对比</h3><table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU的server模式与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记压缩</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记压缩</td>
<td>吞吐量优先</td>
<td>后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记清除</td>
<td>响应速度优先</td>
<td>互联网/BS业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发，并行</td>
<td>新生代，老年代</td>
<td>标记压缩，复制</td>
<td>响应速度优先</td>
<td>服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段 Serial =&gt; Parallel(并行) =&gt;CMS(并发)=&gt;G1=&gt;ZGC</p>
<h3 id="2）垃圾回收器的组合"><a href="#2）垃圾回收器的组合" class="headerlink" title="2）垃圾回收器的组合"></a>2）垃圾回收器的组合</h3><p><img src="https://img-blog.csdnimg.cn/20210319035717659.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="3）怎么选择垃圾回收器？"><a href="#3）怎么选择垃圾回收器？" class="headerlink" title="3）怎么选择垃圾回收器？"></a>3）怎么选择垃圾回收器？</h3><p>1.优先调整堆的大小让JVM自适应完成</p>
<p>2.如果内存小于100M，使用串行收集器</p>
<p>3.如果是单核，单机程序，并且没有停顿时间的要求，串行收集器</p>
<p>4.如果是多CPU，需要高吞吐量，允许停顿时间超过1s，选择并行或者JVM自己选择</p>
<p>5.如果是多CPU，追求低停顿时间，需快速响应，使用并发收集器</p>
<p><strong>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1.</strong></p>
<p>没有最好的收集器，调优是针对特定场景，特定需求。</p>
<h2 id="81-GC日志分析"><a href="#81-GC日志分析" class="headerlink" title="81.GC日志分析"></a>81.GC日志分析</h2><h3 id="1）内存分配与垃圾回收的参数列表"><a href="#1）内存分配与垃圾回收的参数列表" class="headerlink" title="1）内存分配与垃圾回收的参数列表"></a>1）内存分配与垃圾回收的参数列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: +PrintGC` 输出Gc日志。类似: `-verbose:gc</span><br></pre></td></tr></table></figure>



<p><code>-XX: +PrintGCDetails</code>输出GC的详细日志</p>
<p><code>-XX: +PrintGCTimeStamps</code>输出Gc的时间戳( 以基准时间的形式)</p>
<p><code>-XX: +PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如<code>2013-05- 04T21 :53:59.234+0800</code>)</p>
<p><code>-XX: +PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</p>
<p><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</p>
<h3 id="2）GC日志中垃圾回收数据分析"><a href="#2）GC日志中垃圾回收数据分析" class="headerlink" title="2）GC日志中垃圾回收数据分析"></a>2）GC日志中垃圾回收数据分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createtime</span> 2021/3/18 13:37</span></span><br><span class="line"><span class="comment"> * vmoptions:-Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetDump</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">999999999</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">1000000</span>).forEach(i -&gt; <span class="keyword">new</span> GetDump());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[GC</span> <span class="string">(Allocation Failure) [PSYoungGen: 2048K-&gt;496K(2560K)] 2048K-&gt;953K(9728K), 0.0008097 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[GC</span> <span class="string">(Allocation Failure) [PSYoungGen: 1918K-&gt;488K(2560K)] 2375K-&gt;1141K(9728K), 0.0006189 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[GC</span> <span class="string">(Allocation Failure) [PSYoungGen: 488K-&gt;488K(2560K)] 1141K-&gt;1181K(9728K), 0.0005018 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[Full</span> <span class="string">GC (Allocation Failure) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 693K-&gt;1041K(7168K)] 1181K-&gt;1041K(9728K), [Metaspace: 4058K-&gt;4056K(1056768K)], 0.0079747 secs] [Times: user=0.14 sys=0.00, real=0.01 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[GC</span> <span class="string">(Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 1041K-&gt;1041K(9728K), 0.0004530 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">[Full</span> <span class="string">GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 1041K-&gt;987K(7168K)] 1041K-&gt;987K(9728K), [Metaspace: 4056K-&gt;4056K(1056768K)], 0.0072571 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span></span><br><span class="line"></span><br><span class="line"><span class="attr">Heap</span></span><br><span class="line"> <span class="attr">PSYoungGen</span>      <span class="string">total 2560K, used 51K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span></span><br><span class="line">  <span class="attr">eden</span> <span class="string">space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0cc80,0x00000000fff00000)</span></span><br><span class="line">  <span class="attr">from</span> <span class="string">space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span></span><br><span class="line">  <span class="attr">to</span>   <span class="string">space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span></span><br><span class="line"> <span class="attr">ParOldGen</span>       <span class="string">total 7168K, used 987K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span></span><br><span class="line">  <span class="attr">object</span> <span class="string">space 7168K, 13% used [0x00000000ff600000,0x00000000ff6f6d18,0x00000000ffd00000)</span></span><br><span class="line"> <span class="attr">Metaspace</span>       <span class="string">used 4093K, capacity 4642K, committed 4864K, reserved 1056768K</span></span><br><span class="line">  <span class="attr">class</span> <span class="string">space    used 463K, capacity 497K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="attr">Exception</span> <span class="string">in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></span><br></pre></td></tr></table></figure>



<p><strong>参数说明</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; [GC&quot;和&quot; [Full GC&quot; 说明了这次垃圾收集的停顿类型，如果有&quot;Full &quot;则说明GC发生了&quot;Stop The World&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用Serial收集器在新生代的名字是Default New Generation,因此显示的是&quot; [ De fNew&quot; 使用ParNew收集器在新生代的名字会变成&quot; [ParNew&quot;,意思是&quot;Parallel New Generation&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用Parallel Scavenge收 集器在新生代的名字是&quot; [PSYoungGen&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老年代的收集和新生代道理一样， 名字也是收集器决定的</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用G1收集器的话，会显示为&quot;garbage- first heap&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allocation Failure</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt; 704K (9216K)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中括号内: GC回收前年轻代大小，回收后大小，(年轻代总 大小)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">括号外: GC回收前年轻代和老年代大小，回收后大小，( 年轻代和老年代总大小)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user代表用户态回收耗时，sys 内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间</span><br></pre></td></tr></table></figure>



<h2 id="82-日志分析工具的使用"><a href="#82-日志分析工具的使用" class="headerlink" title="82.日志分析工具的使用"></a>82.日志分析工具的使用</h2><p>常用日志分析工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCViewer`,`GCEasy`,`GCHIsto`,`GCLogViewer`,`Hpjmeter`,`garbagecat</span><br></pre></td></tr></table></figure>



<h2 id="83-垃圾回收器的新发展"><a href="#83-垃圾回收器的新发展" class="headerlink" title="83.垃圾回收器的新发展"></a>83.垃圾回收器的新发展</h2><h3 id="1）Epsilon-GC"><a href="#1）Epsilon-GC" class="headerlink" title="1）Epsilon GC"></a>1）Epsilon GC</h3><p>仅仅做内存分配，分配完之后程序直接结束</p>
<h3 id="2）Shenandoah-GC"><a href="#2）Shenandoah-GC" class="headerlink" title="2）Shenandoah GC"></a>2）Shenandoah GC</h3><p>低停顿时间，由红帽开发。</p>
<p>暂停时间与堆大小无关，堆大小并不会影响垃圾收集的停顿时间。</p>
<p>高并发下吞吐量下降。</p>
<h3 id="3）ZGC"><a href="#3）ZGC" class="headerlink" title="3）ZGC"></a>3）ZGC</h3><p>可伸缩，低延迟的垃圾回收器。</p>
<p>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10ms以内的低延迟。</p>
<p>ZGC收集器是一款基于区域内存布局的，不设置分代的，使用了读屏障，染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>
<p>工作过程分为四个阶段：并发标记-并发预备重分配-并发重分配-并发重映射。</p>
<p>除了初始标记是STW的，其余都可并发。</p>
<h2 id="84-类的加载器概述"><a href="#84-类的加载器概述" class="headerlink" title="84.类的加载器概述"></a>84.类的加载器概述</h2><p>类加载器是 JVM 执行类加载机制的前提</p>
<p><strong>ClassLoader 的作用</strong>：</p>
<p><code>ClassLoader</code> 是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，<code>ClassLoader</code> 负责通过各种方式将 Class 信息的二进制数据流读入 <code>JVM</code> 内部，转换为一个与目标类对应的 <code>java.lang.Class</code> 对象实例。然后交给 Java 虚拟机尽心链接、初始化等操作。因此，<code>ClassLoader</code> 在整个装载阶段，只能影响到类的加载，而无法通过 <code>ClassLoader</code> 去改变类的链接和初始化行为。至于它是否可以运行，则由 <code>Execution Engine</code> 决定。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/FUfJJo.jpeg" alt="img"></p>
<p>类加载器最早出现在 Java 1.0 版本中，那个时候只是单纯地为了满足 Java Applet 应用而被研发出来，但如今类加载器却在 OSGI、字节码加解密领域大放异彩。</p>
<p>这主要归功于 Java 虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在 JVM 内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
<h3 id="1）类加载的分类"><a href="#1）类加载的分类" class="headerlink" title="1）类加载的分类"></a>1）类加载的分类</h3><p>类的加载分类：显式加载 vs 隐式加载</p>
<p>Class 文件的显式加载与隐式加载的方式是指 <code>JVM</code> 加载 Class 文件到内存的方式</p>
<p>显式加载指的是在代码中通过调用 <code>ClassLoader</code> 加载 Class 对象，如直接使用 <code>Class.forName(name)</code> 或 <code>this.getClass().getClassLoader().loadClass()</code> 加载 <code>Class</code>对象</p>
<p>隐式加载则是不直接在代码中调用 <code>ClassLoader</code> 的方法加载 Class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 <code>Class</code> 文件时，该类的 <code>Class</code> 文件中引用了另外一个类的对象，此时额外引用的类将通过 <code>JVM</code> 自动加载到内存中。</p>
<p>在日常开发中以上两种方式一般会混合使用。</p>
<h3 id="2）类加载的必要性"><a href="#2）类加载的必要性" class="headerlink" title="2）类加载的必要性"></a>2）类加载的必要性</h3><p>一般情况下，Java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li><p>避免在开发中遇到 java.lang.ClassNotFoundException 异常或 java.lang.NoClassDeFoundError 异常时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p>
</li>
<li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了</p>
</li>
<li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑</p>
</li>
</ul>
<h3 id="3）命名空间"><a href="#3）命名空间" class="headerlink" title="3）命名空间"></a>3）命名空间</h3><h4 id="①何为类的唯一性？"><a href="#①何为类的唯一性？" class="headerlink" title="①何为类的唯一性？"></a>①何为类的唯一性？</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在 Java 虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p>
<h4 id="②命名空间"><a href="#②命名空间" class="headerlink" title="②命名空间"></a>②命名空间</h4><ul>
<li><p>每个类加载器都有自己的命名空间，命名空间由该加载器以及所有的父加载器所加载的类组成</p>
</li>
<li><p>在同一命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类</p>
</li>
<li><p>在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类</p>
</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h3 id="4）类加载机制的基本特征"><a href="#4）类加载机制的基本特征" class="headerlink" title="4）类加载机制的基本特征"></a>4）类加载机制的基本特征</h3><ul>
<li><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 <code>JDK</code> 内部的 <code>ServiceProvider/ServiceLoader</code> 机制，用户可以在标准 <code>API</code> 框架上，提供自己的实现，<code>JDK</code> 也需要提供些默认的参考实现。例如，Java 中 <code>JNDI、JDBC</code>、文件系统、<code>Cipher</code> 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器</p>
</li>
<li><p>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑</p>
</li>
<li><p>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器”邻居”间，同一类型仍然可以被加载多次，因为相互并不可见</p>
</li>
</ul>
<h2 id="85-类加载器分类"><a href="#85-类加载器分类" class="headerlink" title="85.类加载器分类"></a>85.类加载器分类</h2><p>JVM 支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 <code>ClassLoader</code> 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012454685.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<ul>
<li><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父类”加载器</p>
</li>
<li><p>不同类加载器看似是继承(Inheritance)关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用</p>
</li>
</ul>
<p>“父类加载器”并非下层加载器extends上层加载器，而且包含了上层加载器的引用。</p>
<p><strong>具体代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    ClassLoader parent; <span class="comment">//父类加载器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123; <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1）Bootstrap-ClassLoader"><a href="#1）Bootstrap-ClassLoader" class="headerlink" title="1）Bootstrap ClassLoader"></a>1）Bootstrap ClassLoader</h3><ul>
<li><p>这个类加载使用 C/C++ 语言实现的，嵌套在 JVM 内部</p>
</li>
<li><p>它用来加载 Java 的核心库<code>(JAVA_HOME/jre/lib/rt.jar 或 sun.boot.class.path 路径下的内容)</code>。用于提供 JVM 自身需要的类</p>
</li>
<li><p>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</p>
</li>
<li><p>出于安全考虑，Bootstrap 启动类加载器之加载包名为 <code>java、javax、sun</code> 等开头的类</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
</ul>
<p>使用 -XX:+TraceClassLoading 参数</p>
<p>启动类加载器使用 C++ 编写的？Yes！</p>
<p>C/C++：指针函数 &amp; 函数指针、C++ 支持多继承、更加高效</p>
<p>Java ：由 C++ 演变而来，(C++)– 版，单继承</p>
<h3 id="2）Extension-ClassLoader"><a href="#2）Extension-ClassLoader" class="headerlink" title="2）Extension ClassLoader"></a>2）Extension ClassLoader</h3><p>Java 语言编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</p>
<p>继承于 <code>ClassLoader</code> 类</p>
<p>父类加载器为启动类加载器</p>
<p>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 <code>JDK</code> 的安装目录的 <code>jre/lib/ext</code> 子目录下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载</p>
<h3 id="3）AppClassLoader"><a href="#3）AppClassLoader" class="headerlink" title="3）AppClassLoader"></a>3）AppClassLoader</h3><ul>
<li><p>Java 语言编写，由 <code>sun.misc.Launcher$AppClassLoader</code> 实现</p>
</li>
<li><p>继承于 <code>ClassLoader</code> 类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量 <code>classpath</code> 或系统属性 <code>java.class.path</code> 指定路径下的类库</p>
</li>
<li><p>应用程序中的类加载器默认是系统类加载器</p>
</li>
<li><p>它是用户自定义类加载器的默认父加载器</p>
</li>
<li><p>通过 <code>ClassLoader</code> 的 <code>getSystemClassLoader()</code> 方法可以获取到该类加载器</p>
</li>
</ul>
<h3 id="4）User-DIY-ClassLoader"><a href="#4）User-DIY-ClassLoader" class="headerlink" title="4）User DIY ClassLoader"></a>4）User DIY ClassLoader</h3><ul>
<li><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式</p>
</li>
<li><p>体现 Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的 JAR 包，也可以是网络上的远程资源</p>
</li>
<li><p>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例不胜枚举。例如，著名的 OSGI 组件框架，再如 Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无需重新打包发布应用程序就能实现</p>
</li>
<li><p>同时，自定义加载器能够实现应用隔离，例如 Tomcat、Spring 等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比 C/C++ 程序要好太多，想不修改 C/C++ 程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡所有美好的设想</p>
</li>
<li><p>自定义类加载器通常需要继承于 <code>ClassLoader</code></p>
</li>
</ul>
<h2 id="86-测试不同的类加载器"><a href="#86-测试不同的类加载器" class="headerlink" title="86.测试不同的类加载器"></a>86.测试不同的类加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用</p>
<p>获取 ClassLoader 的途径</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012511751.jpg#pic_center" alt="img"></p>
<p><strong>说明：</strong></p>
<p>站在程序的角度看，引导类加载器与另外两种类加载器(系统类加载器和扩展类加载器)并不是同一个层次意义上的加载器，引导类加载器是使用 C++ 语言编写而成的，而另外两种类加载器则是使用 Java 语言编写的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值</p>
<p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 Class.geetClassLoader() 返回的，与数组当中元素类型的类加载器是一样的：如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = <span class="keyword">new</span> String[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br><span class="line"></span><br><span class="line">ClassLoaderTest[] test = <span class="keyword">new</span> ClassLoaderTest[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] inst = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(inst.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//运行结果：null</span></span><br></pre></td></tr></table></figure>



<h2 id="87-ClassLoader源码解析"><a href="#87-ClassLoader源码解析" class="headerlink" title="87.ClassLoader源码解析"></a>87.ClassLoader源码解析</h2><p><code>ClassLoader</code> 与现有类加载的关系：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/MibqQF.jpeg" alt="img"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 <code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承 <code>ClassLoader</code> 类。</p>
<h3 id="1）ClassLoader的主要方法"><a href="#1）ClassLoader的主要方法" class="headerlink" title="1）ClassLoader的主要方法"></a>1）ClassLoader的主要方法</h3><p><code>public final ClassLoader getParent()</code>返回该类加载器的超类加载器</p>
<p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回<code>ClassNotFoundException</code>异常。</p>
<p>该方法中的逻辑就是双亲委派模式的实现。</p>
<p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p>
<p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写<code>loadClass</code>方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中，从前面的分析可知， <code>findClass()</code>方法是在l<code>oadClass()</code>方法中被调用的，当<code>loadClass()</code>方法中父加载器加载失败后，则会调用自己的<code>findClass()</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是<code>ClassLoader</code>类中并没有实现<code>findClass()</code>方法的具体代码逻辑，取而代之的是抛出<code>ClassNotFoundException</code>异常，同时应该知道的是<code>findClass</code>方法通常是和<code>defineClass</code>方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p>
<p><code>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</code>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义<code>ClassLoader</code>子类中可以使用。</p>
<p><code>defineClass()</code>方法是用来将byte字节流解析成<code>JVM</code>能够识别的Class对象(<code>ClassLoader</code>中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p>
<p><code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader的findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 编写findClass方法的逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的class文件字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><code>protected final void resolveClass(Class&lt;?&gt; c)</code>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析(即加载的同时也进行解析)。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>查找名称为name的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例。这个方法是final方法，无法被修改。</p>
<p><code>private final ClassLoader parent</code>它也是一个<code>ClassLoader</code>的实例，这个字段所表示的<code>ClassLoader</code>也称为这个<code>ClassLoader</code>的双亲。在类加载的过程中,<code>ClassLoader</code>可能会将某些请求交予自己的双亲处理。</p>
<h4 id="①loadClass-的剖析"><a href="#①loadClass-的剖析" class="headerlink" title="①loadClass()的剖析"></a>①loadClass()的剖析</h4><p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguig.java.User&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>涉及到对如下方法的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve:true-加载class的同时进行解析操作。</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">       <span class="comment">//首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器。</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载（递归）</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//parent为null:父类加载器是引导类加教器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//当前类的加载器的父类加载器未加载此类or此类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//调用当前ClassLoader的findClass()</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2）SecureClassLoader与URLClassLoader"><a href="#2）SecureClassLoader与URLClassLoader" class="headerlink" title="2）SecureClassLoader与URLClassLoader"></a>2）SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p>
<p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012544891.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="3）ExtClassLoader与AppClassLoader"><a href="#3）ExtClassLoader与AppClassLoader" class="headerlink" title="3）ExtClassLoader与AppClassLoader"></a>3）ExtClassLoader与AppClassLoader</h3><p>了解完<code>URLClassLoader</code>后接着看看剩余的两个类加载器，即拓展类加载器<code>ExtClassLoader</code>和系统类加载<code>AppClassLoader</code>，这两个类都继承自<code>URLClassLoader</code>，是<code>sun.misc.Launcher</code>的静态内部类。</p>
<p><code>sun.misc.Launcher</code>主要被系统用于启动主应用程序，<code>ExtClassLoader</code>和<code>AppClassLoader</code>都是由<code>sun.misc.Launcher</code>创建的，其类主要类结构如下:</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012558316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>我们发现<code>ExtClassLoader</code>并没有重写<code>loadClass()</code>方法，这足矣说明其遵循双亲委派模式，而<code>AppClassLoader</code>重载了<code>loadclass()</code>方法，但最终调用的还是父类<code>loadClass()</code>方法，因此依然遵守双亲委派模式。</p>
<h3 id="4）Class-forName与ClassLoader-loadClass"><a href="#4）Class-forName与ClassLoader-loadClass" class="headerlink" title="4）Class.forName与ClassLoader.loadClass()"></a>4）Class.forName与ClassLoader.loadClass()</h3><p><code>Class.forName()</code>:是一个静态方法,最常用的是<code>Class.forName(String className);</code>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时,会执行类的初始化。</p>
<p>如:<code>Class.forName( &quot;com.atguigu.java.Helloworld&quot;) ;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.loadClass()`:这是一个实例方法,需要一个`ClassLoader`对象来调用该方法。该方法将class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化。该方法因为需要得到个`ClassLoader`对象,所以可以根据需要指定使用哪个类加载器.如: `ClassLoader cl=......;</span><br><span class="line">cl.loadClass (&quot;com.atguigu.java.Helloworld&quot; );</span><br></pre></td></tr></table></figure>



<h2 id="88-双亲委派模型"><a href="#88-双亲委派模型" class="headerlink" title="88.双亲委派模型"></a>88.双亲委派模型</h2><h3 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1)定义与本质"></a>1)定义与本质</h3><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证java平台的安全。</p>
<h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<h4 id="②本质"><a href="#②本质" class="headerlink" title="②本质"></a>②本质</h4><p>规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><img src="https://img-blog.csdnimg.cn/2021032601261098.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210326012623335.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="2）优势与劣势"><a href="#2）优势与劣势" class="headerlink" title="2）优势与劣势"></a>2）优势与劣势</h3><h4 id="①双亲委派机制优势"><a href="#①双亲委派机制优势" class="headerlink" title="①双亲委派机制优势"></a>①双亲委派机制优势</h4><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
<p>保护程序安全，防止核心API被随意篡改</p>
<h4 id="②代码支持"><a href="#②代码支持" class="headerlink" title="②代码支持"></a>②代码支持</h4><p>双亲委派机制在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下:</p>
<p>(1)先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p>(2)判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p>
<p>(3)反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进加载。</p>
<p>(4)如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<h4 id="③举例"><a href="#③举例" class="headerlink" title="③举例"></a>③举例</h4><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>java.lang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String)，最终通过引导类加载器进行加载。</p>
<h4 id="④思考"><a href="#④思考" class="headerlink" title="④思考"></a>④思考</h4><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法,抹去其中的双亲委派机制,仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?</p>
<p>这也不行!因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器还是扩展类加载器，最终都必须调用java.lang.classLoader.defineClass(String,byte[], int, int, ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p>
<h4 id="⑤双亲委托模式的弊端"><a href="#⑤双亲委托模式的弊端" class="headerlink" title="⑤双亲委托模式的弊端"></a>⑤双亲委托模式的弊端</h4><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<h4 id="⑥结论"><a href="#⑥结论" class="headerlink" title="⑥结论:"></a>⑥结论:</h4><p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p>
<p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>
<h3 id="3）破坏双亲委派机制"><a href="#3）破坏双亲委派机制" class="headerlink" title="3）破坏双亲委派机制"></a>3）破坏双亲委派机制</h3><h4 id="①破坏双亲委派机制1"><a href="#①破坏双亲委派机制1" class="headerlink" title="①破坏双亲委派机制1"></a>①破坏双亲委派机制1</h4><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<p><strong>第一次破坏双亲委派机制:</strong></p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="②破坏双亲委派机制2"><a href="#②破坏双亲委派机制2" class="headerlink" title="②破坏双亲委派机制2"></a>②破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制:线程上下文类加载器</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题〈越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码,那该怎么办呢?</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的)，肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的NDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?(SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计:线程上下文类加载器（Thread ContextClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如NDI、JDBC、JCE、JAXB和BT等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/DWQ5xc.jpeg" alt="img"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h4 id="③破坏双亲委派机制3"><a href="#③破坏双亲委派机制3" class="headerlink" title="③破坏双亲委派机制3"></a>③破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制:</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换（Hot Swap)、模块热部署（Hot Deployment）等</p>
<p>IBM公司主导的JSR-291(即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:（不细讲）</p>
<p>1）将以java.*开头的类，委派给父类加载器加载。</p>
<p>2）否则，将委派列表名单内的类，委派给父类加载器加载。</p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明:只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结:</p>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如:OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</p>
<h3 id="4）热替换的实现"><a href="#4）热替换的实现" class="headerlink" title="4）热替换的实现"></a>4）热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如: PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重新定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意:由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示:</p>
<p><img src="https://img-blog.csdnimg.cn/2021032601270166.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="89-沙箱安全机制"><a href="#89-沙箱安全机制" class="headerlink" title="89.沙箱安全机制"></a>89.沙箱安全机制</h2><ul>
<li><p>保护程序安全</p>
</li>
<li><p>保护 Java 原生的 JDK 代码</p>
</li>
</ul>
<p>Java 安全模型的核心就是 Java 沙箱(Sandbox)。什么是沙箱？沙箱就是一个限制程序运行的环境</p>
<p>沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏</p>
<p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样</p>
<p>所有的 Java 程序运行都可以指定沙箱，可以定制安全策略</p>
<h3 id="1）JDK1-0时期"><a href="#1）JDK1-0时期" class="headerlink" title="1）JDK1.0时期"></a>1）JDK1.0时期</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（Sandbox）机制。如下图所示JDK1.0安全模型</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012715392.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="2）JDK1-1时期"><a href="#2）JDK1-1时期" class="headerlink" title="2）JDK1.1时期"></a>2）JDK1.1时期</h3><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/Bcebmz.jpeg" alt="img"></p>
<h3 id="3）JDK1-2时期"><a href="#3）JDK1-2时期" class="headerlink" title="3）JDK1.2时期"></a>3）JDK1.2时期</h3><p>在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012750307.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="4）JDK1-6时期"><a href="#4）JDK1-6时期" class="headerlink" title="4）JDK1.6时期"></a>4）JDK1.6时期</h3><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限（Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6)</p>
<p><img src="https://img-blog.csdnimg.cn/2021032601280669.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="90-自定义类加载器"><a href="#90-自定义类加载器" class="headerlink" title="90.自定义类加载器"></a>90.自定义类加载器</h2><h3 id="1）为什么要自定义类加载器"><a href="#1）为什么要自定义类加载器" class="headerlink" title="1）为什么要自定义类加载器?"></a>1）为什么要自定义类加载器?</h3><ul>
<li>隔离加载类</li>
</ul>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如: Tomcat这类web应用服务器，内部自定义了好几种类加载器，用于隔离同一个web应用服务器上的不同应用程序。（类的仲裁–&gt;类冲突）</p>
<p>修改类加载的方式</p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p>
<ul>
<li>扩展加载源</li>
</ul>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
<ul>
<li>防止源码泄漏</li>
</ul>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
<h3 id="2）常见的场景"><a href="#2）常见的场景" class="headerlink" title="2）常见的场景"></a>2）常见的场景</h3><ul>
<li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。</p>
</li>
<li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</p>
</li>
</ul>
<h3 id="3）注意"><a href="#3）注意" class="headerlink" title="3）注意:"></a>3）注意:</h3><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="4）实现方式"><a href="#4）实现方式" class="headerlink" title="4）实现方式"></a>4）实现方式</h3><p>用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p>
<h4 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader 的子类时候，我们常见的会有两种做法:</p>
<ul>
<li><p>方式一:重写loadclass()方法</p>
</li>
<li><p>重写findClass()方法【推荐】</p>
</li>
</ul>
<h4 id="②对比"><a href="#②对比" class="headerlink" title="②对比"></a>②对比</h4><p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<ul>
<li><p>loadClass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
</li>
<li><p>当编写好自定义类加载器后，便可以在程序中调用loadClass(）方法来实现类加载操作。</p>
</li>
</ul>
<h4 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h4><ul>
<li><p>其父类加载器是系统类加载器</p>
</li>
<li><p>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</p>
</li>
</ul>
<h2 id="91-类加载器Java9新特性"><a href="#91-类加载器Java9新特性" class="headerlink" title="91.类加载器Java9新特性"></a>91.类加载器Java9新特性</h2><p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<p>1.扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform classloader)。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</p>
<p>JDK 9时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HONE>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p>
<p>2.平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/3EVRSl.jpeg" alt="img"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在 JDK9及更高版本的JDK中崩溃。</p>
<p>3.在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p>
<p>4.启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器〈以前是C++实现)，但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</p>
<p>5.类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012211936.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块。</p>
<h2 id="92-jvm监控-JPS-查看正在运行的java进程"><a href="#92-jvm监控-JPS-查看正在运行的java进程" class="headerlink" title="92.jvm监控   JPS-查看正在运行的java进程"></a>92.jvm监控   JPS-查看正在运行的java进程</h2><h3 id="1）概述-3"><a href="#1）概述-3" class="headerlink" title="1）概述"></a>1）概述</h3><p><code>jps</code>：显式指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p>
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID时一致的，是唯一的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130426364.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="2）基本语法"><a href="#2）基本语法" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]  //可以通过追加参数，打印额外信息</span><br></pre></td></tr></table></figure>



<h4 id="①options参数"><a href="#①options参数" class="headerlink" title="①options参数"></a>①options参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-q :仅仅显示LVMID (local virtual machine id), 即本地虚拟机唯一-id。 不显示主类的名称等</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l:输出应用程序主类的全类名或如果进程执行的是jar包，则输出jar完整路径</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m:输出虚拟机进程启动时传递给主类main()的参数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v: 列出虚拟机进程启动时的JVM参数。比如: -Xms20m -Xmx50m是 启动程序指定的jvm参数。</span><br></pre></td></tr></table></figure>



<p>说明:以上参数可以综合使用。</p>
<p>补充:</p>
<p><strong>如果某Java进程关闭了默认开启的UsePerfData参数(即使用参数</strong><code>**-XX:-UsePerfData**</code><strong>) ，那么jps命令(以及下面介绍的jstat)将无法探知该Java进程。</strong></p>
<p>如何将信息输入到同级文件中：</p>
<p>语法：命令 &gt; 文件名称</p>
<h4 id="②hostid参数"><a href="#②hostid参数" class="headerlink" title="②hostid参数"></a>②hostid参数</h4><p>RMI注册表中注册的主机名。</p>
<p>如果想要远程监控主机上的java 程序，需要安装jstatd。</p>
<p>对于具有更严格的安全实践的网络场所而言，可能使用-一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击。</p>
<p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd服务器， 而是在本地使用jstat和jps工具。</p>
<h2 id="93-jvm监控-jstat-查看JVM统计信息"><a href="#93-jvm监控-jstat-查看JVM统计信息" class="headerlink" title="93.jvm监控   jstat-查看JVM统计信息"></a>93.jvm监控   jstat-查看JVM统计信息</h2><h3 id="1）概述-4"><a href="#1）概述-4" class="headerlink" title="1）概述"></a>1）概述</h3><p>jstat(JVM Statistics Monitoring Tool): 用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p>
<h3 id="2）基本语法-1"><a href="#2）基本语法-1" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h &lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;] ]</span><br></pre></td></tr></table></figure>



<p>其中vmid是进程id号</p>
<h4 id="①option参数"><a href="#①option参数" class="headerlink" title="①option参数"></a>①option参数</h4><p>选项option可以由以下值构成。</p>
<p>●类装载相关的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-class: 显示ClassLoader的相关信息: 类的装载、卸载数量、总空间、类装载所消耗的时间等</span><br></pre></td></tr></table></figure>



<p>●垃圾回收相关的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gc: 显示与GC相关的堆信息。包括Eden区、两个Survivor区、 老年代、永久代等的容量、己用空间、GC时间合计等信息。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gccapacity:显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcutil:显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gccause:与-gcuti1功能一样，但是会额外输出导致最后-一次或当前正在发生的GC产生的原因。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcnew: 显示新生代GC状况</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcnewcapacity: 显示内容与-gcnew基 本相同，输出主要关注使用到的最大、最小空间</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-geold: 显示老年代GC状况</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcoldcapacity: 显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-gcpermcapacity:显示永久代使用到的最大、最小空间。</span><br></pre></td></tr></table></figure>



<p>●JIT相关的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-compiler: 显示JIT编译器编译过的方法、耗时等信息</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-printcompilation: 输出已经被JIT编译的方法</span><br></pre></td></tr></table></figure>



<p>以-GC为例：</p>
<p><strong>新生代相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0C是第一个幸存者区的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S1C是第二个幸存者区的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S0U是第一个幸存者区已使用的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S1U是第二个幸存者区已使用的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EC是Eden空间的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EU是Eden空间已使用大小（字节）</span><br></pre></td></tr></table></figure>



<p><strong>老年代相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OC是老年代的大小（字节）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OU是老年代已使用的大小（字节）</span><br></pre></td></tr></table></figure>



<p><strong>方法区相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MC是方法区的大小</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MU是方法区已使用的大小</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCSC是压缩类空间的大小</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CCSU是压缩类空间已使用的大小</span><br></pre></td></tr></table></figure>



<p><strong>其他</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YGC是从应用程序启动到采样时young gc的次数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YGCT是指从应用程序启动到采样时young gc消耗时间（秒）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGC是从应用程序启动到采样时full gc的次数</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGCT是从应用程序启动到采样时的full gc的消耗时间（秒）</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GCT是从应用程序启动到采样时gc的总时间</span><br></pre></td></tr></table></figure>



<h4 id="②interval参数"><a href="#②interval参数" class="headerlink" title="②interval参数"></a>②interval参数</h4><p>用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p>
<h4 id="③count参数"><a href="#③count参数" class="headerlink" title="③count参数"></a>③count参数</h4><p>用于指定查询的总次数</p>
<h4 id="④-t参数"><a href="#④-t参数" class="headerlink" title="④-t参数"></a>④-t参数</h4><p>可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p>
<p>我们可以比较Java进程的启动时间以及总GC时间(GCT列)，或者两次测量的间隔时间以及总GC时间的增量，来得出GC时间占运行时间的比例。</p>
<p>如果该比例超过20%， 则说明目前堆的压力较大;如果该比例超过90%，则说明堆里几乎没有可用空间，随时都可能抛出00M异常。</p>
<p>我们执行jstat -gc -t 13152 1000 10，这代表1秒打印出1行，一共10行，-t代表打印出Timestamp总运行时间，结果如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130440992.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h4 id="⑤-h参数"><a href="#⑤-h参数" class="headerlink" title="⑤-h参数"></a>⑤-h参数</h4><p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p>
<h3 id="3）补充-1"><a href="#3）补充-1" class="headerlink" title="3）补充"></a>3）补充</h3><p>jstat还可以用来判断是否出现内存泄漏。</p>
<p>第1步:</p>
<p>在长时间运行的Java程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中ou列(即己占用的老年代内存)的最小值。</p>
<p>第2步:</p>
<p>然后，我们每隔- 段较长的时间重复- -次上述操作， 来获得多组ou最小值。 如果这些值呈 上 涨趋势，则说明该Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p>
<h2 id="94-jvm监控-jinfo-实时查看和修改JVM参数"><a href="#94-jvm监控-jinfo-实时查看和修改JVM参数" class="headerlink" title="94.jvm监控   jinfo-实时查看和修改JVM参数"></a>94.jvm监控   jinfo-实时查看和修改JVM参数</h2><h3 id="1）概述-5"><a href="#1）概述-5" class="headerlink" title="1）概述"></a>1）概述</h3><p>jinfo(Configuration Info for Java)</p>
<p>查看虛拟机配置参数信息，也可用于调整虚拟机的配置参数。</p>
<p>在很多情况不，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虛拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虛拟机参数的当前值。</p>
<h3 id="2）基本语法-2"><a href="#2）基本语法-2" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><h4 id="①查看"><a href="#①查看" class="headerlink" title="①查看"></a>①查看</h4><p><code>jinfo -sysprops 进程id</code> 可以查看由System.getProperties()取得的参数</p>
<p><code>jinfo -flags 进程id</code>  查看曾经赋过值的一些参数</p>
<p><code>jinfo -flag 参数名称 进程id</code> 查看某个java进程的具体参数信息</p>
<h4 id="②修改"><a href="#②修改" class="headerlink" title="②修改"></a>②修改</h4><p>jinfo不仅可以查看运行时某-个Java虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p>
<p>但是，并非所有参数都支持动态修改。参数只有被标记为manageable的f1ag可以被实时修改其实，这个修改能力是极其有限的。</p>
<p>可以查看被标记为manageable的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX: +PrintFlagsFinal -version| grep manageable</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210322130454851.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><strong>针对boolean类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag [+|-]参数名称 进程id</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag +PrintGCDetails 18232</span><br></pre></td></tr></table></figure>



<p><strong>针对非boolean类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag 参数名称=参数值 进程id</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag MaxHeapFreeRatio=90 8600</span><br></pre></td></tr></table></figure>



<h3 id="3）拓展"><a href="#3）拓展" class="headerlink" title="3）拓展"></a>3）拓展</h3><p><code>java -XX:+PrintFlagsInitial</code> 查看所有JVM参数启动的初始值</p>
<p><code>java -XX:+PrintFlagsFinal</code>查看所有JVM参数的最终值</p>
<p><code>java -参数名称:+PrintCommandLineFlags</code>查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p>
<h2 id="95-jvm监控-jmap-导出内存映像文件-amp-内存使用情况"><a href="#95-jvm监控-jmap-导出内存映像文件-amp-内存使用情况" class="headerlink" title="95.jvm监控   jmap-导出内存映像文件&amp;内存使用情况"></a>95.jvm监控   jmap-导出内存映像文件&amp;内存使用情况</h2><h3 id="1）概述-6"><a href="#1）概述-6" class="headerlink" title="1）概述"></a>1）概述</h3><p><code>jmap(JVM Memory Map)</code>: 作用一 方面是获取dump文件(堆转储快照文件，二进制文件)，它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。</p>
<p>开发人员可以在控制台中输入命令“<code>jmap -help</code>“查阅jmap工具的具体使用方式和一 些标准选项配置。</p>
<h3 id="2）基本语法-3"><a href="#2）基本语法-3" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] &lt;pid&gt;</span><br><span class="line">jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用语法可以通过在DOS窗口中使用jmap/jmap -h/jmap -help查看</span><br><span class="line">&lt;executable &lt;core&gt;代表可执行的代码，比如使用&gt; 文件名称来指定生成的dump文件的生成位置</span><br><span class="line">[server_id@]&lt;……&gt;是为远程连接准备的</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dump:生成Java堆转储快照：dump文件,特别的：-dump:live只保存堆中的存活对象</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-heap:输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-histo:输出堆中对象的同级信息，包括类、实例数量和合计容量,特别的：-histo:live只统计堆中的存活对象</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-permstat:以ClassLoader为统计口径输出永久代的内存状态信息(仅linux/solaris平台有效)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-finalizerinfo:显示在F-Queue中等待Finalizer线程执行finalize方法的对象(仅linux/solaris平台有效)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-F:当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件(仅linux/solaris平台有效)</span><br></pre></td></tr></table></figure>



<h3 id="3-导出内存映像文件"><a href="#3-导出内存映像文件" class="headerlink" title="3)导出内存映像文件"></a>3)导出内存映像文件</h3><p>一般来说， 使用jmap指 令生成dump文件的操作算得上是最常用的jmap命令之一， 将堆中所有存活对象导出至一一个文件之中。</p>
<p>Heap Dump又叫做堆存储文件，指-个Java进 程在某个时间点的内存快照。</p>
<p>说明:</p>
<p>1.通常在写Heap Dump文件前会触发一 次Fu1l GC， 所以heap dump文件里保存的都是Fu11GC后留下的对象信息。</p>
<p>2.由于生成dump文件比较耗时，因此大家需要耐心等待，尤其是大内存镜像生成dump文件则需要耗费更长的时间来完成。</p>
<p>注意：</p>
<p>对于以上说明中的第1点是自动方式才会这样做，而手动不会在<code>Full GC</code>之后生成<code>Dump</code></p>
<p>使用手动方式生成dump文件，一般指令执行之后就会生成，不用等到快出现<code>OOM</code>的时候</p>
<p>使用自动方式生成<code>dump</code>文件，当出现<code>OOM</code>之前先生成<code>dump</code>文件</p>
<p>如果使用手动方式，一般使用第2种，毕竟生成堆中存活对象的dump文件是比较小的，便于传输和分析</p>
<h4 id="①手动"><a href="#①手动" class="headerlink" title="①手动"></a>①手动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br><span class="line">jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<p>由于<code>jmap</code>将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<code>jmap</code> 需要借助安 全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由<code>jmap</code> 导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p>
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。</p>
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一 直等 下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p>
<h4 id="②自动"><a href="#②自动" class="headerlink" title="②自动"></a>②自动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=&lt;filename.hprof&gt;</span><br></pre></td></tr></table></figure>



<p>当程序发生00M退出系统时，一些瞬时信息都随着程序的终止而消失，而重现00M问题往往比较困难或者耗时。此时若能在0OM时，自动导出dump文件就显得非常迫切。</p>
<p>这里介绍一种比较常用的取得堆快照文件的方法，即使用:<code>-XX: +HeapDump0nOutOfMemoryError</code>:在程序发生0OM时，导出应用程序的当前堆快照。<code>-XX:HeapDumpPath</code>:可以指定堆快照的保存位置。</p>
<p>比如:<code>-Xmx100m -XX: +HeapDumpOnOutOfMemoryError -XX: HeapDumpPath=D: \m . hprof</code></p>
<h3 id="4-显示堆内存相关信息"><a href="#4-显示堆内存相关信息" class="headerlink" title="4)显示堆内存相关信息"></a>4)显示堆内存相关信息</h3><h4 id="①jmap-heap-进程id"><a href="#①jmap-heap-进程id" class="headerlink" title="①jmap -heap 进程id"></a>①jmap -heap 进程id</h4><p>jmap -heap 进程id只是时间点上的堆信息，而jstat后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具，例如jvisualvm等，它们可以用图表的方式动态展示出相关信息，更加直观明了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 3540 &gt;a.txt</span><br></pre></td></tr></table></figure>



<h4 id="②jmap-histo-进程id"><a href="#②jmap-histo-进程id" class="headerlink" title="②jmap -histo 进程id"></a>②jmap -histo 进程id</h4><p>输出堆中对象的同级信息，包括类、实例数量和合计容量，也是这一时刻的内存中的对象信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 3540 &gt;b.txt</span><br></pre></td></tr></table></figure>



<h3 id="5）其他作用"><a href="#5）其他作用" class="headerlink" title="5）其他作用"></a>5）其他作用</h3><p>这两个指令仅linux/solaris平台有效，所以无法在windows操作平台上演示。</p>
<p><code>jmap -permstat 进程id</code> 查看系统的ClassLoader信息</p>
<p><code>jmap -finalizerinfo</code>查看堆积在finalizer队列中的对象</p>
<h2 id="96-jvm监控-jhat-JDK自带堆分析工具"><a href="#96-jvm监控-jhat-JDK自带堆分析工具" class="headerlink" title="96.jvm监控   jhat-JDK自带堆分析工具"></a>96.jvm监控   jhat-JDK自带堆分析工具</h2><p>jhat命令在jdk9及其之后就被移除了，官方建议使用jvisualvm代替jhat，所以该指令只需简单了解一下即可.</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1)概述"></a>1)概述</h3><p>Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件(堆转 储快照)。jhat内置了-个微 型的HTTP/HTML服务器， 生成dump 文件的分析结果后，用户可以在浏览器中查看分析结果(分析虚拟机转储快照信息)。</p>
<p>使用了jhat命令， 就启动了一个http服务，端口是7000， 即<a target="_blank" rel="noopener" href="http://localhost:7000/,%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/,就可以在浏览器里分析。</a></p>
<p>说明: jhat 命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替。</p>
<h3 id="2）基本语法-4"><a href="#2）基本语法-4" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [option] [dumpfile]</span><br></pre></td></tr></table></figure>



<p>其中dumpfile代表dump文件的地址以及名称,<code>jhat d:\3.hprof</code>。</p>
<h4 id="①options参数-1"><a href="#①options参数-1" class="headerlink" title="①options参数"></a>①options参数</h4><table>
<thead>
<tr>
<th>-stack falseltrue</th>
<th>关闭|打开对象分配调用栈跟踪</th>
</tr>
</thead>
<tbody><tr>
<td>-refs falseltrue</td>
<td>关闭|打开对象引用跟踪</td>
</tr>
<tr>
<td>-port port-number</td>
<td>设置jhat HTTP，Server的端口号，默认7000</td>
</tr>
<tr>
<td>-exclude exclude-file</td>
<td>执行对象查询时需要排除的数据成员</td>
</tr>
<tr>
<td>-baseline exclude-file</td>
<td>指定一个基准堆转储</td>
</tr>
<tr>
<td>-debug int</td>
<td>设置debug级别</td>
</tr>
<tr>
<td>-version</td>
<td>启动后显示版本信息就退出</td>
</tr>
<tr>
<td>-J</td>
<td>传入启动参数，比如-J -Xmx512m</td>
</tr>
</tbody></table>
<h2 id="97-jvm监控-jstack-打印JVM中线程快照"><a href="#97-jvm监控-jstack-打印JVM中线程快照" class="headerlink" title="97.jvm监控   jstack-打印JVM中线程快照"></a>97.jvm监控   jstack-打印JVM中线程快照</h2><h3 id="1）概述-7"><a href="#1）概述-7" class="headerlink" title="1）概述"></a>1）概述</h3><p>jstack(JVM Stack Trace): 用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。线程快照就是当前虛拟机内指定进程的每–条线程正在执行的方法堆栈的集合。</p>
<p>生成线程快照的作用:可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况。</p>
<p>在thread dump中， 要留意下面几种状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">死锁，Deadlock (重点关注)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等待资源，Waiting on condition (重点关注)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等待获取监视器，Waiting on monitor entry (重点关注)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阻塞，Blocked (重点关注)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行中，Runnable</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂停，Suspended</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象等待中，object .wait()或TIMED_ WAITING</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">停止，Parked</span><br></pre></td></tr></table></figure>



<h3 id="2）基本语法-5"><a href="#2）基本语法-5" class="headerlink" title="2）基本语法"></a>2）基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack option pid</span><br></pre></td></tr></table></figure>



<p>如果程序出现等待问题，可以使用该指令去查看问题所在。</p>
<h4 id="①option参数-1"><a href="#①option参数-1" class="headerlink" title="①option参数"></a>①option参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-F：当正常输出的请求不被响应时，强制输出线程堆栈</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l：除堆栈外，显示关于锁的附加信息</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-m：如果调用本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-h：帮助操作</span><br></pre></td></tr></table></figure>



<h2 id="98-jvm监控-jcmd-多功能命令行"><a href="#98-jvm监控-jcmd-多功能命令行" class="headerlink" title="98.jvm监控   jcmd-多功能命令行"></a>98.jvm监控   jcmd-多功能命令行</h2><h3 id="1）概述-8"><a href="#1）概述-8" class="headerlink" title="1）概述"></a>1）概述</h3><p>在JDK 1.7以后，新增了一个命令行工具jcmd。</p>
<p>它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如:用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。</p>
<p>jcmd拥有jmap的大部分功能， 并且在0racle的官方网站上也推荐使用jcmd命令代jmap命令。</p>
<h3 id="2）语法"><a href="#2）语法" class="headerlink" title="2）语法"></a>2）语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd -l 列出所有的JVM进程</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 进程号 help	针对指定的进程，列出支持的所有具体命令</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd 进程号 具体命令	显示指定进程的指令命令的数据</span><br></pre></td></tr></table></figure>



<h2 id="99-jvm监控-jstatd-远程主机信息收集"><a href="#99-jvm监控-jstatd-远程主机信息收集" class="headerlink" title="99.jvm监控   jstatd-远程主机信息收集"></a>99.jvm监控   jstatd-远程主机信息收集</h2><p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远 程计算机的监控(如jps、 jstat)。为了启用远程监控，则需要配合使用jstatd 工具。</p>
<p>命令jstatd是-一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监 控工具的通信。 jstatd服务器将本机的Java应用程序信息传递到远程计算机。</p>
<h2 id="100-jvm监控-Eclipse-MAT"><a href="#100-jvm监控-Eclipse-MAT" class="headerlink" title="100.jvm监控   Eclipse MAT"></a>100.jvm监控   Eclipse MAT</h2><h3 id="1）概述-9"><a href="#1）概述-9" class="headerlink" title="1）概述"></a>1）概述</h3><p>功能强大的java堆内存分析器，可以用于查找堆内存泄漏和内存消耗情况。MAT是基于eclipse开发的，可以单独使用或者以插件形式嵌入到eclipse。</p>
<h3 id="2）获取堆dump文件"><a href="#2）获取堆dump文件" class="headerlink" title="2）获取堆dump文件"></a>2）获取堆dump文件</h3><h4 id="①dump文件内存"><a href="#①dump文件内存" class="headerlink" title="①dump文件内存"></a>①dump文件内存</h4><p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的hprof文件，通过MAT打开就可以直观地看到当前的内存信息。</p>
<p>一般说来，这些内存信息包含:</p>
<p>●所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</p>
<p>● 所有的类信息，包括classloader、 类名称、父类、静态变量等</p>
<p>GCRoot到所有的这些对象的引用路径</p>
<p>线程信息，包括线程的调用栈及此线程的线程局部变量(TLS)</p>
<h3 id="2）说明"><a href="#2）说明" class="headerlink" title="2）说明"></a>2）说明</h3><p>说明1:缺点:</p>
<p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun, HP, SAP所采用的HPROF 二进制堆存储文件，以及IBM的PHD堆存储文件等都能被很好的解析。</p>
<p>说明2：</p>
<p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到-键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p>
<h3 id="3）获取dump文件"><a href="#3）获取dump文件" class="headerlink" title="3）获取dump文件"></a>3）获取dump文件</h3><p>方法一:通过前一章介绍的jmap工具生成，可以生成任意-一个java进程的dump文件;</p>
<p>方法二:通过配置JVM参数生成。</p>
<p>● 选项”-XX: +HeapDumpOnOutOfMemoryError”或”-XX: +HeapDumpBeforeFullGC”</p>
<p>● 选项”-XX:HeapDumpPath”所代表的含义就是当程序出现0utofMemory时，将会在相应的目录下 生成一份dump文件。如果不指定选项“-XX:HeapDumpPath” 则在当前目录下生成dump文件。</p>
<p>对比:考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此使用jmap+MAT工具是最常见的组合。</p>
<p>方法三:使用VisualVM可以导出堆dump文件</p>
<p>方法四:</p>
<p>使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照。 该功能将借助jps列出当前正在运行的Java 进程，以供选择并获取快照。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/OzmcgB.jpg" alt="img"></p>
<h3 id="4）分析堆dump文件"><a href="#4）分析堆dump文件" class="headerlink" title="4）分析堆dump文件"></a>4）分析堆dump文件</h3><h4 id="①histogram"><a href="#①histogram" class="headerlink" title="①histogram"></a>①histogram</h4><p>展示了各个类的实例数目以及这些实例的Shallow heap或者Retained heap的总和。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/oltv0d.jpeg" alt="img"></p>
<p>具体内容：</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130548842.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h4 id="②thread-overview"><a href="#②thread-overview" class="headerlink" title="②thread overview"></a>②thread overview</h4><p>查看系统中的Java线程    查看局部变量的信息</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/VSCJHr.jpeg" alt="img"></p>
<h4 id="③获得对象互相引用的关系"><a href="#③获得对象互相引用的关系" class="headerlink" title="③获得对象互相引用的关系"></a>③获得对象互相引用的关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with outgoing references</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210322130618136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with incoming references</span><br></pre></td></tr></table></figure>



<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/pIXbNO.jpeg" alt="img"></p>
<h4 id="④浅堆与深堆"><a href="#④浅堆与深堆" class="headerlink" title="④浅堆与深堆"></a>④浅堆与深堆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shallow heap</span><br></pre></td></tr></table></figure>



<p>对象头代表根据类创建的对象的对象头，还有对象的大小不是可能向8字节对齐，而是就向8字节对齐。</p>
<p>浅堆(Shallow Heap)是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会成8字节进行对齐。</p>
<p>以String为例: 2 个int值共占8字节，对象引用占用4字节，对象头8字节，合计20字节，向8字节对齐，故占24字节。(jdk7中)</p>
<table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>hash</td>
<td>0</td>
</tr>
<tr>
<td>ref</td>
<td>value</td>
<td>C:\Users\ASUS</td>
</tr>
</tbody></table>
<p>这24字节为String对象的浅堆大小。它与String的value实际取值无关，无论字符串长度如何，浅堆大小始终是24字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retained heap</span><br></pre></td></tr></table></figure>



<p>保留集(Retained Set):</p>
<p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合(包括对象A本身)，即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象A所持有的对象的集合。</p>
<p>深堆(Retained Heap):</p>
<p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意:浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的(直接或间接)所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象实际大小</span><br></pre></td></tr></table></figure>



<p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和 被人接受， 但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大 小只是A本身， 不含C和D,而A的实际大小为A、 C、D三者之 和。而A的深堆大小为A与D之和， 由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/EIHaTv.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练习</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210322130700395.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>A对象的Retained Size=A对象的Shallow Size</p>
<p>B对象的Retained Size=B对象的Shallow Size+C对象的Shallow Size</p>
<p>这里不包括D对象，因为D对象被GC Roots直接引用</p>
<p>如果GC Roots不引用D对象呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130713181.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">案例分析：StudentTrace</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span></span><br><span class="line"><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=c:\code\student.hprof</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTrace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> ArrayList&lt;WebPage&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createWebPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            WebPage wp = <span class="keyword">new</span> WebPage();</span><br><span class="line">            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">            wp.setContent(Integer.toString(i));</span><br><span class="line">            webpages.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        createWebPages();<span class="comment">//创建了100个网页</span></span><br><span class="line">        <span class="comment">//创建3个学生对象</span></span><br><span class="line">        Student st3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Student st5 = <span class="keyword">new</span> Student(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Student st7 = <span class="keyword">new</span> Student(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)</span><br><span class="line">                st3.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)</span><br><span class="line">                st5.visit(webpages.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)</span><br><span class="line">                st7.visit(webpages.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        webpages.clear();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WebPage&gt; <span class="title">getHistory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> history;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WebPage wp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            history.add(wp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/20210322130727125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>结论：</p>
<p>elementData数组的浅堆是80个字节，而elementData数组中的所有WebPage对象的深堆之和是1208个字节，所以加在一起就是elementData数组的深堆之和，也就是1288个字节。</p>
<p>解释：</p>
<p>我说“elementData数组的浅堆是80个字节”，其中15个对象一共是60个字节，对象头8个字节，数组对象本身4个字节，这些的和是72个字节，然后总和要是8的倍数，所以“elementData数组的浅堆是80个字节”</p>
<p>我说“WebPage对象的深堆之和是1208个字节”，一共有15个对象，其中0、21、42、63、84、35、70不仅仅是7的倍数，还是3或者5的倍数，所以这几个数值对应的i不能计算在深堆之内，这15个对象中大多数的深堆是152个字节，但是i是0和7的那两个深堆是144个字节，所以(13<em>152+144</em>2)-(6*152+144)=1208，所以这也印证了我上面的话，即“WebPage对象的深堆之和是1208个字节”。</p>
<p>因此“elementData数组的浅堆80个字节”加上“WebPage对象的深堆之和1208个字节”，正好是1288个字节，说明“elementData数组的浅堆1288个字节”。</p>
<h4 id="⑤支配树"><a href="#⑤支配树" class="headerlink" title="⑤支配树"></a>⑤支配树</h4><p>支配树( Dominator Tree)支配树的概念源自图论。</p>
<p>MAT提供了一个称为支配树(Dominator Tree)的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质:</p>
<p>●对象A的子树(所有被对象A支配的对象集合)表示对象A的保留集(retained set) ，即深堆。</p>
<p>●如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</p>
<p>●支配树的边与对象引用图的边不直接对应。</p>
<p>如下图所示:左图表示对象引用图，右图表示左图所对应的支配树。对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A，也可以经过B，因此对象C的直接支配者也是根对象。对象F与对象D相互引用，因为到对象F的所有路径必然经过对象D，因此，对象D是对象F的直接支配者。而到对象D的所有路径中，必然经过对象C，即使是从对象F到对象D的引用，从根节点出发，也是经过对象C的，所以，对象D的直接支配者为对象C。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130740750.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>同理，对象E支配对象G。到达对象H的可以通过对象D，也可以通过对象E，因此对象D和E都不能支配对象H，而经过对象C既可以到达对象D也可以到达对象E，因此对象C为对象H的直接分配者。</p>
<p>注意：</p>
<p>跟随我一起来理解如何从“对象引用图—》支配树”，首先需要理解支配者（如果要到达对象B，毕竟经过对象A，那么对象A就是对象B的支配者，可以想到支配者大于等于1），然后需要理解直接支配者（在支配者中距离对象B最近的对象A就是对象B的直接支配者，你要明白直接支配者不一定就是对象B的上一级，然后直接支配者只有一个），然后还需要理解支配树是怎么画的，其实支配树中的对象与对象之间的关系就是直接支配关系，也就是上一级是下一级的直接支配者，只要按照这样的方式来作图，肯定能从“对象引用图—》支配树”。</p>
<p><strong>在Eclipse MAT工具中如何查看支配树</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20210322130754293.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="5）案例：Tomcat堆溢出分析"><a href="#5）案例：Tomcat堆溢出分析" class="headerlink" title="5）案例：Tomcat堆溢出分析"></a>5）案例：Tomcat堆溢出分析</h3><h4 id="①说明"><a href="#①说明" class="headerlink" title="①说明"></a>①说明</h4><p>Tomcat是最常用的Java Servlet容器之一，同时也可以当做单独的Web服务器使用。Tomcat本身使 用Java实现，并运行于Java虚拟机之上。在大规模请求时，Tomcat有 可能会因为无法承受压力而发生内存溢出错误。这里根据一个被压垮的Tomcat的堆快照文件，来分析Tomcat在崩溃时的内部情况。</p>
<h4 id="②分析过程"><a href="#②分析过程" class="headerlink" title="②分析过程"></a>②分析过程</h4><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/d9JQo2.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/DiBceH.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/SK0LMS.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/LthasO.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/pZnT6F.jpeg" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210322131029144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210322131039996.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210322131049645.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="6）支持使用OQL语言查询对象信息"><a href="#6）支持使用OQL语言查询对象信息" class="headerlink" title="6）支持使用OQL语言查询对象信息"></a>6）支持使用OQL语言查询对象信息</h3><p>SELECT子句    FROM子句    WHERE子句    内置对象与方法</p>
<h2 id="101-jvm监控-Arthas"><a href="#101-jvm监控-Arthas" class="headerlink" title="101.jvm监控  Arthas"></a>101.jvm监控  Arthas</h2><p><img src="/Users/a58/Documents/hexoWorkspase/dog-lee-blog/source/_posts/12.%E9%9D%A2%E8%AF%95/1-%E5%90%AF%E5%8A%A8%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF%E6%8A%A5%E9%94%99.jpg" alt="img"></p>
<h3 id="1）基本概述"><a href="#1）基本概述" class="headerlink" title="1）基本概述"></a>1）基本概述</h3><h4 id="①背景"><a href="#①背景" class="headerlink" title="①背景"></a>①背景</h4><p>不需要远程连接，也不需要配制监控参数，同时也提供了丰富的性能监控数据</p>
<h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>Arthas (阿尔萨斯) 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启 ;动态跟踪Java代码; 实时监控JVM状态。</p>
<p>Arthas 支持JDK 6+， 支持Linux/Mac/Windows, 采用命令行交互模式，同时提供丰富的Tab 自动补全功能，进–步方便进行问题的定位和诊断。</p>
<p>当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决:</p>
<p>●这个类从哪个jar包加载的?为什么会报各种类相关的Exception?</p>
<p>●我改的代码为什么没有执行到?难道是我没commit?分支搞错了?</p>
<p>●遇到问题无法在线上debug, 难道只能通过加日志再重新发布吗?</p>
<p>●线上遇到某个用户的数据处理有问题，但线上同样无法debug,线下无法重现!</p>
<p>●是否有一个全局视角来查看系统的运行状况?</p>
<p>●有什么办法可以监控到JVM的实时运行状态?</p>
<p>●怎么快速定位应用的执占，生成火焰图2</p>
<h4 id="③基于哪些工具开发而来"><a href="#③基于哪些工具开发而来" class="headerlink" title="③基于哪些工具开发而来"></a>③基于哪些工具开发而来</h4><p>greys- anatomy: Arthas代码基 于Greys =二次开发而来，非常感谢Greys之前所有的工作，以及Greys原作者对Arthas提出的意见和建议!</p>
<p>termd: Arthas 的命令行实现基于termd开发，是一款优秀的命令行程序开发框架，感谢termd提供了优秀的框架。</p>
<p>crash: Arthas的文本渲染功能基于crash中的文本渲染功能开发，可以从这里看到源码，感谢crash在这方面所做的优秀工作。</p>
<p>cli: Arthas的命令行界面基于vert. x提供的cli库进行开发，感谢vert . x在这方面做的优秀工作。</p>
<p>compiler Arthas 里的内存编绎器代码来源</p>
<p>Apache Commons Net Arthas 里的Telnet Client 代码来源</p>
<p>JavaAgent:运行在main方法之前的拦截器，它内定的方法名叫premain ，也就是说先执行premain方法然后再执行main方法</p>
<p>ASM:一个通用的Java字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动 态生成类。ASM提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用(当然也可以以静态方式使用，例如在编译器中)</p>
<h4 id="④官方文档"><a href="#④官方文档" class="headerlink" title="④官方文档"></a>④官方文档</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://arthas.aliyun.com/doc/quick-start.html</span><br></pre></td></tr></table></figure>



<h3 id="2）安装与使用"><a href="#2）安装与使用" class="headerlink" title="2）安装与使用"></a>2）安装与使用</h3><h4 id="①安装"><a href="#①安装" class="headerlink" title="①安装"></a>①安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure>



<h4 id="②工程目录"><a href="#②工程目录" class="headerlink" title="②工程目录"></a>②工程目录</h4><p>arthas-agent:基于JavaAgent技术的代理</p>
<p>bin:–些启动脚本</p>
<p>arthas- boot: Java版 本的一键安装启动脚本</p>
<p>arthas-client: telnet client代码</p>
<p>arthas - common:一些共用的工具类和枚举类</p>
<p>arthas-core:核心库，各种arthas命令的交互和实现</p>
<p>arthas-demo:示例代码</p>
<p>arthas -memorycompiler:内存编绎器代码，Fork from <a target="_blank" rel="noopener" href="https://github.com/skalogs/SkaETL/tree/master/compiler">https://github.com/skalogs/SkaETL/tree/master/compiler</a></p>
<p>arthas-packaging: maven打 包相关的</p>
<p>arthas-site: arthas站点</p>
<p>arthas-spy:编织到目标类中的各个切面</p>
<p>static:静态资源</p>
<p>arthas-testcase:测试</p>
<h4 id="③启动"><a href="#③启动" class="headerlink" title="③启动"></a>③启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>



<h4 id="④查看进程"><a href="#④查看进程" class="headerlink" title="④查看进程"></a>④查看进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>



<h4 id="⑤查看日志"><a href="#⑤查看日志" class="headerlink" title="⑤查看日志"></a>⑤查看日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/logs/arthas/arthas.log</span><br></pre></td></tr></table></figure>



<h4 id="⑥查看帮助"><a href="#⑥查看帮助" class="headerlink" title="⑥查看帮助"></a>⑥查看帮助</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br></pre></td></tr></table></figure>



<h4 id="⑦web-console"><a href="#⑦web-console" class="headerlink" title="⑦web console"></a>⑦web console</h4><p>除了在命令行查看外，Arthas 目前还支持Web Console。 在成功启动连接进程之后就已经自动启 动，可以直接访问<a target="_blank" rel="noopener" href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p>
<h4 id="⑧退出"><a href="#⑧退出" class="headerlink" title="⑧退出"></a>⑧退出</h4><p>最后一行[arthas@7457]$， 说明打开进入了监控客户端，在这里就可以执行相关命令进行查看了。</p>
<p>使用quit\exit:退出当前客户端</p>
<p>使用stop\shutdown:关闭arthas服 务端,并退出所有客户端。</p>
<h3 id="3）相关诊断指令"><a href="#3）相关诊断指令" class="headerlink" title="3）相关诊断指令"></a>3）相关诊断指令</h3><h4 id="①基础指令"><a href="#①基础指令" class="headerlink" title="①基础指令"></a>①基础指令</h4><p>●help- -查看命令帮助信息</p>
<p>●cat- - -打印文件内容,和linux里的cat命令类似</p>
<p>●echo-打印参数，和linux里的echo命令类似</p>
<p>●grep– -匹配查找，和linux里的grep命令类似</p>
<p>●tee– -复制标准输入到标准输出和指定的文件，和linux里的tee命令类似</p>
<p>pwd- - -返回当前的工作目录，和linux命令类似</p>
<p>●cls– -清空当前屏幕区域</p>
<p>●session- - 查看当前会话的信息</p>
<p>●reset– 重置增强类，将被Arthas增强过的类全部还原，Arthas服务端关闭时会重置所有增强过的类 ●version– 输出当前目标Java进程所加载的Arthas版本号</p>
<p>●history- – 打印命令历史</p>
<p>●quit- -退出当前Arthas客户端，其他Arthas客户端不受影响</p>
<p>●stop–关闭Arthas服务端，所有Arthas客户端全部退出</p>
<p>●keymap- - - Arthas快捷键列表及自定义快捷键</p>
<h4 id="②jvm相关"><a href="#②jvm相关" class="headerlink" title="②jvm相关"></a>②jvm相关</h4><p>●dashboard- -当前系统的实时数据面板</p>
<p>●thread- - _查看当前JVM的线程堆栈信息</p>
<p>●jvm–查看当前JVM的信息</p>
<p>●sysprop–查看和修改JVM的系统属性</p>
<p>●sysenv- –查看JVM的环境变量</p>
<p>●vmoption- – -查看和修改JVM里诊断相关的option</p>
<p>●perfcounter- – 查看当前JVM的Perf Counter信息</p>
<p>●logger–查看和修改logger</p>
<p>●getstatic– 查看类的静态属性</p>
<p>●ognl- – 执行ogn装达式</p>
<p>●mbean– _查看Mbean的信息</p>
<p>●heapdump- – -dump java heap,类似jmap命令的heap dump功能</p>
<h4 id="③class-classloader相关"><a href="#③class-classloader相关" class="headerlink" title="③class/classloader相关"></a>③class/classloader相关</h4><p>●SC–查看JM已加载的类信息</p>
<p>●sm–查看已加载类的方法信息</p>
<p>●jad–反编译指定已加载类的源码</p>
<p>●mc- -内存编译器,内存编译. java文件为.class文件</p>
<p>●retransform- - - 加载外部的.class文件, retransform到JVM里，</p>
<p>● redefine– 加载外部的.class文件, redefine到JVM里</p>
<p>●dump– -dump已加载类的byte code到特定目录</p>
<p>●classloader– 查看classloader的继承树， urls, 类加载信息,使用classloader去getResource</p>
<h4 id="④monitor-watch-trace相关"><a href="#④monitor-watch-trace相关" class="headerlink" title="④monitor/watch/trace相关"></a>④monitor/watch/trace相关</h4><p>monitor–方法抉行監控</p>
<p>watch- – -方法丸行数跼規測</p>
<p>trace– -方法内部凋用路径，并輸出方法路径上的毎个芍点上耗肘</p>
<p>stack- – -輸出当前方法被凋用的凋用路径</p>
<p>tt–方法丸行数据的吋空隧道，記彖下指定方法毎次調用的入参和返回信息，并能対文些不同的吋同下凋用迸行規測</p>
<h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><p>使用&gt;将结果重写到日志文件，使用&amp;指令命令是后台运行，session断开不影响任务执行(生命周期默认为1天)</p>
<p>jobs:列出所有job</p>
<p>kill:强制终止任务</p>
<p>fg:将暂停的任务拉到前台执行</p>
<p>bg:将暂停的任务放到后台执行</p>
<p>grep:搜索满足条件的结果</p>
<p>plaintext :将命令的结果去除ANSI颜色 WC :;按行统计输出结果</p>
<p>options:查看或设置Arthas全局开关</p>
<p>profiler :使用async-profiler对应用采样，生成火焰图</p>
<h2 id="102-再谈内存泄漏"><a href="#102-再谈内存泄漏" class="headerlink" title="102.再谈内存泄漏"></a>102.再谈内存泄漏</h2><h3 id="1）内存泄露的理解与分析"><a href="#1）内存泄露的理解与分析" class="headerlink" title="1）内存泄露的理解与分析"></a>1）内存泄露的理解与分析</h3><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题(让JVM误以为此对象还在引用中，无法回收，造成内存泄漏)。</p>
<p>是否还被使用? 是</p>
<p>是否还被需要? 否</p>
<p>内存泄漏(memory leak) 的理解</p>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致0OM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322131843311.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>对象X引用对象Y,X的生命周期比Y的生命周期长;</p>
<p>那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的;</p>
<p>如果对象X还引用着生命周期比较短的A、B、C,对象A又引用着对象a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p>内存泄漏与内存溢出的关系:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.内存泄漏(memory leak )</span><br></pre></td></tr></table></figure>



<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M 的内存一-直不回收，那么可以 用的内存只有512M 了，仿佛泄露掉了一部分;</p>
<p>通俗一点讲的话，内存泄漏就是[占着茅坑不拉shi]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.内存溢出(out of memory )</span><br></pre></td></tr></table></figure>



<p>申请内存时，没有足够的内存可以使用;</p>
<p>通俗一点儿讲，-一个厕所就三个坑，有两个站着茅坑不走的(内存泄漏)，剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位(内存)就不够了，内存泄漏变成内存溢出了。</p>
<p>可见，内存泄漏和内存溢出的关系:内存泄漏的增多，最终会导致内存溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泄漏的分类</span><br></pre></td></tr></table></figure>



<p>经常发生:发生内存泄露的代码会被多次执行，每次执行，泄露一块内存;</p>
<p>偶然发生:在某些特定情况下才会发生</p>
<p>一次性:发生内存泄露的方法只会执行一次;</p>
<p>隐式泄漏:一 直占着内存不释放，直到执行结束;严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p>
<h3 id="2）Java中内存泄露的8种情况"><a href="#2）Java中内存泄露的8种情况" class="headerlink" title="2）Java中内存泄露的8种情况"></a>2）Java中内存泄露的8种情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-静态集合类</span><br></pre></td></tr></table></figure>



<p>静态集合类，如HashMap、 LinkedList等等。 如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2-单例模式</span><br></pre></td></tr></table></figure>



<p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和JVM的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3-内部类持有外部类</span><br></pre></td></tr></table></figure>



<p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。</p>
<p>这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4-各种连接，如数据库连接、网络连接和IO连接等</span><br></pre></td></tr></table></figure>



<p>各种连接，如数据库连接、网络连接和IO连接等。</p>
<p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。</p>
<p>否则，如果在访问数据库的过程中，对Connection、 Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5-变量不合理的作用域</span><br></pre></td></tr></table></figure>



<p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null,很有可能导致内存泄漏的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6-改变哈希值</span><br></pre></td></tr></table></figure>



<p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是String为什么被设置成了不可变类型，我们可以放心地把String 存入HashSet,或者把 String当做HashMap 的key值;</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">例<span class="number">2</span>：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示内存泄漏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7-缓存泄露</span><br></pre></td></tr></table></figure>



<p>内存泄漏的另一个常见来源是缓存，- -旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载-个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/oWfe4u.jpeg" alt="img"></p>
<p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函 数执行完成后，局部变量字 符串引用weakd1 ,weakd2,d1,d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以 看到，调用gc之后，HashMap的没有被回收，而WeakHashMap 里面的缓存被回收了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8-监听器和回调</span><br></pre></td></tr></table></figure>



<p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p>
<h3 id="3）内存泄露案例分析"><a href="#3）内存泄露案例分析" class="headerlink" title="3）内存泄露案例分析"></a>3）内存泄露案例分析</h3><h4 id="①代码"><a href="#①代码" class="headerlink" title="①代码"></a>①代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②分析"><a href="#②分析" class="headerlink" title="②分析"></a>②分析</h4><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数，下面通过这张图示展现</p>
<p>假设这个栈- -直增长，增长后如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20210322132052316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>当进行大量的POP操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210322132104493.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>从上图可以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，这个内存泄漏很隐蔽。</p>
<h4 id="③解决办法"><a href="#③解决办法" class="headerlink" title="③解决办法"></a>③解决办法</h4><p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elements[--size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="https://img-blog.csdnimg.cn/20210322132116326.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="103-GC日志格式"><a href="#103-GC日志格式" class="headerlink" title="103.GC日志格式"></a>103.GC日志格式</h2><h3 id="1）GC分类"><a href="#1）GC分类" class="headerlink" title="1）GC分类"></a>1）GC分类</h3><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集（Partial GC)，一种是整堆收集（Full GC)</p>
<p><strong>部分收集</strong>:不晕完整收集整个Java堆的垃圾收集。其中又分为:</p>
<p>·<strong>新生代收集</strong>(Minor GC / Young GC）:只是新生代（Eden\Se,S1）的垃圾收集·老年代收集（Major Gc / old GC):只是老年代的垃圾收集。</p>
<p>·目前，只有cMS GC会有单独收集老年代的行为。</p>
<p>·注意，很多时候Major GC会和FullGC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p>
<p>·<strong>混合收集</strong>（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。</p>
<p>·目前,只有G1 GC会有这种行为。</p>
<p><strong>整堆收集</strong>（Ful1 GC):收集整个java堆和方法区的垃圾收集。</p>
<p>新生代收集：当Eden区满的时候就会进行新生代收集，所以新生代收集和S0区域和S1区域无关。</p>
<p>老年代收集和新生代收集的关系：进行老年代收集之前会先进行一次年轻代的垃圾收集，原因如下：一个比较大的对象无法放入新生代，那它自然会往老年代去放，如果老年代也放不下，那会先进行一次新生代的垃圾收集，之后尝试往新生代放，如果还是放不下，才会进行老年代的垃圾收集，之后在往老年代去放，这是一个过程，我来说明一下为什么需要往老年代放，但是放不下，而进行新生代垃圾收集的原因，这是因为新生代垃圾收集比老年代垃圾收集更加简单，这样做可以节省性能。</p>
<p>进行垃圾收集的时候，堆包含新生代、老年代、元空间/永久代：可以看出Heap后面包含着新生代、老年代、元空间，但是我们设置堆空间大小的时候设置的只是新生代、老年代而已，元空间是分开设置的。</p>
<p>哪些情况会触发Full GC：老年代空间不足、方法区空间不足、显示调用System.gc()、Minior GC进入老年代的数据的平均大小 大于 老年代的可用内存、大对象直接进入老年代，而老年代的可用空间不足。</p>
<h3 id="2）不同GC分类的GC细节"><a href="#2）不同GC分类的GC细节" class="headerlink" title="2）不同GC分类的GC细节"></a>2）不同GC分类的GC细节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  -XX:+PrintCommandLineFlags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+UseSerialGC:表明新生代使用Serial GC ，同时老年代使用Serial Old GC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+UseParNewGC：标明新生代使用ParNew GC</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+UseParallelGC:表明新生代使用Parallel GC</span></span><br><span class="line"><span class="comment"> *  -XX:+UseParallelOldGC : 表明老年代使用 Parallel Old GC</span></span><br><span class="line"><span class="comment"> *  说明：二者可以相互激活</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  -XX:+UseConcMarkSweepGC：表明老年代使用CMS GC。同时，年轻代会触发对ParNew 的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 17:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCUseTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>];<span class="comment">//10kb</span></span><br><span class="line">            list.add(arr);</span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(5);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="①老年代使用CMS-GC"><a href="#①老年代使用CMS-GC" class="headerlink" title="①老年代使用CMS GC"></a>①老年代使用CMS GC</h4><p>GC设置方法：参数中使用<code>-XX:+UseConcMarkSweepGC</code>，说明老年代使用<code>CMS GC</code>，同时年轻代也会触发对ParNew的使用，因此添加该参数之后，新生代使用ParNew GC，而老年代使用CMS GC，整体是并发垃圾收集，主打低延迟。</p>
<h4 id="②新生代使用Serial-GC"><a href="#②新生代使用Serial-GC" class="headerlink" title="②新生代使用Serial GC"></a>②新生代使用Serial GC</h4><p>GC设置方法：参数中使用<code>-XX:+UseSerialGC</code>，说明新生代使用Serial GC，同时老年代也会触发对Serial Old GC的使用，因此添加该参数之后，新生代使用Serial GC，而老年代使用<code>Serial Old GC</code>，整体是串行垃圾收集。</p>
<h3 id="3）GC日志分类"><a href="#3）GC日志分类" class="headerlink" title="3）GC日志分类"></a>3）GC日志分类</h3><h4 id="①MinorGC"><a href="#①MinorGC" class="headerlink" title="①MinorGC"></a>①MinorGC</h4><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/1tbyvZ.jpeg" alt="img"></p>
<h4 id="②FullGC"><a href="#②FullGC" class="headerlink" title="②FullGC"></a>②FullGC</h4><p><img src="https://img-blog.csdnimg.cn/20210322132218411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="4）GC日志结构剖析"><a href="#4）GC日志结构剖析" class="headerlink" title="4）GC日志结构剖析"></a>4）GC日志结构剖析</h3><h4 id="①垃圾收集器"><a href="#①垃圾收集器" class="headerlink" title="①垃圾收集器"></a>①垃圾收集器</h4><p>使用Serial收集器在新生代的名字是<code>Default New Generation</code>，因此显示的是<code>&quot;[DefNew&quot;</code>·</p>
<p>使用ParNew收集器在新生代的名字会变成<code>&quot;[ParNew&quot;</code>,意思是<code>&quot;Parallel New Generation&quot;</code>·</p>
<p>使用parallel Scavenge收集器在新生代的名字是<code>&quot;[PSYoungGen&quot;</code> ,这里的3DK1.7使用的就是<code>PSYoungGen</code></p>
<p>使用Parallel old Generation收集器在老年代的名字是<code>&quot;[ParoldGen&quot;</code>·</p>
<p>使用G1收集器的话，会显示为<code>&quot;garbage-first heap&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allocation Failure</span><br></pre></td></tr></table></figure>



<p>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
<h4 id="②GC前后情况"><a href="#②GC前后情况" class="headerlink" title="②GC前后情况"></a>②GC前后情况</h4><p>通过图示，我们可以发现Gc日志格式的规律一般都是:GC前内存占用一&gt;GC后内存占用（该区域内存总大小)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K(8704K)]5986K-&gt;704K(9216K)</span><br></pre></td></tr></table></figure>



<p>中括号内:Gc回收前年轻代堆大小，回收后大小，（年轻代堆总大小)</p>
<p>括号外:GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小)</p>
<h4 id="③GC时间"><a href="#③GC时间" class="headerlink" title="③GC时间"></a>③GC时间</h4><p>Gc日志中有三个时间:user，sys和real</p>
<p>user - 进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</p>
<p>sys -进程在内核态消耗的 CPU时间，即在内核执行系统调用或等待系统事件所使用的CPU时间</p>
<p>real -程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待I/0 完成）。对于并行gc，这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</p>
<p>由于多核的原因，一般的Gc事件中，real time是小于sys + user time的，因为一般是多个线程并发的去做GCc，所以real time是要小于sys+user time的。如果real&gt;sys+user的话，则你的应用可能存在下列问题:IO负载非常重或者是CPU不够用。</p>
<h3 id="5-Minor-GC-日志解析"><a href="#5-Minor-GC-日志解析" class="headerlink" title="5)Minor GC 日志解析"></a>5)Minor GC 日志解析</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2020-11-20T17</span>:<span class="string">19:43.265-0800: 0.822:[GC(ALLOCATION FAILURE)[PSYOUNGGEN:76800K-&gt;8433K(89600K)] 76800K-&gt;8449K(294400K)，0.0088371 SECS][TIMES:</span></span><br><span class="line"><span class="attr">USER</span>=<span class="string">0.02svs=e.01,REAL=0.01 SECS]</span></span><br><span class="line"><span class="comment">##注释</span></span><br><span class="line"><span class="meta">2020-11-20T17</span>:<span class="string">19:43.265-0800   添加-XX:+PrintGCDateStamps参数	日志打印时间 日期格式 如2013-05-04T21:53:59.234+0800   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">0.822</span>:	<span class="string">添加-XX:+PrintGCTimeStamps该参数	gc发生时，Java虚拟机启动以来经过的秒数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[GC(Allocation</span> <span class="string">Failure)	发生了一次垃圾回收，这是一次Minior GC。它不区分新生代还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是新生代中没有足够区域能够存放需要分配的数据而失败。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[PSYoungGen</span>:<span class="string">76800K-&gt;8433K(89600K)	</span></span><br><span class="line">	<span class="attr">PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的</span></span><br><span class="line">		<span class="meta">Serial收集器：Default</span> <span class="string">New Generation 显示Defnew</span></span><br><span class="line">		<span class="attr">ParNew收集器：ParNew</span></span><br><span class="line">		<span class="attr">Parallel</span> <span class="string">Scanvenge收集器：PSYoung</span></span><br><span class="line">		<span class="attr">老年代和新生代同理，也是和收集器名称相关</span></span><br><span class="line">	<span class="attr">76800K-&gt;8433K(89600K)：GC前该内存区域已使用容量-&gt;GC后盖区域容量(该区域总容量)</span></span><br><span class="line">		<span class="attr">如果是新生代，总容量则会显示整个新生代内存的9/10，即eden+from/to区</span></span><br><span class="line">		<span class="attr">如果是老年代，总容量则是全身内存大小，无变化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">76800K-&gt;8449K(294400K)</span>	<span class="string">虽然本次是Minor GC，只会进行新生代的垃圾收集，但是也肯定会打印堆中总容量相关信息</span></span><br><span class="line"><span class="meta">在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量-&gt;GC后堆内存容量（堆内存总容量），并且堆内存总容量</span> = <span class="string">9/10 新生代 + 老年代，然后堆内存总容量肯定小于初始化的内存大小。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">,0.0088371</span>	<span class="string">整个GC所花费的时间，单位是秒</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[Times：user</span>=<span class="string">0.02 sys=0.01,real=0.01 secs]</span></span><br><span class="line">	<span class="attr">user：指CPU工作在用户态所花费的时间</span></span><br><span class="line">	<span class="attr">sys：指CPU工作在内核态所花费的时间</span></span><br><span class="line">	<span class="attr">real：指在此次事件中所花费的总时间</span></span><br></pre></td></tr></table></figure>



<h3 id="6-Full-GC-日志解析"><a href="#6-Full-GC-日志解析" class="headerlink" title="6)Full GC 日志解析"></a>6)Full GC 日志解析</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2020-11-20T17</span>:<span class="string">19:43.794-0800: 1.351:[FULL GC (METADATA GC THRESHOLD)[PsYOUNGGEN: 10082K-&gt;eK(89600K)][ PAROLDGEN: 32K-&gt;9638K(204800K)]</span></span><br><span class="line"><span class="meta">10114K-&gt;9638K</span> <span class="string">( 29440OK),</span></span><br><span class="line"><span class="meta">[METASPACE</span>: <span class="string">20158K-&gt;20156K(1067008K)]，0.0285388 SECS] [TIMES: USER=0.11sYS=0.00，REAL=6.03 SECS]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##注释</span></span><br><span class="line"><span class="meta">2020-11-20T17</span>:<span class="string">19:43.794-0800	日志打印时间 日期格式 如2013-05-04T21:53:59.234+0800	添加-XX:+PrintGCDateStamps参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">1.351</span>	<span class="string">gc发生时，Java虚拟机启动以来经过的秒数	添加-XX:+PrintGCTimeStamps该参数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Full</span> <span class="string">GC(Metadata GCThreshold)	括号中是gc发生的原因，原因：Metaspace区不够用了。</span></span><br><span class="line">    <span class="meta">除此之外，还有另外两种情况会引起Full</span> <span class="string">GC，如下：</span></span><br><span class="line">        <span class="meta">1、Full</span> <span class="string">GC(FErgonomics)</span></span><br><span class="line">        <span class="attr">原因：JVM自适应调整导致的GC</span></span><br><span class="line">        <span class="meta">2、Full</span> <span class="string">GC（System）</span></span><br><span class="line">        <span class="attr">原因：调用了System.gc()方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[PSYoungGen</span>: <span class="string">100082K-&gt;0K(89600K)]</span></span><br><span class="line">	<span class="attr">PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的</span></span><br><span class="line">		<span class="meta">Serial收集器：Default</span> <span class="string">New Generation 显示DefNew</span></span><br><span class="line">		<span class="attr">ParNew收集器：ParNew</span></span><br><span class="line">		<span class="attr">Parallel</span> <span class="string">Scanvenge收集器：PSYoungGen</span></span><br><span class="line">		<span class="attr">老年代和新生代同理，也是和收集器名称相关</span></span><br><span class="line">	<span class="attr">10082K-&gt;0K(89600K)：GC前该内存区域已使用容量-&gt;GC该区域容量(该区域总容量)</span></span><br><span class="line">		<span class="attr">如果是新生代，总容量会显示整个新生代内存的9/10，即eden+from/to区</span></span><br><span class="line">		<span class="attr">如果是老年代，总容量则是全部内存大小，无变化</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">ParOldGen：32K-&gt;9638K(204800K)</span>	<span class="string">老年代区域没有发生GC，因此本次GC是metaspace引起的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">10114K-&gt;9638K(294400K),在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量-&gt;GC后堆内存容量（堆内存总容量），并且堆内存总容量</span> = <span class="string">9/10 新生代 + 老年代，然后堆内存总容量肯定小于初始化的内存大小</span></span><br><span class="line"></span><br><span class="line"><span class="meta">[Meatspace</span>:<span class="string">20158K-&gt;20156K(1067008K)],	metaspace GC 回收2K空间</span></span><br></pre></td></tr></table></figure>



<h2 id="104-垃圾回收算法"><a href="#104-垃圾回收算法" class="headerlink" title="104.垃圾回收算法"></a>104.垃圾回收算法</h2><ol>
<li>引用计数法</li>
<li>可达性分析法</li>
</ol>
<p>对于可达性分析法，我们知道需要存在一个GC Root的对象作为起点，从这个节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到对象不可达）时，则证明此对象是不可用的。</p>
<h2 id="105-GC-Root有哪些？"><a href="#105-GC-Root有哪些？" class="headerlink" title="105.GC Root有哪些？"></a>105.GC Root有哪些？</h2><ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
<li>本地方法栈中JNI引用对象</li>
</ul>
<h2 id="106-垃圾回收器有哪些？"><a href="#106-垃圾回收器有哪些？" class="headerlink" title="106.垃圾回收器有哪些？"></a>106.垃圾回收器有哪些？</h2><ol>
<li><strong>Serial收集器</strong>(-XX:+UseSerialGC -XX:+UseSerialOldGC)：Serial（串行）收集器是一个单线程收集器，新生代采用复制算法，老年代采用标记-整理算法。</li>
<li><strong>Parallel Scavenge收集器</strong>(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)) ：Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同</li>
<li><strong>ParNew收集器</strong>(-XX:+UseParNewGC)：只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作</li>
<li><strong>CMS收集器</strong>(-XX:+UseConcMarkSweepGC(old))：收集器是一种以获取最短回收停顿时间为目标的收集器CMS收集器是一种 “标记-清除”算法实现的。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</li>
<li><strong>G1收集器</strong>(-XX:+UseG1GC)：G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M</li>
<li><strong>Shenandoah：</strong>可以看成是G1升级版</li>
<li><strong>ZGC收集器：</strong>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器。1、支持TB量级的堆；2、最大GC停顿时间不超10ms；3、奠定未来GC特性的基础；4、最糟糕的情况下吞吐量会降低15%</li>
</ol>
<h2 id="107-CMS运行过程，缺点？"><a href="#107-CMS运行过程，缺点？" class="headerlink" title="107.CMS运行过程，缺点？"></a>107.CMS运行过程，缺点？</h2><p>整个过程分为四个步骤</p>
<ol>
<li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>对CPU资源敏感（会和服务抢资源）</li>
<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li>
</ol>
<h2 id="108-G1运行过程"><a href="#108-G1运行过程" class="headerlink" title="108.G1运行过程"></a>108.G1运行过程</h2><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p>
<ol>
<li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li>
<li>并发标记（Concurrent Marking）：同CMS的并发标记</li>
<li>最终标记（Remark，STW）：同CMS的重新标记</li>
<li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li>
</ol>
<h2 id="109-G1适合什么场景"><a href="#109-G1适合什么场景" class="headerlink" title="109.G1适合什么场景"></a>109.G1适合什么场景</h2><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h2 id="110-判断元空间是无用的类"><a href="#110-判断元空间是无用的类" class="headerlink" title="110.判断元空间是无用的类"></a>110.判断元空间是无用的类</h2><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="111-安全点和安全区域"><a href="#111-安全点和安全区域" class="headerlink" title="111.安全点和安全区域"></a>111.安全点和安全区域</h2><p><strong>安全点：</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>安全区域：如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，引用关系不会发生变化。在这个区域内的任意地方开始 GC 都是安全的。</p>
<h2 id="112-YGC和FGC发生的场景"><a href="#112-YGC和FGC发生的场景" class="headerlink" title="112.YGC和FGC发生的场景"></a>112.YGC和FGC发生的场景</h2><p>YGC：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。edn空间不足,执行 </p>
<p>FGC：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。生产环境，一般比较少会触发fgc，有时10天或一周左右会有一次。</p>
<p>老年代空间不足，永久区空间不足，调用方法System.gc() ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</p>
<h2 id="113-jstack，jmap，Jstat作用"><a href="#113-jstack，jmap，Jstat作用" class="headerlink" title="113.jstack，jmap，Jstat作用"></a>113.jstack，jmap，Jstat作用</h2><p><strong>jmap：</strong>可以用来查看内存信息，实例个数以及占用内存大小</p>
<ul>
<li>jmap -heap 进程号：查看堆内存信息</li>
<li>jmap ‐dump:format=b,file=eureka.hprof 进程号： 堆内存的快照信息，添加jvm参数也可以设置内存溢出自动导出dump文件</li>
</ul>
<p><strong>jstack:</strong> 可以获得java线程的运行情况，可以查看死锁，阻塞，等待</p>
<ul>
<li>Jstack -l PID &gt;&gt; 123.txt 打印某个java进程的堆栈信息</li>
</ul>
<p><strong>Jstat：</strong>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量</p>
<ul>
<li>jstat -gc pid 最常用，可以评估程序内存使用及GC压力整体情况</li>
</ul>
<h1 id="四、缓存-Redis"><a href="#四、缓存-Redis" class="headerlink" title="四、缓存:Redis"></a>四、缓存:Redis</h1><p>1.redis基本数据类型及常用场景</p>
<p>2.redis数据类型底层数据结构</p>
<p>3.redis单线程为什么快</p>
<p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p>
<ol>
<li>完全基于内存操作</li>
<li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li>
<li>使用单线程，无上下文的切换成本</li>
<li>基于非阻塞的IO多路复用机制</li>
</ol>
<p>4.redis单线程模型</p>
<p>5.那为什么Redis6.0之后又改用多线程呢?</p>
<p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p>
<p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p>
<p>6.缓存雪崩、缓存击穿、缓存穿透及解决方案</p>
<ul>
<li><font color='red'>缓存雪崩</font>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol>
<li>过期时间随机，防止同一时间大量数据过期</li>
<li>缓存预热：项目启动加载缓存到redis</li>
<li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li>
<li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li>
</ol>
</li>
<li><font color='red'>缓存穿透</font>：指数据库没有数据，导致请求落到数据库上<ol>
<li>接口层增加校验，对id进行规则拦截</li>
<li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li>
<li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li>
</ol>
</li>
<li><font color='red'>缓存击穿</font>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol>
<li>key不过期</li>
<li>加互斥锁</li>
</ol>
</li>
</ul>
<p>7.大key</p>
<p>8.热key</p>
<p>9.Redis的过期策略有哪些</p>
<p>10.redis淘汰策略？（同问题定期+惰性都没有删除过期的key怎么办？）</p>
<p>11.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁</p>
<p>12.redis持久化两种方式（AOF&amp;RDB）</p>
<p>RDB的原理是什么</p>
<p>给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是<strong>copy on write</strong>，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<p>注：回答这个问题的时候，如果你还能说出AOF和RDB的优缺点，我觉得我是面试官在这个问题上我会给你点赞，两者其实区别还是很大的</p>
<p>13.redis主从复制原理（全量同步&amp;增量同步）</p>
<p>14.redis哨兵模式</p>
<p>15.redis集群模式</p>
<p>16.一致性hash</p>
<p>17.redis和数据库数据一致性问题</p>
<p>18.BloomFilter过滤器原理</p>
<p>19.场景题</p>
<p>排行榜（多维度）</p>
<p>签到</p>
<p>redis实现消息队列</p>
<p>一般使用list结构作为队列，<strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>如果对方追问可不可以不用sleep呢？ </p>
<p>list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>如果对方接着追问能不能生产一次消费多次呢？ </p>
<p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p>
<p>如果对方继续追问 pub/su b有什么缺点？ </p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<strong>RocketMQ</strong>等。</p>
<p>如果对方究极TM追问Redis如何实现延时队列？</p>
<p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用<strong>zrangebyscore</strong>指令获取N秒之前的数据轮询进行处理。</p>
<ol>
<li><h3 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h3></li>
</ol>
<p>Redis基于Reactor模式开发的网络事件处理器，这个文件事件处理器是单线程的，采用IO多路复用机制监听多个Socker，根据Socker上的事件类型选择对应的事件处理器处理这个事件，可以实现高性能的网络通信。文件事件处理器包含4个部分，多个Socker，IO多路复用程序，文件事件分派器和事件处理器(命令请求处理器，命令回复处理器，链接应答处理器)，多个Socket可能并发产生不同操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Socket，会将Socket放入一个队列，每次从队列中取出一个Socket给时间分派器，时间分派器把Socket给对应的事件处理器。</p>
<p>单线程快的原因：1.纯内存操作；2.核心是基于非阻塞的IO多路复用机制；3.单线程反而避免多线程的频繁上下文切换</p>
<h3 id="分布式锁怎么实现的？"><a href="#分布式锁怎么实现的？" class="headerlink" title="分布式锁怎么实现的？"></a>分布式锁怎么实现的？</h3><ol>
<li>基于数据库实现分布式锁：唯一索引，状态机唯一联合索引</li>
<li>基于缓存（Redis等）实现分布式锁：SET key value NX PX 30000</li>
<li>基于Zookeeper实现分布式锁；</li>
</ol>
<h3 id="setnx用到的参数"><a href="#setnx用到的参数" class="headerlink" title="setnx用到的参数"></a>setnx用到的参数</h3><p><code>SET key value NX PX 30000</code></p>
<p>第三个参数：把key、value set到redis中的策略</p>
<ul>
<li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li>
<li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li>
</ul>
<p>第四个参数：过期时间单位</p>
<ul>
<li>  ex ：seconds 秒</li>
<li>  px : milliseconds 毫秒</li>
</ul>
<p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error </p>
<p>第五个参数：有两种可选的值，</p>
<p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p>
<h3 id="缓存穿透，击穿，雪崩"><a href="#缓存穿透，击穿，雪崩" class="headerlink" title="缓存穿透，击穿，雪崩"></a>缓存穿透，击穿，雪崩</h3><ul>
<li></li>
</ul>
<h3 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h3><p>Redis对于过期键有三种清除策略：</p>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批<strong>已过期</strong>的key</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清理策略</strong></li>
</ol>
<p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）</p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p>
<ol>
<li>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</li>
<li>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</li>
</ol>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ol>
<li>RDB快照(snapshot)<ol>
<li>Redis 将内存数据快照保存在名字为 dump.rdb 的二进制文件中。可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据；**# save 60 1000    //** (60秒改1000次进行一次RDB持久化)关闭RDB只需要将所有的save保存策略注释掉即可。</li>
<li>问题：会阻塞客户端命令。</li>
<li>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</li>
<li><strong>bgsave的写时复制(COW)机制</strong>：Redis 借助操作系统提供的写时复制技术（Copy-On-Write, COW），在生成快照的同时，依然可以正常处理写命令。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，在这个过程中，主线程仍然可以修改原来的数据。</li>
</ol>
</li>
<li>AOF(append-only file)<ol>
<li>如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将<strong>修改的</strong>每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</li>
</ol>
</li>
</ol>
<h3 id="缓存与数据库数据一致性"><a href="#缓存与数据库数据一致性" class="headerlink" title="缓存与数据库数据一致性"></a>缓存与数据库数据一致性</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/HwOLrx.png" />

<p>解决方案：</p>
<ol>
<li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li>
<li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ol>
<h1 id="五、MQ"><a href="#五、MQ" class="headerlink" title="五、MQ"></a>五、MQ</h1><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/dvvBBU.png" />

<h3 id="Rabbitmq生产高可用怎么实现的"><a href="#Rabbitmq生产高可用怎么实现的" class="headerlink" title="Rabbitmq生产高可用怎么实现的"></a>Rabbitmq生产高可用怎么实现的</h3><ol>
<li>生产部署为集群模式：避免单机模式下MQ服务器挂了导致服务不可用，还可以承载更高的并发量，但是集群模式有个问题，就是在哪个节点上创建队列，该队列只会存在该节点上，其他集群节点不会备份该队列，一旦该节点宕机，该队列中的消息就会丢失(亲测设置持久化也丢失)</li>
<li>使用镜像队列：可以解决集群模式下，每个机器上只有一个队列的问题，让消息在其他节点再备份一份。开启方式：任何节点添加policy策略即可，该集群就具有镜像队列能力，可设置备份的份数和备份队列规则，即使其中一个节点宕机，也会保证整个集群中保存2份</li>
<li>高可用负载均衡：haproxy+keepalive，nginx，lvs等实现高可用负载均衡</li>
<li>其他：Federation Exchange联邦交换机插件解决两地接受消息确认消息延迟问题，也可以用Shovel来做数据同步，需要安装插件</li>
</ol>
<h1 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h1><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>死锁：是指一组互相竞争资源的线程，因为互相等待，导致永久阻塞的现象。</p>
</li>
<li><p>原因：必须同时满足以下四个条件</p>
<ol>
<li>共享互斥条件：共享资源x和y只能被一个线程占用</li>
<li>占有且等待：线程t1已经占有共享资源x，在等待共享资源y的时候不释放共享资源x</li>
<li>不可抢占：其他线程不能强行抢占线程t1占有的资源</li>
<li>循环等待：线程t1等待线程t2占有的资源，线程t2等待线程t1占有的资源</li>
</ol>
</li>
<li><p>如何避免死锁：</p>
<ol>
<li>既然产生死锁必然满足四个条件，那我们只要打破四个条件中的一个就可以避免，第一个互斥条件是无法被破坏的，因为锁本身就是通过互斥来解决线程安全的</li>
<li>针对后三个条件，我们逐一分析，占有且等待这个条件我们可以一次性申请所有资源，不存在等待；</li>
<li>不可抢占这个条件：占有部分资源的线程进一步申请其他资源的时候如果申请不到，可以主动释放已占有的资源，这样不可抢占这条件就破坏了；</li>
<li>循环等待这个条件：可以按照顺序去申请资源进行预防，就是说资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，线性化之后，就不存在循环等待了</li>
</ol>
</li>
</ul>
<h3 id="sleep和wait区别"><a href="#sleep和wait区别" class="headerlink" title="sleep和wait区别"></a>sleep和wait区别</h3><ol>
<li>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法</li>
<li>sleep方法不会释放锁，但是wait会释放，而且会加入到等待队列中</li>
<li>sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字</li>
<li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li>
<li>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信</li>
<li>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</li>
</ol>
<p>sleep就是把cpu的执行资格和执行权释放出去，不再运行此线程，当定时时间结束再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时该线程有锁，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也就是说无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这点和wait是一样的。</p>
<p>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中</p>
<h3 id="Volitile作用"><a href="#Volitile作用" class="headerlink" title="Volitile作用"></a>Volitile作用</h3><ol>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。内存屏障-&gt;汇编Lock关键字-&gt;缓存一致性协议</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的内存屏障来禁止指令重排序来保障有序性</li>
</ol>
<h3 id="Volitile如何保证可见性"><a href="#Volitile如何保证可见性" class="headerlink" title="Volitile如何保证可见性"></a>Volitile如何保证可见性</h3><ol>
<li><strong>缓存一致性：</strong>在共享内存多处理器系统中，每个处理器都有一个单独的缓存内存，共享数据在主内存和各处理器私有缓存同时存在。当数据的一个副本发生更改，其他副本需要感知到最新修改数据。缓存一致性的手段主要有：</li>
<li>总线锁定：总线锁定就是使用处理器提供的一个 LOCK＃信号，当其中一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器可以独占共享内存。</li>
<li>总线窥探(Bus snooping)：是缓存中的一致性控制器窥探总线事务的一种方案（该方案由Ravishankar和Goodman于1983年提出）当数据被多个缓存共享时，一个处理器修改了共享数据的值，可以是刷新缓存块或使缓存块失效还可以通过缓存块状态的改变，来达到缓存一致性的目的，主要取决于窥探协议类型：<ol>
<li>写失效（Write-invalidate） ：当一个处理器写入共享缓存时，其他缓存中的所有共享副本都会通过总线窥探失效。确保处理器只能读写一个数据副本，其他缓存中的所有其他副本都无效。这是最常用的窥探协议。MSI、MESI、MOSI、MOESI和MESIF协议属于该类型。</li>
<li>写更新（Write-update）：当处理器写入一个共享缓存块时，其他缓存的所有共享副本都会通过总线窥探更新。这个方法将写数据广播到总线上的所有缓存中。它比写失效协议引起更大的总线流量，因此这种方法不常见。Dragon和firefly协议属于此类别。</li>
</ol>
</li>
</ol>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>Java语言规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义：：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行状态+运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol>
<p>在操作系统层面，有五种状态，Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 是一种状态，即前面我们提到的休眠状态。也就是说只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。</p>
<h3 id="linux查看线程命令"><a href="#linux查看线程命令" class="headerlink" title="linux查看线程命令"></a>linux查看线程命令</h3><ul>
<li><p>ps  - fe 查看所有进程</p>
</li>
<li><p>ps  - fT  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>kill 杀死进程</p>
</li>
<li><p>top 按大写  H  切换是否显示线程</p>
</li>
<li><p>top  - H  - p <PID> 查看某个进程（ PID ）的所有线程</p>
</li>
<li><p>jps 命令查看所有  Java  进程</p>
</li>
<li><p>jstack <PID> 查看某个  Java  进程（ PID ）的所有线程状态</p>
</li>
<li><p>jconsole 来查看某个  Java  进程中线程的运行情况（图形界面）</p>
</li>
</ul>
<h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><ol>
<li>方式1：使用 Thread类或继承Thread类</li>
<li>实现 Runnable 接口配合Thread</li>
<li>使用有返回值的 Callable，借助线程池使用</li>
<li>使用 lambda</li>
</ol>
<p>本质上Java中实现线程只有一种方式，都是通过new Thread()创建线程，调用Thread#start启动线程最终都会调用Thread#run方法</p>
<h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><p><strong>sleep方法</strong></p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态，不会释放对象锁</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出InterruptedException，并且会清除中断标志</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>sleep当传入参数为0时，和yield相同</li>
</ul>
<p><strong>yield方法</strong></p>
<ul>
<li>yield会释放CPU资源，让当前线程从 Running 进入 Runnable状态，让优先级更高（至少是相同）的线程获得执行机会，不会释放对象锁；</li>
<li>假设当前进程只有main线程，当调用yield之后，main线程会继续运行，因为没有比它优先级更高的线程；</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
<h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal<br>实例，value为线程变量的副本</p>
<h3 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h3><ol>
<li>在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li>
<li>线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息。</li>
<li>数据库连接，Session会话管理。<ul>
<li>Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</li>
</ul>
</li>
</ol>
<h3 id="ThreadLocal内存泄露原因，如何避免"><a href="#ThreadLocal内存泄露原因，如何避免" class="headerlink" title="ThreadLocal内存泄露原因，如何避免"></a>ThreadLocal内存泄露原因，如何避免</h3><ol>
<li>强引用：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，<br>Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</li>
<li>弱引用：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用<br>java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</li>
<li>ThreadLocal正确的使用方法<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任<br>何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</li>
</ol>
<h3 id="synchronized和ReentranLock区别？"><a href="#synchronized和ReentranLock区别？" class="headerlink" title="synchronized和ReentranLock区别？"></a>synchronized和ReentranLock区别？</h3><p>synchronized是jvm层面的关键字，底层是通过monitor对象来完成，monitor对象底层依赖于操作系统的Mutex互斥量，底层调用的是操作系统的Pthread库，是由操作系统来维护的，而操作系统分为用户空间和内核空间的，JVM运行在用户空间，调用底层操作系统cpu会进行一轮状态切换，这个状态切换是比较重型操作，wait/notify等方法也依赖monitor对象只有在同步块或方法中才能调wait/notify等方法。</p>
<p>Lock是具体类（java.util.concurrent.Locks.Lock)是api层面的锁，是从jdk1.5开始引入的，那个时候synchronized性能还比较差，ReentranLock的出现是为了解决当时性能差的问题</p>
<ul>
<li><p>使用方法：synchronized不需要手动释放锁，ReentranLock则需要用户手动释放锁(需要lock()和unlock()配合try/finally使用)</p>
</li>
<li><p>等待是否可中断：synchronized不可中断，除非抛出异常或者执行完成，ReentranLock可中断</p>
</li>
</ul>
<ol>
<li>设置超时方法tryLock(long timeout, timeUnit unit)</li>
<li>lockInterruptibly()放代码块忠，调用interrupt()方法可中断</li>
</ol>
<ul>
<li><p>加锁是否公平：synchronized非公平锁；ReentranLock 两者都可以，默认非公平锁，构造方法传入true为公平锁，false为非公平锁</p>
</li>
<li><p>锁绑定多个条件Condition：synchronized 没有；ReentranLock  用来实现分组唤醒需要唤醒的线程，可以精确唤醒，不像synchronized要么随机唤醒一个线程，要么全部唤醒</p>
</li>
</ul>
<h3 id="线程池参数有，核心线程配置，原因？"><a href="#线程池参数有，核心线程配置，原因？" class="headerlink" title="线程池参数有，核心线程配置，原因？"></a>线程池参数有，核心线程配置，原因？</h3><ol>
<li>corePoolSize：线程池中的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务</li>
<li>keepAliveTime：核心线程外的线程存活超时时间</li>
<li>unit：时间单位</li>
<li>workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口</li>
<li>threadFactory：用来创建新线程</li>
<li>线程池的饱和策略：( AbortPolicy：直接抛出异常，默认策略；CallerRunsPolicy：用调用者所在的线程来执行任务；DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy：直接丢弃任务)</li>
</ol>
<p><strong>CPU密集型（CPU-bound）</strong></p>
<p>CPU密集型也叫计算密集型，在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p><font color=red face="黑体">线程数 = CPU核数+1 (现代CPU支持超线程)</font> </p>
<p><strong>IO密集型（I/O bound）</strong></p>
<p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作</p>
<p> <font color=red face="黑体">线程数 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</font> </p>
<h1 id="七、spring"><a href="#七、spring" class="headerlink" title="七、spring"></a>七、spring</h1><p>spring是一个框架，更像是一个生态环境，在我们的开发流程中，所有的框架基本上都依赖于spring，spring起到了一个IOC容器的作用，用来承载我们整体的bean对象，它帮我们处理了bean对象从创建到销毁的整个生命周期的管理，我们在使用spring的时候，可以使用配置文件，也可以使用注解的方式进行相关开发。spring框架的工作主要流程是，当我们程序开始启动之后，spring把注解或者配置文件定义好的bean对象转化成为BeanDefinitionran，然后通BeanFactoryPostProcessor完成整个的BeanDefinitionran的解析和加载过程，然后根据BeanDefinitionran通过反射的方式创建bean对象，然后进行对象初始化，包括：aware接口相关操作，BeanPostProcessor操作，Init-methord操作完成整个bean的创建过程，之后我们就可以使用了。</p>
<h3 id="Bean的初始化过程"><a href="#Bean的初始化过程" class="headerlink" title="Bean的初始化过程"></a>Bean的初始化过程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uEApmP.png"  />



<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/uyP4Yq.png"/>



<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="AOP的顺序"><a href="#AOP的顺序" class="headerlink" title="AOP的顺序"></a>AOP的顺序</h3><p>  spring4和spring5是不一样的</p>
<h3 id="springMVC处理请求流程"><a href="#springMVC处理请求流程" class="headerlink" title="springMVC处理请求流程"></a>springMVC处理请求流程</h3><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/ig6fc0.png" />

<h3 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h3><ol>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：支持当前事务，如果没有事务会创建一个新的事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>SUPPORTS</strong>：支持当前事务，如果没有事务的话以非事务方式执行</li>
<li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：支持当前事务，如果没有事务抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：创建一个新的事务并挂起当前事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前存在事务则将当前事务挂起</li>
<li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：以非事务方式进行，如果存在事务则抛出异常</li>
<li>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li>
</ol>
<h1 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h1><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul>
<li>第一层：物理层</li>
<li>第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY </li>
<li>第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP </li>
<li>第四层：传输层 TCP、UDP、SPX </li>
<li>第五层：会话层 <strong>RPC</strong>、SQL、NFS 、X WINDOWS、ASP</li>
<li>第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG </li>
<li>第七层：应用层 HTTP,FTP,SNMP等</li>
</ul>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/jafyuK.png"/>

<ol>
<li>物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输；</li>
<li>数据链路层：数据链路层通过物理网络链路􏰁供数据传输。不同的数据链路层定义了不同的网络和协 议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控。可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；</li>
<li>网络层：网络层负责在源和终点之间建立连接。可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！</li>
<li>传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；</li>
<li>会话层：会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址）;</li>
<li>表示层：表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信；</li>
<li>应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;</li>
</ol>
<h3 id="http1-0和http1-1区别"><a href="#http1-0和http1-1区别" class="headerlink" title="http1.0和http1.1区别"></a>http1.0和http1.1区别</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ol>
<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
<li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ol>
<h3 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>
</ul>
<h3 id="http三次握手四次挥手"><a href="#http三次握手四次挥手" class="headerlink" title="http三次握手四次挥手"></a>http三次握手四次挥手</h3><p>其实这么说是不太准确的，应该说是tcp协议建立连接要3次握手，断开连接要4次挥手，而http是基于tcp协议的，所以通常我们也这么说，tcp可以提供全双工的数据流传输服务</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h1 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h1><h1 id="十、Dubbo"><a href="#十、Dubbo" class="headerlink" title="十、Dubbo"></a>十、Dubbo</h1><h3 id="你知道的json序列化方式？"><a href="#你知道的json序列化方式？" class="headerlink" title="你知道的json序列化方式？"></a>你知道的json序列化方式？</h3><ol>
<li>谷歌的Gson</li>
<li>json-smart：号称是速度最快的JSON解析器</li>
<li>Common Lang3(3.1)的SerializationUtils</li>
<li>阿里巴巴的 FastJson、以及 Jackson</li>
</ol>
<h3 id="两个系统之间怎么交互的？"><a href="#两个系统之间怎么交互的？" class="headerlink" title="两个系统之间怎么交互的？"></a>两个系统之间怎么交互的？</h3><ol>
<li> 套接字（socket）：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</li>
<li> 可以通过RPC框架（dubbo、feign等）进行远程调用</li>
<li> 也可以引入消息队列等消息中间件作为系统之间信息交互的桥梁</li>
<li> 共享内存（shared memory）：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更</li>
</ol>
<h3 id="dubbo的序列化？"><a href="#dubbo的序列化？" class="headerlink" title="dubbo的序列化？"></a>dubbo的序列化？</h3><p>dubbo 支持 hession、Java 二进制序列化、json、SOAP 文本序列化多种序列化协议。 hessian 是其默认的序列化协议</p>
<p>dubbo</p>
<ul>
<li>提供者(Provider)启动时，会向注册中心写入自己的元数据信息(调用方式)。</li>
<li>消费者(Consumer)启动时，也会在注册中心写入自己的元数据信息，并且订阅服务提供者，路由和配置元数据的信息。</li>
<li>服务治理中心(duubo-admin)启动时，会同时订阅所有消费者，提供者，路由和配置元数据的信息。</li>
<li>当提供者离开或者新提供者加入时，注册中心发现变化会通知消费者和服务治理中心。</li>
</ul>
<h1 id="十一、Netty"><a href="#十一、Netty" class="headerlink" title="十一、Netty"></a>十一、Netty</h1><h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a>NIO三大核心组件</h3><p> <strong>Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)</strong></p>
<ol>
<li>channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组</li>
<li>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理</li>
<li>NIO 的 Buffer 和 channel 都是既可以读也可以写</li>
</ol>
<h3 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h3><p>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现boss和work两个线程池，其中boss的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，交由对应的Handler处理。</p>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5cJC8M.png" />

<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/5N67yC.png"/> 

<ol>
<li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</li>
<li>BossGroup和WorkerGroup类型都是NioEventLoopGroup</li>
<li>NioEventLoopGroup 相当于一个事件循环<strong>线程组</strong>, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</li>
<li>每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</li>
<li> 每个BossNioEventLoop线程内部循环执行的步骤有 3 步</li>
<li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li>
<li>将NioSocketChannel注册到某个worker  NIOEventLoop上的selector</li>
<li>处理任务队列的任务 ， 即runAllTasks</li>
<li>每个workerNIOEventLoop线程循环执行的步骤<ol>
<li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件</li>
<li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务</li>
<li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入TaskQueue中慢慢处理，这样不影响数据在 pipeline 中的流动处理</li>
</ol>
</li>
</ol>
<h3 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h3><ul>
<li><p><strong>Bootstrap、ServerBootstrap</strong>：Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
</li>
<li><p><strong>Future、ChannelFuture</strong>：正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
</li>
<li><p><strong>Channel</strong>：Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ol>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
</li>
<li><p>网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</p>
</li>
<li><p>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</p>
</li>
<li><p>支持关联 I/O 操作与对应的处理程序。</p>
</li>
<li><p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p>
</li>
<li><pre><code>NioSocketChannel，异步的客户端 TCP Socket 连接。
NioServerSocketChannel，异步的服务器端 TCP Socket 连接。
NioDatagramChannel，异步的 UDP 连接。
NioSctpChannel，异步的客户端 Sctp 连接。
NioSctpServerChannel，异步的 Sctp 服务器端连接。
这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。
</code></pre>
</li>
</ol>
</li>
<li><p><strong>Selector</strong>：Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
</li>
<li><p><strong>NioEventLoop</strong>：NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务：I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p>
</li>
<li><p><strong>NioEventLoopGroup</strong>：NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p>
</li>
<li><p><strong>ChannelHandler</strong>：ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</p>
</li>
<li><p><strong>ChannelHandlerContext</strong>：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。</p>
</li>
<li><p><strong>ChannelPipline</strong>：保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互。在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</p>
</li>
</ul>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/OnweVR.png"/> 

<p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰。</p>
<h3 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h3><p>TCP是一个流协议，就是没有界限的一长串二进制数据。TCP作为传输层协议并不不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行数据包的划分，所以在业务上认为是一个完整的包，可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。面向流的通信是无消息保护边界的。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>消息定长度，传输的数据大小固定长度，例如每段的长度固定为100字节，如果不够空位补空格</p>
</li>
<li><p>在数据包尾部添加特殊分隔符，比如下划线，中划线等，这种方法简单易行，但选择分隔符的时候一定要注意每条数据的内部一定不能出现分隔符。</p>
</li>
<li><p>发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p>
<p>Netty提供了多个解码器，可以进行分包的操作，如下：</p>
<ol>
<li>LineBasedFrameDecoder （回车换行分包）</li>
<li>DelimiterBasedFrameDecoder（特殊分隔符分包）</li>
<li>FixedLengthFrameDecoder（固定长度报文来分包）</li>
</ol>
</li>
</ol>
<h1 id="十二、zookeeper"><a href="#十二、zookeeper" class="headerlink" title="十二、zookeeper"></a>十二、zookeeper</h1><h4 id="zookeeper的理解"><a href="#zookeeper的理解" class="headerlink" title="zookeeper的理解"></a>zookeeper的理解</h4><ol>
<li>集群管理：提供了CP模型来保证集群中每个节点的数据一致性</li>
<li>分布式锁</li>
<li>集群选举</li>
</ol>
<h4 id="zookeeper选举机制"><a href="#zookeeper选举机制" class="headerlink" title="zookeeper选举机制"></a>zookeeper选举机制</h4><ul>
<li>LeaderElection  </li>
<li>AuthFastLeaderElection</li>
<li>FastLeaderElection （最新默认）</li>
</ul>
<p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p>
<ul>
<li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。</li>
<li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li>
<li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li>
<li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li>
<li>服务器5启动，后面的逻辑同服务器4成为小弟。</li>
</ul>
<h1 id="十三、理论"><a href="#十三、理论" class="headerlink" title="十三、理论"></a>十三、理论</h1><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>​        CAP 理论又叫 Brewer 理论，这是加州大学伯克利分校的埃里克 · 布鲁尔（Eric Brewer）教授，在 2000 年 7 月“ACM 分布式计算原理研讨会（PODC）”上提出的一个猜想。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~brewer%2Fcs262b-2004%2FPODC-keynote.pdf">CAP理论原稿</a>（那时候还只是猜想）然后到了 2002 年，麻省理工学院的赛斯 · 吉尔伯特（Seth Gilbert）和南希 · 林奇（Nancy Lynch）就以严谨的数学推理证明了这个 CAP 猜想。在这之后，CAP 理论就正式成为了分布式计算领域公认的著名定理。这个定理里，描述了一个分布式的系统中，当涉及到共享数据问题时，以下三个特性最多只能满足其中两个：</p>
<ol>
<li>一致性（Consistency）：代表在任何时刻、任何分布式节点中，我们所看到的数据都是没有矛盾的。这与 ACID 中的 C 是相同的单词，但它们又有不同的定义（分别指 Replication 的一致性和数据库状态的一致性）。在分布式事务中，ACID 的 C 要以满足 CAP 中的 C 为前提。</li>
<li>可用性（Availability）：代表系统不间断地提供服务的能力。</li>
<li>分区容忍性（Partition Tolerance）：代表分布式环境中，当部分节点因网络原因而彼此失联（即与其他节点形成“网络分区”）时，系统仍能正确地提供服务的能力。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU3MTQwNDEyMg==&amp;mid=2247483680&amp;idx=1&amp;sn=a844dc83df3316ac0102ea11511b8b46&amp;chksm=fce1fb15cb9672032e98857a74f4e971a1ff833a6e353cafee655587c70a93e730a652daf5a2&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU3MTQwNDEyMg==&amp;mid=2247483680&amp;idx=1&amp;sn=a844dc83df3316ac0102ea11511b8b46&amp;chksm=fce1fb15cb9672032e98857a74f4e971a1ff833a6e353cafee655587c70a93e730a652daf5a2&amp;scene=21#wechat_redirect</a></p>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><p>ddd不是一种架构风格，而是一种方法论，什么是方法论，每个人按照自己的想法来设计就是一套方法论；ddd是一种业务比较认可，对于微服务拆分的一种方法论。</p>
<h1 id="十四、项目"><a href="#十四、项目" class="headerlink" title="十四、项目"></a>十四、项目</h1><ol>
<li>最近做的比较熟悉的项目是哪个？画一下项目技术架构图</li>
<li>写两个类，能够实现堆内存溢出和栈内存溢出</li>
<li>写一个线程安全的单例。</li>
<li>两个可变有序链表放到新数组中，有序</li>
</ol>
<h3 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h3><p>ES他是建立在全文搜索引擎库ApacheLucene基础上的一个开源搜索和分析引擎，ES本身具有一个分布式存储，检索速度快的特性，所以我们经常用它去实现全文检索这一类的场景，比如像网站搜索，公司内部用ELK做日志聚集和检索，来去快速查找服务器的日志记录，去定位问题，基本上涉及到TB级别的数据场景，用ES是一个比较好的选择</p>
<h4 id="ES查询快的原因"><a href="#ES查询快的原因" class="headerlink" title="ES查询快的原因"></a>ES查询快的原因</h4><ol>
<li>第一、Lucene是擅长管理大量的索引数据的，另一方面他会对数据进行分词以后在保存索引，这样能搞提升数据的检索效率</li>
<li>第二、ES采用倒排索引，所谓倒排索引，就是通过属性值来确定数据记录的位置的索引，来避免全表扫描这样一个问题，</li>
<li>第三、ES采用分片存储机制</li>
<li>第四、ES扩展性好，我们可以水平扩展增加服务器，提升ES处理性能，可以达到百台服务器节点扩展</li>
<li>第五、ES内部提供了数据汇总和索引生命周期管理的一些功能，可以方便我们更加高效的存储和搜索数据</li>
</ol>
<h4 id="使用ES注意事项"><a href="#使用ES注意事项" class="headerlink" title="使用ES注意事项"></a>使用ES注意事项</h4><ol>
<li>ES里面不建议使用复杂的关联查询，会对性能影响很大</li>
<li>避免深度分页查询，因为ES分页是支持front和size参数，在查询的时候，每个分片必须构造一个长度为front加size的优先队列，然后回传到网关节点，网关节点再对这些队列进行排序再找到正确的size文档。而当front足够大的时候容易造成OOM以及网络传输性能差的一些问题</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">https://zhangxin66666.github.io/2022/03/31/12.面试/常见面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/%E9%9D%A2%E8%AF%95.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构和算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/"><img class="next-cover" src="/images/cover/%E6%96%B9%E6%B3%95%E8%AE%BA.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">业务架构-稳定性建设方法论</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ConcurrentHashMap"><span class="toc-text">1.ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Set-List-Map%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2.Set,List,Map有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HashMap%E5%92%8CHashTable%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.HashMap和HashTable有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.HashMap底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-HashMap-put%E6%B5%81%E7%A8%8B"><span class="toc-text">5.HashMap put流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-HashMap%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-text">6.HashMap扩容流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">7.为什么选择用红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">8.面向对象的特征?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%B8%B8%E8%A7%81%E7%9A%84RuntimeException"><span class="toc-text">9.常见的RuntimeException</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">10.常见的引用类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM"><span class="toc-text">二、JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.jvm内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.对象创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">3.类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">4.类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">5.双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">6.沙箱安全机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-PC"><span class="toc-text">7.程序计数器-PC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">8.虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">9.本地方法接口和本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A0%86"><span class="toc-text">10.堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">11.堆的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="toc-text">12.堆的内存细分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">1）堆空间的大小设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89OutOfMemoryError"><span class="toc-text">2）OutOfMemoryError</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">13.年轻代和老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">14.对象分配过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="toc-text">15.常用调优工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Minor-GC-Major-GC-fULL-GC"><span class="toc-text">16.Minor GC,Major GC,fULL GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%AD%96%E7%95%A5%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">17.分代式GC策略触发条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%B9%B4%E8%BD%BB%E4%BB%A3%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">1）年轻代触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%80%81%E5%B9%B4%E4%BB%A3GC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-text">2）老年代GC触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89FullGC%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">3）FullGC触发条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="toc-text">18.堆空间分代思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">19.对象分配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-TLAB"><span class="toc-text">20.TLAB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">21.堆空间的参数设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%BB%8E%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">22.从逃逸分析角度分析对象内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%98%9B%EF%BC%9F"><span class="toc-text">1）堆是分配对象存储的唯一选择嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">2）逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%A1%A5%E5%85%85"><span class="toc-text">3）补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E4%BD%BF%E7%94%A8%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%A0%86%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">23.使用逃逸分析堆代码进行优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-text">1）栈上分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5"><span class="toc-text">2）同步省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%88%86%E7%A6%BB%E5%AF%B9%E8%B1%A1%E6%88%96%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-text">3）分离对象或标量替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%A0%88%EF%BC%8C%E5%A0%86%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">24.栈，堆，方法区的交互关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">25.方法区的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">26.设置方法区大小的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3OOM"><span class="toc-text">27.如何解决OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">28.方法区的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">1）类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%9F%E4%BF%A1%E6%81%AF"><span class="toc-text">2）域信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="toc-text">3）方法信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89class%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4）class文件中常量池的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">5）运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E5%9B%BE%E8%A7%A3%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">29.图解常量池操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">1）运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-text">30.方法区的演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-StringTable%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E6%95%B4%E4%BD%8D%E7%BD%AE"><span class="toc-text">31.StringTable为什么调整位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-text">32.静态变量放在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">33.方法区的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">34.创建对象的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89new"><span class="toc-text">1）new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Class-forName-newInstance"><span class="toc-text">2）Class.forName().newInstance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89Constructor-newInstance-xxx"><span class="toc-text">3）Constructor.newInstance(xxx)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E4%BD%BF%E7%94%A8clone%EF%BC%88%EF%BC%89"><span class="toc-text">4）使用clone（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">5）使用反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93Objenesis"><span class="toc-text">6）第三方库Objenesis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">35.创建对象的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%A6%96%E5%85%88%E5%88%A4%E6%96%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E5%8A%A0%E8%BD%BD%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1）首先判断对应的类是否已经加载，链接，初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">2）为对象分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">3）处理并发安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E9%85%8D%E5%88%B0%E7%A9%BA%E9%97%B4"><span class="toc-text">4）初始化分配到空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text">5）设置对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">6）执行init方法初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">36.对象访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="toc-text">1）句柄访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88-HotSpot%E9%87%87%E7%94%A8"><span class="toc-text">2）直接指针(HotSpot采用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">37.直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">38.执行引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-java%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">39.java代码的编译和执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E6%9C%BA%E5%99%A8%E7%A0%81%EF%BC%8C%E6%8C%87%E4%BB%A4%EF%BC%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-text">40.机器码，指令，汇编语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-text">41.解释器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">42.JIT即时编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="toc-text">1）热点代码以及探测方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89OSR%E7%BC%96%E8%AF%91"><span class="toc-text">2）OSR编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89JDK9%E5%BC%95%E5%85%A5%E4%BA%86AOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">3）JDK9引入了AOT编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89JDK10%E7%9A%84Graal%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">4）JDK10的Graal编译器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-StringTable"><span class="toc-text">43.StringTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-String%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">44.String的基本特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-String%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-text">45.String内存的分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-String%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">46.String的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">47.字符串拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-intern%EF%BC%88%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">48.intern（）的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-StringTable%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">49.StringTable的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-G1%E4%B8%AD%E7%9A%84String%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">50.G1中的String去重操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="toc-text">51.什么是垃圾？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC%EF%BC%9F"><span class="toc-text">52.为什么需要GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%97%A9%E6%9C%9F%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">53.早期的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">54.Java垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-text">55.垃圾判断算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%91%EF%BC%89%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">１）引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%92%EF%BC%89%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">２）可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="toc-text">56.对象的finalization机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-%E4%BD%BF%E7%94%A8MAT%E6%9F%A5%E7%9C%8BGC-Root"><span class="toc-text">57.使用MAT查看GC Root</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%8E%B7%E5%8F%96dump%E6%96%87%E4%BB%B6"><span class="toc-text">1）获取dump文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8jmap"><span class="toc-text">①命令行使用jmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1JvisualVM"><span class="toc-text">②JvisualVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BD%BF%E7%94%A8MAT%E5%88%86%E6%9E%90dump%E6%96%87%E4%BB%B6"><span class="toc-text">2）使用MAT分析dump文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%9F%A5%E7%9C%8BGC-Roots"><span class="toc-text">①查看GC Roots</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E4%BD%BF%E7%94%A8Jprofiler%E8%BF%9B%E8%A1%8CGCRoots%E6%B7%91%E6%BA%90"><span class="toc-text">58.使用Jprofiler进行GCRoots淑源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E4%BD%BF%E7%94%A8Jprofiler%E5%88%86%E6%9E%90OOM"><span class="toc-text">59.使用Jprofiler分析OOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">60.标记清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">61.标记整理算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">62.复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">63.分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">64.增量收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">65.分区算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">66.System.gc()的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">67.内存溢出与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">1）内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">2）内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-Stop-The-World"><span class="toc-text">68.Stop The World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">69.垃圾回收的并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%B9%B6%E8%A1%8C"><span class="toc-text">1）并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%B9%B6%E5%8F%91"><span class="toc-text">2）并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">70.安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-text">1）安全点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">2）安全区域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E5%BC%95%E7%94%A8"><span class="toc-text">71.引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%88%86%E7%B1%BB"><span class="toc-text">72.垃圾回收分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">73.评估GC的性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">74.不同的垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-text">1）垃圾收集器发展历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">2）垃圾收集器分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-Serial-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-text">75.Serial 回收器（串行回收器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-text">76.ParNew回收器（并行回收）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-Parallel-Scavenge-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-text">77.Parallel Scavenge 回收器（吞吐量优先）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">2）参数配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%89"><span class="toc-text">78.CMS回收器（低延迟）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89CMS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">2）CMS工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">3）参数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">4）小技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">5）后续版本变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%8C%BA%E5%9F%9F%E5%88%86%E4%BB%A3%E5%8C%96%EF%BC%89"><span class="toc-text">79.G1回收器（区域分代化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-2"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%89%B9%E7%82%B9"><span class="toc-text">2）特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">①并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-text">②分代收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%A9%BA%E9%97%B4%E6%95%B4%E5%90%88"><span class="toc-text">③空间整合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4"><span class="toc-text">④可预测的停顿时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%BC%BA%E7%82%B9"><span class="toc-text">3）缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">4）参数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89G1%E8%B0%83%E4%BC%98%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">5）G1调优的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6）适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89Humongous"><span class="toc-text">7）Humongous</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%89%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-text">8）回收过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-text">①记忆集与写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B9%B4%E8%BD%BB%E4%BB%A3GC"><span class="toc-text">②年轻代GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">②并发标记过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="toc-text">③混合回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3Full-GC"><span class="toc-text">④Full GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4G1%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="toc-text">⑤G1回收器优化建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-text">80.垃圾回收器总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AF%B9%E6%AF%94"><span class="toc-text">1）对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">2）垃圾回收器的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-text">3）怎么选择垃圾回收器？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-text">81.GC日志分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">1）内存分配与垃圾回收的参数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89GC%E6%97%A5%E5%BF%97%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-text">2）GC日志中垃圾回收数据分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">82.日志分析工具的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95"><span class="toc-text">83.垃圾回收器的新发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Epsilon-GC"><span class="toc-text">1）Epsilon GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Shenandoah-GC"><span class="toc-text">2）Shenandoah GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89ZGC"><span class="toc-text">3）ZGC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">84.类的加载器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">1）类加载的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">2）类加载的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">3）命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BD%95%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F"><span class="toc-text">①何为类的唯一性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">②命名空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">4）类加载机制的基本特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-text">85.类加载器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Bootstrap-ClassLoader"><span class="toc-text">1）Bootstrap ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Extension-ClassLoader"><span class="toc-text">2）Extension ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89AppClassLoader"><span class="toc-text">3）AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89User-DIY-ClassLoader"><span class="toc-text">4）User DIY ClassLoader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">86.测试不同的类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-ClassLoader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">87.ClassLoader源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89ClassLoader%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">1）ClassLoader的主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0loadClass-%E7%9A%84%E5%89%96%E6%9E%90"><span class="toc-text">①loadClass()的剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89SecureClassLoader%E4%B8%8EURLClassLoader"><span class="toc-text">2）SecureClassLoader与URLClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89ExtClassLoader%E4%B8%8EAppClassLoader"><span class="toc-text">3）ExtClassLoader与AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89Class-forName%E4%B8%8EClassLoader-loadClass"><span class="toc-text">4）Class.forName与ClassLoader.loadClass()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">88.双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="toc-text">1)定义与本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%9C%AC%E8%B4%A8"><span class="toc-text">②本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-text">2）优势与劣势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8A%BF"><span class="toc-text">①双亲委派机制优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BB%A3%E7%A0%81%E6%94%AF%E6%8C%81"><span class="toc-text">②代码支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%B8%BE%E4%BE%8B"><span class="toc-text">③举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%80%9D%E8%80%83"><span class="toc-text">④思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">⑤双亲委托模式的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E7%BB%93%E8%AE%BA"><span class="toc-text">⑥结论:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">3）破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B61"><span class="toc-text">①破坏双亲委派机制1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B62"><span class="toc-text">②破坏双亲委派机制2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B63"><span class="toc-text">③破坏双亲委派机制3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">4）热替换的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">89.沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89JDK1-0%E6%97%B6%E6%9C%9F"><span class="toc-text">1）JDK1.0时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89JDK1-1%E6%97%B6%E6%9C%9F"><span class="toc-text">2）JDK1.1时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89JDK1-2%E6%97%B6%E6%9C%9F"><span class="toc-text">3）JDK1.2时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89JDK1-6%E6%97%B6%E6%9C%9F"><span class="toc-text">4）JDK1.6时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#90-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">90.自定义类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">1）为什么要自定义类加载器?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">2）常见的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%B3%A8%E6%84%8F"><span class="toc-text">3）注意:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">4）实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">①实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AF%B9%E6%AF%94"><span class="toc-text">②对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E"><span class="toc-text">③说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">91.类加载器Java9新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-jvm%E7%9B%91%E6%8E%A7-JPS-%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84java%E8%BF%9B%E7%A8%8B"><span class="toc-text">92.jvm监控   JPS-查看正在运行的java进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-3"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2）基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0options%E5%8F%82%E6%95%B0"><span class="toc-text">①options参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1hostid%E5%8F%82%E6%95%B0"><span class="toc-text">②hostid参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-jvm%E7%9B%91%E6%8E%A7-jstat-%E6%9F%A5%E7%9C%8BJVM%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">93.jvm监控   jstat-查看JVM统计信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-4"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">2）基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0option%E5%8F%82%E6%95%B0"><span class="toc-text">①option参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1interval%E5%8F%82%E6%95%B0"><span class="toc-text">②interval参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2count%E5%8F%82%E6%95%B0"><span class="toc-text">③count参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-t%E5%8F%82%E6%95%B0"><span class="toc-text">④-t参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-h%E5%8F%82%E6%95%B0"><span class="toc-text">⑤-h参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%A1%A5%E5%85%85-1"><span class="toc-text">3）补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-jvm%E7%9B%91%E6%8E%A7-jinfo-%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E4%BF%AE%E6%94%B9JVM%E5%8F%82%E6%95%B0"><span class="toc-text">94.jvm监控   jinfo-实时查看和修改JVM参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-5"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-text">2）基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%9F%A5%E7%9C%8B"><span class="toc-text">①查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BF%AE%E6%94%B9"><span class="toc-text">②修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%8B%93%E5%B1%95"><span class="toc-text">3）拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-jvm%E7%9B%91%E6%8E%A7-jmap-%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6-amp-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">95.jvm监控   jmap-导出内存映像文件&amp;内存使用情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-6"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-text">2）基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%BC%E5%87%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-text">3)导出内存映像文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%89%8B%E5%8A%A8"><span class="toc-text">①手动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%87%AA%E5%8A%A8"><span class="toc-text">②自动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%98%BE%E7%A4%BA%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-text">4)显示堆内存相关信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0jmap-heap-%E8%BF%9B%E7%A8%8Bid"><span class="toc-text">①jmap -heap 进程id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1jmap-histo-%E8%BF%9B%E7%A8%8Bid"><span class="toc-text">②jmap -histo 进程id</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E5%85%B6%E4%BB%96%E4%BD%9C%E7%94%A8"><span class="toc-text">5）其他作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-jvm%E7%9B%91%E6%8E%A7-jhat-JDK%E8%87%AA%E5%B8%A6%E5%A0%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">96.jvm监控   jhat-JDK自带堆分析工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1)概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-text">2）基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0options%E5%8F%82%E6%95%B0-1"><span class="toc-text">①options参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-jvm%E7%9B%91%E6%8E%A7-jstack-%E6%89%93%E5%8D%B0JVM%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7"><span class="toc-text">97.jvm监控   jstack-打印JVM中线程快照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-7"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-5"><span class="toc-text">2）基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0option%E5%8F%82%E6%95%B0-1"><span class="toc-text">①option参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-jvm%E7%9B%91%E6%8E%A7-jcmd-%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-text">98.jvm监控   jcmd-多功能命令行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-8"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%AF%AD%E6%B3%95"><span class="toc-text">2）语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99-jvm%E7%9B%91%E6%8E%A7-jstatd-%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-text">99.jvm监控   jstatd-远程主机信息收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#100-jvm%E7%9B%91%E6%8E%A7-Eclipse-MAT"><span class="toc-text">100.jvm监控   Eclipse MAT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%A6%82%E8%BF%B0-9"><span class="toc-text">1）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%8E%B7%E5%8F%96%E5%A0%86dump%E6%96%87%E4%BB%B6"><span class="toc-text">2）获取堆dump文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0dump%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%98"><span class="toc-text">①dump文件内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%AF%B4%E6%98%8E"><span class="toc-text">2）说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%8E%B7%E5%8F%96dump%E6%96%87%E4%BB%B6"><span class="toc-text">3）获取dump文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%88%86%E6%9E%90%E5%A0%86dump%E6%96%87%E4%BB%B6"><span class="toc-text">4）分析堆dump文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0histogram"><span class="toc-text">①histogram</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1thread-overview"><span class="toc-text">②thread overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%8E%B7%E5%BE%97%E5%AF%B9%E8%B1%A1%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">③获得对象互相引用的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%B5%85%E5%A0%86%E4%B8%8E%E6%B7%B1%E5%A0%86"><span class="toc-text">④浅堆与深堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E6%94%AF%E9%85%8D%E6%A0%91"><span class="toc-text">⑤支配树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E6%A1%88%E4%BE%8B%EF%BC%9ATomcat%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90"><span class="toc-text">5）案例：Tomcat堆溢出分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%AF%B4%E6%98%8E"><span class="toc-text">①说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-text">②分析过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89%E6%94%AF%E6%8C%81%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">6）支持使用OQL语言查询对象信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-jvm%E7%9B%91%E6%8E%A7-Arthas"><span class="toc-text">101.jvm监控  Arthas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="toc-text">1）基本概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%83%8C%E6%99%AF"><span class="toc-text">①背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">②概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%9F%BA%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%80%8C%E6%9D%A5"><span class="toc-text">③基于哪些工具开发而来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="toc-text">④官方文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">2）安装与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%89%E8%A3%85"><span class="toc-text">①安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95"><span class="toc-text">②工程目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%90%AF%E5%8A%A8"><span class="toc-text">③启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">④查看进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-text">⑤查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9"><span class="toc-text">⑥查看帮助</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6web-console"><span class="toc-text">⑦web console</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7%E9%80%80%E5%87%BA"><span class="toc-text">⑧退出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%9B%B8%E5%85%B3%E8%AF%8A%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-text">3）相关诊断指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">①基础指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1jvm%E7%9B%B8%E5%85%B3"><span class="toc-text">②jvm相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2class-classloader%E7%9B%B8%E5%85%B3"><span class="toc-text">③class&#x2F;classloader相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3monitor-watch-trace%E7%9B%B8%E5%85%B3"><span class="toc-text">④monitor&#x2F;watch&#x2F;trace相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%85%B6%E4%BB%96"><span class="toc-text">⑤其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E5%86%8D%E8%B0%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">102.再谈内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-text">1）内存泄露的理解与分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Java%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%848%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">2）Java中内存泄露的8种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">3）内存泄露案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BB%A3%E7%A0%81"><span class="toc-text">①代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%88%86%E6%9E%90"><span class="toc-text">②分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">③解决办法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#103-GC%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">103.GC日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89GC%E5%88%86%E7%B1%BB"><span class="toc-text">1）GC分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8D%E5%90%8CGC%E5%88%86%E7%B1%BB%E7%9A%84GC%E7%BB%86%E8%8A%82"><span class="toc-text">2）不同GC分类的GC细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%80%81%E5%B9%B4%E4%BB%A3%E4%BD%BF%E7%94%A8CMS-GC"><span class="toc-text">①老年代使用CMS GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%96%B0%E7%94%9F%E4%BB%A3%E4%BD%BF%E7%94%A8Serial-GC"><span class="toc-text">②新生代使用Serial GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89GC%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB"><span class="toc-text">3）GC日志分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0MinorGC"><span class="toc-text">①MinorGC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1FullGC"><span class="toc-text">②FullGC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89GC%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-text">4）GC日志结构剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">①垃圾收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1GC%E5%89%8D%E5%90%8E%E6%83%85%E5%86%B5"><span class="toc-text">②GC前后情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2GC%E6%97%B6%E9%97%B4"><span class="toc-text">③GC时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Minor-GC-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-text">5)Minor GC 日志解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Full-GC-%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="toc-text">6)Full GC 日志解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">104.垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-GC-Root%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">105.GC Root有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#106-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">106.垃圾回收器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#107-CMS%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">107.CMS运行过程，缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-G1%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">108.G1运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#109-G1%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-text">109.G1适合什么场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#110-%E5%88%A4%E6%96%AD%E5%85%83%E7%A9%BA%E9%97%B4%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-text">110.判断元空间是无用的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E5%AE%89%E5%85%A8%E7%82%B9%E5%92%8C%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">111.安全点和安全区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-YGC%E5%92%8CFGC%E5%8F%91%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">112.YGC和FGC发生的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#113-jstack%EF%BC%8Cjmap%EF%BC%8CJstat%E4%BD%9C%E7%94%A8"><span class="toc-text">113.jstack，jmap，Jstat作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%AD%98-Redis"><span class="toc-text">四、缓存:Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">分布式锁怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setnx%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">setnx用到的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存穿透，击穿，雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">Redis过期键删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">Redis持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">缓存与数据库数据一致性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81MQ"><span class="toc-text">五、MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rabbitmq%E7%94%9F%E4%BA%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">Rabbitmq生产高可用怎么实现的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">六、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E5%92%8Cwait%E5%8C%BA%E5%88%AB"><span class="toc-text">sleep和wait区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E4%BD%9C%E7%94%A8"><span class="toc-text">Volitile作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volitile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">Volitile如何保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-text">指令重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Java线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%91%BD%E4%BB%A4"><span class="toc-text">linux查看线程命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">Java线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Thread常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">ThreadLocal的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">ThreadLocal应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-text">ThreadLocal内存泄露原因，如何避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CReentranLock%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">synchronized和ReentranLock区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E6%9C%89%EF%BC%8C%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-text">线程池参数有，核心线程配置，原因？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81spring"><span class="toc-text">七、spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">Bean的初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">AOP的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#springMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-text">springMVC处理请求流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">spring事务的传播机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C"><span class="toc-text">八、网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http1-0%E5%92%8Chttp1-1%E5%8C%BA%E5%88%AB"><span class="toc-text">http1.0和http1.1区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E4%B8%8EHTTP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-text">HTTPS与HTTP的一些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">http三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">四次挥手</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">九、设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Dubbo"><span class="toc-text">十、Dubbo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84json%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">你知道的json序列化方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="toc-text">两个系统之间怎么交互的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dubbo%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-text">dubbo的序列化？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Netty"><span class="toc-text">十一、Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-text">NIO三大核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Netty线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-text">Netty模块组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-text">Netty粘包拆包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81zookeeper"><span class="toc-text">十二、zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">zookeeper的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">zookeeper选举机制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E7%90%86%E8%AE%BA"><span class="toc-text">十三、理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="toc-text">CAP理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD"><span class="toc-text">DDD</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E9%A1%B9%E7%9B%AE"><span class="toc-text">十四、项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%AE%80%E4%BB%8B"><span class="toc-text">ES简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES%E6%9F%A5%E8%AF%A2%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">ES查询快的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ES%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用ES注意事项</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/29/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读"><img src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap源码解读"/></a><div class="content"><a class="title" href="/2022/08/29/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读">ConcurrentHashMap源码解读</a><time datetime="2022-08-29T08:07:33.022Z" title="发表于 2022-08-29 16:07:33">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql执行流程"/></a><div class="content"><a class="title" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程">mysql执行流程</a><time datetime="2022-04-01T16:00:00.000Z" title="发表于 2022-04-02 00:00:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/mysql/" title="mysql面试"><img src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql面试"/></a><div class="content"><a class="title" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/mysql/" title="mysql面试">mysql面试</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法"><img src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法">数据结构和算法</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试知识点总结"><img src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试知识点总结"/></a><div class="content"><a class="title" href="/2022/03/31/12.%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试知识点总结">面试知识点总结</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>