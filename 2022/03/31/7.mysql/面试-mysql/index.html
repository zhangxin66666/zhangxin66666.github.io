<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mysql面试 | 金子爸爸の家</title><meta name="keywords" content="Mysql"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="mysql常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql面试">
<meta property="og:url" content="https://zhangxin66666.github.io/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="mysql常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png">
<meta property="article:published_time" content="2022-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-07T12:38:56.676Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-07 20:38:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-07T12:38:56.676Z" title="更新于 2025-01-07 20:38:56">2025-01-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-索引底层结构-amp-行格式-amp-页格式"><a href="#1-索引底层结构-amp-行格式-amp-页格式" class="headerlink" title="1.索引底层结构&amp;行格式&amp;页格式"></a>1.索引底层结构&amp;行格式&amp;页格式</h2><p>文章内容包含索引结构，联合索引结构，聚簇索引、非聚簇索引区别，在页上如何搜索具体数据过程，一次完成的索引检索过程</p>
<p>地址：<a href="/2022/01/05/7.mysql/行页索引底层结构" target="_blank">行页索引底层结构</a></p>
<h2 id="2-一条-SQL-的执行过程详解"><a href="#2-一条-SQL-的执行过程详解" class="headerlink" title="2.一条 SQL 的执行过程详解"></a>2.一条 SQL 的执行过程详解</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/02/jK9nFC.png" alt="image-20220402151247405"></p>
<p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<p>至此表示整个更新事务已经完成</p>
<p><strong>为什么Mysql不能直接更新磁盘上的数据而且设置这么一套复杂的机制来执行SQL了？</strong></p>
<p>因为来一个请求就直接对磁盘文件进行随机读写，然后更新磁盘文件里的数据性能可能相当差。因为磁盘随机读写的性能是非常差的，所以直接更新磁盘文件是不能让数据库抗住很高并发的。</p>
<p>Mysql这套机制看起来复杂，但它可以保证每个更新请求都是<strong>更新内存BufferPool</strong>，然后<strong>顺序写日志文件</strong>，同时还能</p>
<p>保证各种异常情况下的数据一致性。</p>
<p>更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是非常高的，要远高于随机读写磁盘文件。</p>
<p>正是通过这套机制，才能让我们的MySQL数据库在较高配置的机器上每秒可以抗下几干的读写请求。</p>
<p>细节介绍server层连接器、词法分析器、优化器、执行器、查询缓存功能见单独文章</p>
<p>地址：<a href="/2022/04/02/7.mysql/mysql执行流程" target="_blank">mysql执行流程</a></p>
<h2 id="3-ACID及实现原理"><a href="#3-ACID及实现原理" class="headerlink" title="3.ACID及实现原理"></a>3.ACID及实现原理</h2><ul>
<li>（Atomicity）原子性： 事务是最小的执行单位，不允许分割。要么全都执行,要么全都不执行；——-&gt;原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时，撤销已经执行成功的sql</li>
<li>（Consistency）一致性： 执行事务前后，数据保持一致；——-&gt;原子性、隔离性、持久性就是为了来保证一致性</li>
<li>（Isolation）隔离性： 并发访问数据库时，一个事务不被其他事务所干扰，数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行；——-&gt;锁机制和MVCC共同实现</li>
<li>（Durability）持久性: 一个事务被提交之后。对数据库中数据的改变是持久的，即使数据库发生故障也不会受到影响。——-&gt;持久性由redolog来保证的，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。</li>
</ul>
<h2 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4.MVCC"></a>4.MVCC</h2><p>MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。</p>
<p>MVCC主要解决三个问题：</p>
<p>第一、通过MVCC可以解决读写并发阻塞问题，从而提高数据库的并发处理能力；</p>
<p>第二、MVCC采用的是乐观锁的方式实现，降低了死锁的概率；</p>
<p>第三、解决了一致性读的问题，也就是事务启动的时候，根据某个条件去读取到的数据，知道事务结束的时候再去执行相同条件，还是读到同一份数据，不会发生变化变化。</p>
<p><strong>MVCC用于读已提交（RC）和可重复读级别（RR）的控制，主要通过undo log日志版本链和read view来实现，</strong></p>
<p>InnoDB中MVCC的实现依赖四个条件: 隐藏字段, 事务链表，read view, undo log</p>
<p>数据表额外字段</p>
<p><strong>DB_TRX_ID(6字节)</strong>: 在innoDB中, 会为每个事物分配一个事务ID. 而该字段表示的就是插入或更新该行的最后一个事务的事务标识符.</p>
<p><strong>DB_ROLL_PTR(7字节)</strong>: 这个字段称为回滚指针, 指向了回滚段的撤销日志. (undo log)</p>
<p><strong>DB_ROW_ID(6字节)</strong>:  这个字段包含了一个行ID. 该ID在插入新行时会单调增加. 这个字段是为了在表里没有主键ID的时候, 生成聚簇索引使用的.</p>
<p>rowid存的是什么？</p>
<p>rowid默认是主键，如果没有主键，会选择唯一键，如果没有唯一键，会生成6字节的rowid</p>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/7Syg8j.png" alt="聚簇索引行结构" style="zoom: 67%;" />



<p>undo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚</p>
<p>日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kP6kYm.png" alt="image-20220407160145376"></p>
<p>在<strong>可重复读隔离级别（RR）</strong>，当事务开启，执行任何查询sql时会生成当前事务的<strong>一致性视图read-view，</strong>该视图在事务结束</p>
<p>之前都不会变化(<strong>如果是读已提交隔离级别在每次执行查询sql时都会重新生成</strong>)，这个视图由执行查询时所有未提交事</p>
<p>务id数组（数组里最小的id为min_id）和已创建的最大事务id（max_id）组成，事务里的任何sql查询结果需要从对应</p>
<p>版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。</p>
<p><strong>版本链比对规则：</strong></p>
<ol>
<li><p>如果 row 的 trx_id 落在绿色部分( trx_id&lt;min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的；</p>
</li>
<li><p>如果 row 的 trx_id 落在红色部分( trx_id&gt;max_id )，表示这个版本是由将来启动的事务生成的，是不可见的(若</p>
</li>
</ol>
<p>row 的 trx_id 就是当前自己的事务是可见的）；3. 如果 row 的 trx_id 落在黄色部分(min_id &lt;=trx_id&lt;= max_id)，那就包括两种情况</p>
<p>​        a. 若 row 的 trx_id 在视图数组中，表示这个版本是由还没提交的事务生成的，不可见(若 row 的 trx_id 就是当前自</p>
<p>己的事务是可见的)；</p>
<p>​        b. 若 row 的 trx_id 不在视图数组中，表示这个版本是已经提交了的事务生成的，可见。</p>
<p>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的</p>
<p>trx_id，同时在该条记录的头信息（record header）里的（deleted_flag）标记位写上true，来表示当前记录已经被</p>
<p>删除，在查询时按照上面的规则查到对应的记录如果delete_flag标记位为true，意味着记录已被删除，则不返回数</p>
<p>据。</p>
<p><strong>注意：</strong>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句，</p>
<p>事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。</p>
<p><strong>总结：</strong></p>
<p>MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取</p>
<p>同一条数据在版本链上的不同版本数据。</p>
<h2 id="5-mysql三大日志"><a href="#5-mysql三大日志" class="headerlink" title="5.mysql三大日志"></a>5.mysql三大日志</h2><p>地址：<a href="/2021/12/27/7.mysql/mysql三大日志" target="_blank">mysql三大日志</a></p>
<h2 id="6-redo日志"><a href="#6-redo日志" class="headerlink" title="6.redo日志"></a>6.redo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/redo日志" target="_blank">redo日志</a></p>
<h2 id="7-undo日志"><a href="#7-undo日志" class="headerlink" title="7.undo日志"></a>7.undo日志</h2><p>地址：<a href="/2021/12/27/7.mysql/undo日志" target="_blank">undo日志</a></p>
<h2 id="8-能说下myisam-和-innodb的区别吗"><a href="#8-能说下myisam-和-innodb的区别吗" class="headerlink" title="8.能说下myisam 和 innodb的区别吗"></a>8.能说下myisam 和 innodb的区别吗</h2><table>
<thead>
<tr>
<th>区别</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引</td>
<td>聚簇索引和非聚簇索引</td>
<td>非聚簇索引</td>
</tr>
<tr>
<td>行锁</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>存储文件</td>
<td>frm(表结构)，ibd(数据和索引)</td>
<td>frm，myi(索引文件)，myd(数据文件)</td>
</tr>
<tr>
<td>具体行数</td>
<td>全表扫描统计行数</td>
<td>通过变量保存行数</td>
</tr>
</tbody></table>
<ul>
<li>MyISAM不支持事务，在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。</li>
<li>InnoDB在执行查询语句SELECT时(非串行隔离级别)，(因为有mvcc机制)不会加锁。但是update、insert、delete操作会加行锁。简而言之，就是<strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</li>
</ul>
<h2 id="9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"><a href="#9-说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别" class="headerlink" title="9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别"></a>9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别</h2><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
<h2 id="10-什么是覆盖索引和回表"><a href="#10-什么是覆盖索引和回表" class="headerlink" title="10.什么是覆盖索引和回表"></a>10.什么是覆盖索引和回表</h2><p>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。</p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助 索引。当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为回表。也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树—-一次辅助索引，一次聚集索引。</p>
<h2 id="11-mysql的各种锁。-间隙锁"><a href="#11-mysql的各种锁。-间隙锁" class="headerlink" title="11.mysql的各种锁。  间隙锁"></a>11.mysql的各种锁。  间隙锁</h2><p>锁分类图解</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/SNv09f.png" alt="image-20220407172447222"></p>
<p><strong>按照兼容性分类</strong></p>
<p>InnoDB实现了以下两种类型的行锁。</p>
<p><strong>「共享锁（S)」</strong>：又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据， 但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>
<p><strong>「排他锁（X)」</strong>：exclusive lock（也叫writer lock）又称写锁。 若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前， 其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。 <strong>「排它锁是悲观锁的一种实现」</strong>。</p>
<p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），<code>这两种意向锁都是表锁</code>。</p>
<p><strong>「意向共享锁（IS）」</strong>：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p><strong>「意向排他锁（IX）」</strong>：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p><strong>「InnoDB行锁模式兼容性列表」</strong></p>
<table>
<thead>
<tr>
<th>请求锁模式 是否兼容当前锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT写操作，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<p>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。</p>
<p>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。</p>
<p>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在， 并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作， 则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p>
<p>InnoDB在事务执行过程中，使用<code>两阶段锁协议</code>：</p>
<p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p>
<p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p>
<p><strong>按算法分类</strong></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/acUCbj.jpg" alt="img"></p>
<p><strong>「Record Lock」</strong>： 单个行记录上的锁</p>
<p>锁总会锁住索引记录，锁住的是key。</p>
<p>如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB会使用隐式的主键进行锁定。</p>
<p>如果要锁的没有索引，则会进行全表记录加锁。</p>
<p><strong>「Gap Lock」</strong> ：间隙锁，锁定一个范围，但不包含记录本身</p>
<p>锁定索引记录间隙，确保索引记录的间隙不变</p>
<p>间隙锁时针对事务隔离级别为可重复读或以上级别而配的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读</span><br></pre></td></tr></table></figure>

<p><strong>「Next-Key Lock」</strong>：临键锁，Gap Lock + Record Lock，锁定一个范围，并且包含记录本身</p>
<p>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</p>
<p>当查询的索引为辅助索引时，默认使用Next-Key Locking技术进行加锁，锁定范围是前一个索引到后一个索引之间范围。</p>
<h2 id="12-MRR"><a href="#12-MRR" class="headerlink" title="12.MRR"></a>12.MRR</h2><p>每次从二级索引中读取到一条记录后，就会根据该记录的主键值 执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些</p>
<p>二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。 每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机IO带来的 性能开销比较大。MySQL中提出了一个名为Disk-Sweep Multi-Range Read (MRR，多范围 读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执 行回表操作。</p>
<p>相对于每读取一条二级索引记录就立即执行回表操作，这样会节省一些IO开销。使用这个 MRR优化措施的条件比较苛刻，所以我们直接认为每读取一条二级索引记录就立即执行回表操作。MRR的详细信息，可以查询官方文档。</p>
<h2 id="13-分库分表"><a href="#13-分库分表" class="headerlink" title="13.分库分表"></a>13.分库分表</h2><h2 id="14-分布式唯一id"><a href="#14-分布式唯一id" class="headerlink" title="14.分布式唯一id"></a>14.分布式唯一id</h2><h2 id="15-数据库三大范式是什么"><a href="#15-数据库三大范式是什么" class="headerlink" title="15.数据库三大范式是什么"></a>15.数据库三大范式是什么</h2><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h2 id="16-InnoDB引擎的4大特性"><a href="#16-InnoDB引擎的4大特性" class="headerlink" title="16.InnoDB引擎的4大特性"></a>16.InnoDB引擎的4大特性</h2><p>插入缓冲（insert buffer)</p>
<p>二次写(double write)</p>
<p>自适应哈希索引(ahi)</p>
<p>预读(read ahead)</p>
<h2 id="17-索引失效的情况"><a href="#17-索引失效的情况" class="headerlink" title="17.索引失效的情况"></a>17.索引失效的情况</h2><p>谈到索引主要从两方面来分析：IO 和数据结构：不管索引数据还是行数据，都是存在磁盘里面的，我们尽可能少的取出数据</p>
<ul>
<li>IO—–&gt;读取次数少、量少——&gt;分块读取——&gt;局部性原理、磁盘预读</li>
<li>数据结构——&gt;B+树——&gt;二叉树、AVL树、红黑树、B树</li>
</ul>
<ol>
<li>组合索引不遵循最左匹配原则</li>
<li>组合索引前面索引列使用范围查询(&lt;,&gt;,like),会导致后续索引失效；</li>
<li>不要在索引上做任何操作（计算，函数，类型转换）</li>
<li>is null和is not null 无法使用索引</li>
<li>尽量少使用or操作符，否则连接时索引会失效</li>
<li>字符串不添加引号会导致索引失效（隐式类型转换）</li>
<li>两表关联使用的条件字段中字段的长度，编码不一致会导致索引失效</li>
<li>like语句中，以%开头的模糊查询会导致索引失效</li>
<li>如果mysql中使用全表扫描比索引快，也会导致索引失效 （force index:强制使用索引）</li>
</ol>
<h2 id="18-最左前缀原则。-联合索引使用分析实战"><a href="#18-最左前缀原则。-联合索引使用分析实战" class="headerlink" title="18.最左前缀原则。 联合索引使用分析实战"></a>18.最左前缀原则。 联合索引使用分析实战</h2><p>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p>实战？？</p>
<h2 id="19-sql优化之explain-详解"><a href="#19-sql优化之explain-详解" class="headerlink" title="19.sql优化之explain 详解"></a>19.sql优化之explain 详解</h2><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，而不是执行这条SQL</p>
<p>接下来我们将展示 explain 中每个列的信息</p>
<p><strong>19.1. id列</strong></p>
<p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。</p>
<p>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p>
<p><strong>19.2. select_type列</strong></p>
<p>select_type 表示对应行是简单还是复杂的查询。</p>
<p>1）simple：</p>
<p>简单查询。查询不包含子查询和union</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film where id = 2; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/T5Cula.png" alt="image-20220407160800996"></p>
<p>2）primary：</p>
<p>复杂查询中最外层的 select</p>
<p>3）subquery：</p>
<p>包含在 select 中的子查询（不在 from 子句中）</p>
<p>4）derived：</p>
<p>包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>用这个例子来了解 primary、subquery 和 derived 类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合 并优化 </span><br><span class="line"></span><br><span class="line">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/q2w4D3.png" alt="image-20220407161247159"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置 </span><br></pre></td></tr></table></figure>

<p>5）union：</p>
<p>在 union 中的第二个和随后的 select</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/kCABNr.png" alt="image-20220407161256284"></p>
<p><strong>19.3. table列</strong></p>
<p>这一列表示 explain 的一行正在访问哪个表。</p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查</p>
<p>询。</p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>
<p><strong>19.4. type列</strong></p>
<p>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。</p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p>
<p>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong></p>
<p><strong>NULL</strong>：</p>
<p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可</p>
<p>以单独查找索引来完成，不需要在执行时访问表</p>
<p>1 mysql&gt; explain select min(id) from film;</p>
<p><strong>const, system</strong>：</p>
<p>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于</p>
<p>primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是</strong></p>
<p><strong>const的特例</strong>，表里只有一条元组匹配时为system</p>
<p>1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</p>
<p>1 mysql&gt; show warnings;</p>
<p><strong>eq_ref</strong>：</p>
<p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在</p>
<p>const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<p>1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</p>
<p><strong>ref</strong>：</p>
<p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会</p>
<p>找到多个符合条件的行。</p>
<ol>
<li>简单 select 查询，name是普通索引（非唯一索引）</li>
</ol>
<p>1 mysql&gt; explain select * from film where name = ‘film1’;</p>
<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</p>
<p>1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.fi</p>
<p>lm_id;</p>
<p><strong>range</strong>：</p>
<p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<p>1 mysql&gt; explain select * from actor where id &gt; 1;<strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接</p>
<p>对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这</p>
<p>种通常比ALL快一些。</p>
<p>1 mysql&gt; explain select * from film;</p>
<p><strong>ALL</strong>：</p>
<p>即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p>
<p>1 mysql&gt; explain select * from actor;</p>
<p><strong>19.5. possible_keys列</strong></p>
<p>这一列显示查询可能使用哪些索引来查找。</p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引</p>
<p>对此查询帮助不大，选择了全表查询。</p>
<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提</p>
<p>高查询性能，然后用 explain 查看效果。</p>
<p><strong>19.6. key列</strong></p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force</p>
<p>index、ignore index。</p>
<p><strong>19.7. key_len列</strong></p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通</p>
<p>过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id = 2; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/euMjk1.png" alt="image-20220407162337179"></p>
<p>key_len计算规则如下：</p>
<p><strong>字符串</strong>，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数，</strong>如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节</p>
<p>​            char(n)：如果存汉字长度就是 3n 字节</p>
<p>​            varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为varchar是变长字符串</p>
<p><strong>数值类型</strong></p>
<p>​            tinyint：1字节</p>
<p>​            smallint：2字节</p>
<p>​            int：4字节</p>
<p>​            bigint：8字节</p>
<p><strong>时间类型</strong></p>
<p>​            date：3字节timestamp：4字节</p>
<p>​            datetime：8字节</p>
<p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<p><strong>19.8. ref列</strong></p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>
<p><strong>19.9. rows列</strong></p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<p><strong>19.10. Extra列</strong></p>
<p>这一列展示的是额外信息。常见的重要值如下：</p>
<p>1）<strong>Using index</strong>：使用覆盖索引</p>
<p><strong>覆盖索引定义</strong>：mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select film_id from film_actor where film_id = 1; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/HDa0QJ.png" alt="image-20220407162614921"></p>
<p>2）<strong>Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor where name = &#x27;a&#x27;; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TCOus4.png" alt="image-20220407162649995"></p>
<p>3）<strong>Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film_actor where film_id &gt; 1; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/R67z2o.png" alt="image-20220407162726922"></p>
<p>4）<strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索</p>
<p>引来优化。</p>
<ol>
<li>actor.name没有索引，此时创建了张临时表来distinct</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from actor; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/zN1qNX.png" alt="image-20220407162748356"></p>
<ol start="2">
<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select distinct name from film; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/TJBQvc.png" alt="image-20220407162804564"></p>
<p>5）<strong>Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p>
<ol>
<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/bvNR53.png" alt="image-20220407162837176"></p>
<ol start="2">
<li>film.name建立了idx_name索引,此时查询时extra是using index</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from film order by name; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/LmfAA3.png" alt="image-20220407162904215"></p>
<p>6）<strong>Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select min(id) from film; </span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/XKI9h9.png" alt="image-20220407162921288"></p>
<h2 id="20-mysql主从复制原理"><a href="#20-mysql主从复制原理" class="headerlink" title="20.mysql主从复制原理"></a>20.mysql主从复制原理</h2><ol>
<li><p>master提交完事务后，写入binlog</p>
</li>
<li><p>slave连接到master，获取binlog</p>
</li>
<li><p>master创建dump线程，推送binglog到slave</p>
</li>
<li><p>slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中</p>
</li>
<li><p>slave再开启一个sql线程读取relay log事件并在slave执行，完成同步</p>
</li>
<li><p>slave记录自己的binglog</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/yEQbgw.jpeg" alt="图片"></p>
</li>
</ol>
<img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/wfHRhP.png"/>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="21-主从同步延时如何解决"><a href="#21-主从同步延时如何解决" class="headerlink" title="21.主从同步延时如何解决"></a>21.主从同步延时如何解决</h2><h2 id="22-隔离级别"><a href="#22-隔离级别" class="headerlink" title="22.隔离级别"></a>22.隔离级别</h2><p>首先回忆四种mysql隔离级别</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读未提交（Read uncommitted）</td>
<td>一个事务还没提交时，它做的变更就能被别的事务看到</td>
</tr>
<tr>
<td align="left">读提交（Read committed）</td>
<td>一个事务提交之后，它做的变更才会被其他事务看到。出 于性能考虑互联网公司会使用RC+乐观锁</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td>一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。<strong>InnoDB默认级别</strong>。</td>
</tr>
<tr>
<td align="left">串行化（Serializable ）</td>
<td>事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，隔离级别最高，牺牲系统并发性。</td>
</tr>
</tbody></table>
<p>查看当前数据库的事务隔离级别:show variables like ‘%tx_isolation%’;</p>
<p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p>
<p>不同的隔离级别是为了解决不同的问题。也就是脏读、幻读、不可重复读。</p>
<p><strong>脏读</strong>：事务A读取到了事务B已经修改但尚未提交的数据，。</p>
<p><strong>不可重复读</strong>：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性。</p>
<p><strong>幻读</strong>：事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<p><strong>不可重复读&amp;&amp;幻读区别</strong></p>
<p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p>
<p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>可以出现</td>
<td>可以出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>读提交</td>
<td>不允许出现</td>
<td>可以出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>可重复读</td>
<td>不允许出现</td>
<td>不允许出现</td>
<td>可以出现</td>
</tr>
<tr>
<td>序列化</td>
<td>不允许出现</td>
<td>不允许出现</td>
<td>不允许出现</td>
</tr>
</tbody></table>
<p><strong>不同的隔离级别下，隔离性是靠锁机制和MVCC共同实现的。</strong></p>
<h2 id="23-RC和RR的本质区别。readview层面"><a href="#23-RC和RR的本质区别。readview层面" class="headerlink" title="23.RC和RR的本质区别。readview层面"></a>23.RC和RR的本质区别。readview层面</h2><p><strong>RC级别下每次都是重新生成read view，而在RR级别下则是一直使用事务内第一次查询时产生的read view。</strong></p>
<h2 id="24-什么是readview"><a href="#24-什么是readview" class="headerlink" title="24.什么是readview"></a>24.什么是readview</h2><p>ReadView可以理解为一个数据结构，在事务开始的时候会根据事务链表构造一个ReadView,初始化方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// readview 初始化</span><br><span class="line">// m_low_limit_id = trx_sys-&gt;max_trx_id; </span><br><span class="line">// m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span><br><span class="line">ReadView::ReadView()</span><br><span class="line">    :</span><br><span class="line">    m_low_limit_id(),</span><br><span class="line">    m_up_limit_id(),</span><br><span class="line">    m_creator_trx_id(),</span><br><span class="line">    m_ids(),</span><br><span class="line">    m_low_limit_no()</span><br><span class="line">&#123;</span><br><span class="line">    ut_d(::memset(&amp;m_view_list, 0x0, sizeof(m_view_list)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>trx_ids</code>: 表示事务开启的时候, 其它未提交的活跃的事务ID. 这个集合中的事务对于当前事务来说, 一直都是不可见的.</p>
<p><code>low_limit_id</code>: 表示在生成ReadView时当前系统中最大事务id.</p>
<p><code>up_limit_id</code>: 表示未提交活跃事务Id(trx_ids)的最大值. 如果trx_ids为空, 则up_limit_id=low_limit_id.</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/07/vsg7bA.png" alt="readview"></p>
<p>通过该ReadView，新的事务可以根据查询到的所有活跃事务记录的事务ID来匹配能够看见该记录，从而实现数据库的事务隔离，主要逻辑如下：</p>
<p>通过聚簇索引的行结构中DB_TRX_ID隐藏字段可以知道最近被哪个事务ID修改过。一个新的事务开始时会根据事务链表构造一个ReadView。当前事务根据ReadView中的数据去跟检索到的每一条数据去校验,看看当前事务是不是能看到这条数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 判断数据对应的聚簇索引中的事务id在这个readview中是否可见</span><br><span class="line">bool changes_visible(</span><br><span class="line">        trx_id_t        id, // 记录的id</span><br><span class="line">    const table_name_t&amp; name) const</span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id &gt; 0);</span><br><span class="line">    // 如果当前记录id &lt; 事务链表的最小值或者等于创建该readview的id就是它自己,那么是可见的</span><br><span class="line">    if (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    // 如果该记录的事务id大于事务链表中的最大值,那么不可见</span><br><span class="line">    if (id &gt;= m_low_limit_id) &#123;</span><br><span class="line">        return(false);</span><br><span class="line">        // 如果事务链表是空的,那也是可见的</span><br><span class="line">    &#125; else if (m_ids.empty()) &#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const ids_t::value_type*    p = m_ids.data();</span><br><span class="line"></span><br><span class="line">    //判断是否在ReadView中，如果在说明在创建ReadView时 此条记录还处于活跃状态则不应该查询到，否则说明创建ReadView是此条记录已经是不活跃状态则可以查询到</span><br><span class="line">    return(!std::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见性算法逻辑总结：</p>
<ol>
<li>当检索到的数据的事务ID小于事务链表中的最小值(数据行的DB_TRX_ID &lt; m_up_limit_id)表示这个数据在当前事务开启前就已经被其他事务修改过了,所以是可见的。</li>
<li>当检索到的数据的事务ID表示的是当前事务自己修改的数据(数据行的DB_TRX_ID = m_creator_trx_id) 时，数据可见。</li>
<li>当检索到的数据的事务ID大于事务链表中的最大值(数据行的DB_TRX_ID &gt;= m_low_limit_id) 表示这个数据在当前事务开启后到下一次查询之间又被其他的事务修改过,那么就是不可见的。</li>
<li>如果事务链表为空,那么也是可见的,也就是当前事务开始的时候,没有其他任意一个事务在执行。</li>
<li>当检索到的数据的事务ID在事务链表中的最小值和最大值之间，从m_low_limit_id到m_up_limit_id进行遍历，取出DB_ROLL_PTR指针所指向的回滚段的事务ID，把它赋值给 trx_id_current ，然后从步骤1重新开始判断，这样总能最后找到一个可用的记录。</li>
</ol>
<h2 id="25-快照读与当前读的区别"><a href="#25-快照读与当前读的区别" class="headerlink" title="25.快照读与当前读的区别"></a>25.快照读与当前读的区别</h2><p>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p>
<p><strong>快照读</strong>：就是select</p>
<ul>
<li>select * from table ….;</li>
</ul>
<p><strong>当前读</strong>：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert;</li>
<li>update ;</li>
<li>delete;</li>
</ul>
<h2 id="26-幻读和不可重复读区别"><a href="#26-幻读和不可重复读区别" class="headerlink" title="26.幻读和不可重复读区别"></a>26.幻读和不可重复读区别</h2><p>不可重复读，重点是修改。在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样，数据变化</p>
<p>幻读，重点在于新增或者删除。在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样，行数变化。</p>
<h2 id="27-MySQL在RR级别中完全解决了幻读的问题么？"><a href="#27-MySQL在RR级别中完全解决了幻读的问题么？" class="headerlink" title="27.MySQL在RR级别中完全解决了幻读的问题么？"></a>27.MySQL在RR级别中完全解决了幻读的问题么？</h2><h2 id="28-脏页是什么，刷脏页时机"><a href="#28-脏页是什么，刷脏页时机" class="headerlink" title="28.脏页是什么，刷脏页时机"></a>28.脏页是什么，刷脏页时机</h2><h2 id="29-bufferpool"><a href="#29-bufferpool" class="headerlink" title="29.bufferpool"></a>29.bufferpool</h2><h2 id="30-几大核心线程"><a href="#30-几大核心线程" class="headerlink" title="30.几大核心线程"></a>30.几大核心线程</h2><p><strong>purge线程</strong></p>
<p>对于一条delete语句 delete from t where a = 1，如果列a有聚集索引，则不会进行真正的删除，而只是在主键列等于1的记录delete flag设置为1，即记录还是存在在B+树中。而对于update操作，不是直接对记录进行更新，而是标识旧记录为删除状态，然后新产生一条记录。那这些旧版本标识位删除的记录何时真正的删除？怎么删除？</p>
<p>其实InnoDB是通过undo日志来进行旧版本的删除操作的，在InnoDB内部，这个操作被称之为purge操作，原来在srv_master_thread主线程中完成，后来进行优化，开辟了purge线程进行purge操作，并且可以设置purge线程的数量。purge操作每10s进行一次。</p>
<p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。此外，InnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行连接，如下面的一种情况：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/11/Zxv9V3.png" alt="purge"></p>
<p>在执行purge过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1所在的Undo page中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故再去history list中取查找，发现最尾端的记录时trx2，接着找到trx2所在的Undo page，依次把trx6、trx4清理，由于Undo page2中所有的记录都被清理了，因此该Undo page可以进行重用。</p>
<p>InnoDB存储引擎这种先从history list中找undo log，然后再从Undo page中找undo log的设计模式是为了避免大量随机读操作，从而提高purge的效率。</p>
<h2 id="31-事务传播机制"><a href="#31-事务传播机制" class="headerlink" title="31.事务传播机制"></a>31.事务传播机制</h2><h2 id="32-分布式事务通用方案"><a href="#32-分布式事务通用方案" class="headerlink" title="32.分布式事务通用方案"></a>32.分布式事务通用方案</h2><h2 id="33-成本分析"><a href="#33-成本分析" class="headerlink" title="33.成本分析"></a>33.成本分析</h2><h2 id="34-表中数据量如何计算总量"><a href="#34-表中数据量如何计算总量" class="headerlink" title="34.表中数据量如何计算总量"></a>34.表中数据量如何计算总量</h2><h2 id="35-count-1-count-count-id-count-字段-性能对比分析"><a href="#35-count-1-count-count-id-count-字段-性能对比分析" class="headerlink" title="35.count(1) count(*) count(id) count(字段) 性能对比分析"></a>35.count(1) count(*) count(id) count(字段) 性能对比分析</h2><p><strong>四个sql的执行计划一样，说明这四个sql执行效率应该差不多</strong></p>
<p><strong>字段有索引：count(*)≈count(1)&gt;count(字段)&gt;count(主键 id) //字段有索引，count(字段)统计走二级索引，二</strong></p>
<p><strong>级索引存储数据比主键索引少，所以count(字段)&gt;count(主键 id)</strong></p>
<p><strong>字段无索引：count(*)≈count(1)&gt;count(主键 id)&gt;count(字段) //字段没有索引count(字段)统计走不了索引，</strong></p>
<p><strong>count(主键 id)还可以走主键索引，所以count(主键 id)&gt;count(字段)</strong></p>
<p>count(1)跟count(字段)执行过程类似，不过count(1)不需要取出字段统计，就用常量1做统计，count(字段)还需要取出</p>
<p>字段，所以理论上count(1)比count(字段)会快一点。</p>
<p>count(*) 是例外，mysql并不会把全部字段取出来，而是专门做了优化，不取值，按行累加，效率很高，所以不需要用</p>
<p>count(列名)或count(常量)来替代 count(*)。</p>
<p>为什么对于count(id)，mysql最终选择辅助索引而不是主键聚集索引？因为二级索引相对主键索引存储数据更少，检索</p>
<p>性能应该更高，mysql内部做了点优化(应该是在5.7版本才优化)。</p>
<h2 id="36-mysql中in-和exists-区别"><a href="#36-mysql中in-和exists-区别" class="headerlink" title="36.mysql中in 和exists 区别"></a>36.mysql中in 和exists 区别</h2><h2 id="37-join查询原理"><a href="#37-join查询原理" class="headerlink" title="37.join查询原理"></a>37.join查询原理</h2><h2 id="38-索引下推"><a href="#38-索引下推" class="headerlink" title="38.索引下推"></a>38.索引下推</h2><p><strong>索引下推</strong>（Index Condition Pushdown，<strong>ICP</strong>), like KK%其实就是用到了索引下推优化</p>
<p><strong>什么是索引下推了？</strong></p>
<p>对于辅助的联合索引(name,age,position)，正常情况按照最左前缀原则，<strong>SELECT * FROM employees WHERE name like ‘LiLei%’</strong></p>
<p><strong>AND age = 22 AND position =’manager’</strong> 这种情况只会走name字段索引，因为根据name字段过滤完，得到的索引行里的age和</p>
<p>position是无序的，无法很好的利用索引。</p>
<p>在MySQL5.6之前的版本，这个查询只能在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引，然后拿这些索引对应的主键逐个回表，到主键索</p>
<p>引上找出相应的记录，再比对<strong>age</strong>和<strong>position</strong>这两个字段的值是否符合。</p>
<p>MySQL 5.6引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可</strong></p>
<p><strong>以有效的减少回表次数</strong>。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是 <strong>‘LiLei’ 开头</strong>的索引之后，同时还会在索引里过</p>
<p>滤<strong>age</strong>和<strong>position</strong>这两个字段，拿着过滤完剩下的索引对应的主键id再回表查整行数据。</p>
<p>索引下推会减少回表次数，对于innodb引擎的表索引下推只能用于二级索引，innodb的主键索引（聚簇索引）树叶子节点上保存的是全</p>
<p>行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
<p><strong>个人理解升华：</strong></p>
<p>我觉得like是这样，用到索引下推的场景，直接利用三个索引都过滤玩，然后回表查数据;</p>
<p>关闭索引下推，利用的第一个索引完成过滤，直接回表，然后继续在server层对第二三字段过滤,都是用到了三个字段，但是第二三个字段用的地方不一样</p>
<p><strong>为什么范围查找Mysql没有用索引下推优化？</strong></p>
<p>然后理论上like和大于小于都是range类型，只不过大于小于这种有点正负无穷的感觉，所以mysql没有特殊处理，like ‘xx%’ mysql默认认为范围可控，就使用刚才的逻辑来处理，当然这也不是绝对的，有时like KK% 也不一定就会走索引下推。</p>
<h2 id="39-两种排序方式"><a href="#39-两种排序方式" class="headerlink" title="39.两种排序方式"></a>39.两种排序方式</h2><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</p>
<h2 id="40-filesort排序原理"><a href="#40-filesort排序原理" class="headerlink" title="40.filesort排序原理"></a>40.filesort排序原理</h2><p><strong>Using filesort文件排序原理详解</strong></p>
<p><strong>filesort文件排序方式</strong></p>
<p>单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可</p>
<p>以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key,</p>
<p>packed_additional_fields &gt;</p>
<p>双路排序（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行</strong></p>
<p><strong>数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具</p>
<p>可以看到sort_mode信息里显示&lt; sort_key, rowid &gt;</p>
<p>MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来</p>
<h2 id="41-filesort判断使用哪种排序模式。-（单路or双路）"><a href="#41-filesort判断使用哪种排序模式。-（单路or双路）" class="headerlink" title="41.filesort判断使用哪种排序模式。 （单路or双路）"></a>41.filesort判断使用哪种排序模式。 （单路or双路）</h2><p>如果 字段的总长度小于max_length_for_sort_data ，那么使用 单路排序模式；</p>
<p>如果 字段的总长度大于max_length_for_sort_data ，那么使用 双路排序模∙式。</p>
<h2 id="40-单路排序、双路排序详细过程"><a href="#40-单路排序、双路排序详细过程" class="headerlink" title="40.单路排序、双路排序详细过程"></a>40.单路排序、双路排序详细过程</h2><p>我们先看<strong>单路排序</strong>的详细过程：</p>
<ol>
<li><p>从索引name找到第一个满足 name = ‘zhuge’ 条件的主键 id</p>
</li>
<li><p>根据主键 id 取出整行，取出所有字段的值，存入 sort_buffer 中</p>
</li>
<li><p>从索引name找到下一个满足 name = ‘zhuge’ 条件的主键 id</p>
</li>
<li><p>重复步骤 2、3 直到不满足 name = ‘zhuge’</p>
</li>
<li><p>对 sort_buffer 中的数据按照字段 position 进行排序</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<p>我们再看下<strong>双路排序</strong>的详细过程：</p>
<ol>
<li><p>从索引 name 找到第一个满足 name = ‘zhuge’ 的主键id</p>
</li>
<li><p>根据主键 id 取出整行，把排序字段 position 和主键 id 这两个字段放到 sort buffer 中</p>
</li>
<li><p>从索引 name 取下一个满足 name = ‘zhuge’ 记录的主键 id</p>
</li>
<li><p>重复 3、4 直到不满足 name = ‘zhuge’</p>
</li>
<li><p>对 sort_buffer 中的字段 position 和主键 id 按照字段 position 进行排序</p>
</li>
<li><p>遍历排序好的 id 和字段 position，按照 id 的值<strong>回到原表</strong>中取出 所有字段的值返回给客户端</p>
</li>
</ol>
<p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p>
<h2 id="41-三星索引"><a href="#41-三星索引" class="headerlink" title="41.三星索引"></a>41.三星索引</h2><p>对于一个查询而言，一个三星索引，可能是其最好的索引。</p>
<p>索引将相关的记录放到一起则获得一星；</p>
<p>如果索引中的数据顺序和查找中的排列顺序一致则获得二星；</p>
<p>如果索引中的列包含了查询中需要的全部列则获得三星。</p>
<h2 id="42-场景题"><a href="#42-场景题" class="headerlink" title="42.场景题"></a>42.场景题</h2><p>新建一张数据表user，后续所有操作都依托于初始化的这三条数据。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
</tbody></table>
<hr>
<p>操作1：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;<br>commit;</td>
</tr>
<tr>
<td>3</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
</tbody></table>
<p>此时不管是RC还是RR，t1的select都能够读取到t2update的值</p>
<p>因为在t1select的时刻才会去生成read view，根据可见性算法得出能看到最新的t2数据</p>
<hr>
<p>操作2:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>2</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;<br/>commit;</td>
</tr>
<tr>
<td>4</td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
</tbody></table>
<p>此时RC级别下，t1的 第二次select能够查看到t2update的值，因为RC级别下每次select都会生成新的read view</p>
<p>在RR级别下，t1的 第二次不能查询到t2update的值，因为RR级别下的后面查询都是使用的第一次select生成的read view</p>
<p>同理，t2语句为insert时也是一样的情况。</p>
<hr>
<p>操作3:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td></td>
<td>update user set name=’zhangsan2’ where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into user values (4,’haha’,3);<br/>waiting~~~</td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>插入成功<br>commit;</td>
</tr>
</tbody></table>
<p>RR级别下，t1进行当前读时，会对数据加锁，具体是间隙锁｜行锁｜next-key，后面细说，此时t2的插入会waiting，直到t1释提交事务，来解决insert情况下的幻读问题</p>
<hr>
<p>那么，感觉RR就已经解决了幻读，为啥还需要串行化（Serializable ）？？？</p>
<p>操作4:</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>t1</th>
<th>t2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td></td>
<td>select * from user where age=1;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>insert into user values (4,’haha’,1);<br/>commit;</td>
</tr>
<tr>
<td>5</td>
<td>update user set name=’zhangsan2’ where age=1;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>RR级别下，此时想象中的结果为下面，因为实际上在第五行如果不是update而是select，是肯定差不到新数据的</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>haha</td>
<td>1</td>
</tr>
</tbody></table>
<p>但是实际的数据库中结果为：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>lisi</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>wangwu</td>
<td>10</td>
</tr>
<tr>
<td>4</td>
<td>zhangsan2</td>
<td>1</td>
</tr>
</tbody></table>
<p>其实在 MySQL在RR级别中并不是完全解决了幻读的问题，对照操作2中t2使用insert、操作3、以及操作4可以看出某些场景下RR解决了幻读，但是MVCC 对于幻读的解决是不彻底的。（快照读和当前读的混合使用会产生幻读问题）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/">https://zhangxin66666.github.io/2022/03/31/7.mysql/面试-mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/%E9%9D%A2%E8%AF%95.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构和算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/17/11.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84-%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE%E6%96%B9%E6%B3%95%E8%AE%BA/"><img class="next-cover" src="/images/cover/%E6%96%B9%E6%B3%95%E8%AE%BA.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">业务架构-稳定性建设方法论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/" title="redolog"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">redolog</div></div></a></div><div><a href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-02</div><div class="title">mysql执行流程</div></div></a></div><div><a href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/" title="mysql三大日志"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">mysql三大日志</div></div></a></div><div><a href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" title="行页索引底层结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">行页索引底层结构</div></div></a></div><div><a href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/" title="undolog"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">undolog</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-amp-%E8%A1%8C%E6%A0%BC%E5%BC%8F-amp-%E9%A1%B5%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.索引底层结构&amp;行格式&amp;页格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E6%9D%A1-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.一条 SQL 的执行过程详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ACID%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3.ACID及实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MVCC"><span class="toc-text">4.MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="toc-text">5.mysql三大日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-redo%E6%97%A5%E5%BF%97"><span class="toc-text">6.redo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-undo%E6%97%A5%E5%BF%97"><span class="toc-text">7.undo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%83%BD%E8%AF%B4%E4%B8%8Bmyisam-%E5%92%8C-innodb%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-text">8.能说下myisam 和 innodb的区别吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%B4%E4%B8%8Bmysql%E7%9A%84%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%90%A7%EF%BC%8C%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">9.说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么，有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8"><span class="toc-text">10.什么是覆盖索引和回表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-mysql%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81%E3%80%82-%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">11.mysql的各种锁。  间隙锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-MRR"><span class="toc-text">12.MRR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">13.分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id"><span class="toc-text">14.分布式唯一id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">15.数据库三大范式是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-InnoDB%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">16.InnoDB引擎的4大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">17.索引失效的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E3%80%82-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98"><span class="toc-text">18.最左前缀原则。 联合索引使用分析实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-sql%E4%BC%98%E5%8C%96%E4%B9%8Bexplain-%E8%AF%A6%E8%A7%A3"><span class="toc-text">19.sql优化之explain 详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">20.mysql主从复制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">21.主从同步延时如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">22.隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-RC%E5%92%8CRR%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E3%80%82readview%E5%B1%82%E9%9D%A2"><span class="toc-text">23.RC和RR的本质区别。readview层面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%BB%80%E4%B9%88%E6%98%AFreadview"><span class="toc-text">24.什么是readview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">25.快照读与当前读的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%B9%BB%E8%AF%BB%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-text">26.幻读和不可重复读区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-MySQL%E5%9C%A8RR%E7%BA%A7%E5%88%AB%E4%B8%AD%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%B9%BB%E8%AF%BB%E7%9A%84%E9%97%AE%E9%A2%98%E4%B9%88%EF%BC%9F"><span class="toc-text">27.MySQL在RR级别中完全解决了幻读的问题么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E8%84%8F%E9%A1%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%88%B7%E8%84%8F%E9%A1%B5%E6%97%B6%E6%9C%BA"><span class="toc-text">28.脏页是什么，刷脏页时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-bufferpool"><span class="toc-text">29.bufferpool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E5%87%A0%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B"><span class="toc-text">30.几大核心线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-text">31.事务传播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%80%9A%E7%94%A8%E6%96%B9%E6%A1%88"><span class="toc-text">32.分布式事务通用方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">33.成本分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E8%A1%A8%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%80%BB%E9%87%8F"><span class="toc-text">34.表中数据量如何计算总量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-count-1-count-count-id-count-%E5%AD%97%E6%AE%B5-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-text">35.count(1) count(*) count(id) count(字段) 性能对比分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-mysql%E4%B8%ADin-%E5%92%8Cexists-%E5%8C%BA%E5%88%AB"><span class="toc-text">36.mysql中in 和exists 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-join%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="toc-text">37.join查询原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">38.索引下推</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">39.两种排序方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-filesort%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-text">40.filesort排序原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-filesort%E5%88%A4%E6%96%AD%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%BC%8F%E3%80%82-%EF%BC%88%E5%8D%95%E8%B7%AFor%E5%8F%8C%E8%B7%AF%EF%BC%89"><span class="toc-text">41.filesort判断使用哪种排序模式。 （单路or双路）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F%E3%80%81%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B"><span class="toc-text">40.单路排序、双路排序详细过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95"><span class="toc-text">41.三星索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">42.场景题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/" title="三种类型设计模式的特点"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三种类型设计模式的特点"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/" title="三种类型设计模式的特点">三种类型设计模式的特点</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件架构的基本原则"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则">软件架构的基本原则</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式之单例模式"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建型模式之单例模式"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式之单例模式">创建型模式之单例模式</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" title="设计模式概述"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式概述"/></a><div class="content"><a class="title" href="/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" title="设计模式概述">设计模式概述</a><time datetime="2025-01-09T16:00:00.000Z" title="发表于 2025-01-10 00:00:00">2025-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/" title="Redis-避免缓存穿透的利器之BloomFilter"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis-避免缓存穿透的利器之BloomFilter"/></a><div class="content"><a class="title" href="/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/" title="Redis-避免缓存穿透的利器之BloomFilter">Redis-避免缓存穿透的利器之BloomFilter</a><time datetime="2025-01-02T16:00:00.000Z" title="发表于 2025-01-03 00:00:00">2025-01-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>