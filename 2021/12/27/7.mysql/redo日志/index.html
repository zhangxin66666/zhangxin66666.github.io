<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redolog | 金子爸爸の家</title><meta name="keywords" content="Mysql"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="3介绍mysql redolog">
<meta property="og:type" content="article">
<meta property="og:title" content="redolog">
<meta property="og:url" content="https://zhangxin66666.github.io/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="3介绍mysql redolog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2021-12-26T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-22T03:23:14.707Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redolog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-22 11:23:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redolog</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-26T16:00:00.000Z" title="发表于 2021-12-27 00:00:00">2021-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-22T03:23:14.707Z" title="更新于 2024-08-22 11:23:14">2024-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/7-mysql/">7.mysql</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redolog"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一，什么是redo日志"><a href="#一，什么是redo日志" class="headerlink" title="一，什么是redo日志"></a>一，什么是redo日志</h1><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们的CRUD操作其实都是在访问页面。在真正访问页面之前，需要把磁盘中的页加载到内存的BufferPool，之后才能访问，但是因为事务要保持持久性，如果我们仅仅在内存的缓冲池修改了页面，假设事务提交后突然发生故障，导致内存的数据都消失了，那么这个已经提交的事务在数据库做的更改就丢失了。</p>
<p>如何保证持久性呢？可以在事务提交完成之前，把事务修改的所有页面都刷新到磁盘。不过这样做存在一些问题：</p>
<ol>
<li>刷新一个完整的数据页过于浪费</li>
<li>随机IO效率比较低</li>
</ol>
<p>事实上仅仅是为了保证事务的持久性，没有必要每次提交事务的时候就把该事务在内存修改过的全部页面刷新到磁盘，只需要把修改的内容记录一下就好，这样在事务提交的时候，就会把这个记录刷新到磁盘。即使系统因为崩溃而重启只需要按照记录的内容重新更新数据页即可恢复数据，上述记录修改的内容就叫做重做日志（redo log）。</p>
<p>相比于在事务提交的时候将所有修改过的内存中的页面刷新到磁盘，重做日志有以下好处：</p>
<ol>
<li>redo日志占用空间小：在存储表空间ID，页号，偏移量以及需要更新的值时，需要的存储空间很小。</li>
<li>redo日志是顺序写入磁盘的：在执行事务过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li>
</ol>
<h1 id="二，redo日志格式"><a href="#二，redo日志格式" class="headerlink" title="二，redo日志格式"></a>二，redo日志格式</h1><p>重做日志本质上仅仅是记录了一下事务对数据库进行了哪些修改。针对事务对数据库的不同修改场景MySQL定义了很多种重做日志，但是大部分类型的重做日志都有以下的通用结构。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/6tRQtF.png" alt="img"></p>
<table>
<thead>
<tr>
<th>type</th>
<th>重做日志的类型</th>
</tr>
</thead>
<tbody><tr>
<td>space ID</td>
<td>表空间ID</td>
</tr>
<tr>
<td>page number</td>
<td>页号</td>
</tr>
<tr>
<td>Data</td>
<td>日志的具体内容</td>
</tr>
</tbody></table>
<h2 id="1-简单的redo日志类型"><a href="#1-简单的redo日志类型" class="headerlink" title="1. 简单的redo日志类型"></a>1. 简单的redo日志类型</h2><p>行格式里面有一个隐藏列叫做row_id。为row_id进行赋值的方式如下：</p>
<ol>
<li>服务器会在内存中维护一个全局变量，每当像某个包含row_id隐藏列的表插入一条记录的时候，就会把这个全局变量的值当做新记录row_id的值，并且把这个全局变量自增1。</li>
<li>每当这个全局变量的值是256的整数倍的时候，就会把这个变量的值刷新到系统表空间页号为7的页面中一个叫做Max Row ID的属性中。</li>
<li>当系统启动的时候，会将Max Row ID属性加载到内存，并把这个值加上256之后赋值给前面提到的全局变量。</li>
</ol>
<p>这个Max Row ID占用的存储空间是8字节。当某个事务向某个包含row_id的表插入一条记录并且该记录分配的row_id值为256的整数倍的时候，就会像系统表空间页号为7的页面的相应偏移量处写入8字节的值。但是这个写入操作实际上是在内存缓冲区完成的，我们需要把这次修改以redo日志的形式记录下来，这样在事务提交之后，即使系统崩溃，也可以将该页面恢复成崩溃前的状态。在这种对页面的修改特别简单的时候，重做日志仅仅需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体修改后的内容是什么就可以了。这也叫做物理日志。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/Mpyn2l.png" alt="img"></p>
<p>offset表示页面中的偏移量。如果写入的是字节序列类型的重做日志，还需要有一个len属性记录实际写入的长度。</p>
<h2 id="2-复杂的redo日志类型"><a href="#2-复杂的redo日志类型" class="headerlink" title="2.复杂的redo日志类型"></a>2.复杂的redo日志类型</h2><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）</p>
<p>这时我们如果使用简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p>
<ul>
<li><p>方案一：在每个修改的地方都记录一条<code>redo</code>日志。<br>也就是有多少个修改的记录，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多。 </p>
</li>
<li><p>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。<br><code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中太浪费了。 </p>
</li>
</ul>
<p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，<code>InnoDB</code>提出了一些新的<code>redo</code>日志类型。</p>
<p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p>
<ul>
<li><p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</p>
</li>
<li><p>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</p>
</li>
</ul>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/xzCFc2.jpeg" alt="img"></p>
<p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了什么，<code>PAGE_HEAP_TOP</code>的值修改为了什么，<code>PAGE_N_HEAP</code>的值修改为了什么等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p>
<p>日志格式说了一堆核心其实就是：<strong>重做日志会把事务执行过程中对数据库所做的所有修改都记录下来，在之后系统因为崩溃而重启后可以把事务所做的任何修改都恢复过来。</strong> </p>
<p>为了节省重做日志占用的空间大小，InnoDB还对重做日志中的某些数据进行了压缩处理，比如表空间ID&amp;page number 一般占用4字节来存储，但是经过压缩之后占用的空间就更小了。</p>
<h1 id="三，Mini-Transcation"><a href="#三，Mini-Transcation" class="headerlink" title="三，Mini-Transcation"></a>三，Mini-Transcation</h1><h2 id="1-以组的形式写入redo日志"><a href="#1-以组的形式写入redo日志" class="headerlink" title="1.以组的形式写入redo日志"></a>1.以组的形式写入redo日志</h2><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被<code>InnoDB</code>人为的划分成了若干个不可分割的组，比如：</p>
<ul>
<li><p>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li><p>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li><p>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li><p>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</p>
</li>
</ul>
<p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p>
<ul>
<li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/CghxTC.png" alt="img"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/89BUTu.png" alt="img"> </p>
</li>
<li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/S3ify8.png" alt="img"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/TRO5IS.png" alt="img"><br>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表等，我们在介绍表空间那一篇中介绍过的各种东西)，反正总共需要记录的<code>redo</code>日志有二、三十条。 </p>
</li>
</ul>
<p>其实不光是悲观插入一条记录会生成许多条redo日志，InnoDB为了其他的一些功能，在乐观插入时也可能产生多条redo日志。</p>
<p><code>InnoDB</code>认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统崩溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是<code>InnoDB</code>所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统崩溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p>
<ul>
<li><p>有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。<br>如何把这些<code>redo</code>日志划分到一个组里边儿呢？<code>InnoDB</code>做了一个很简单的操作，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/xN2THQ.png" alt="img"><br>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/TZs2x6.png" alt="img"><br>这样在系统崩溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。 </p>
</li>
<li><p>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。<br>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，<code>InnoDB</code>不想浪费一个比特位。虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/x6uXSv.png" alt="img"><br>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。 </p>
</li>
</ul>
<h2 id="2-Mini-Transaction"><a href="#2-Mini-Transaction" class="headerlink" title="2.Mini-Transaction"></a>2.Mini-Transaction</h2><p><code>MySQL</code>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ELTRk2.png" alt="img"></p>
<h1 id="四，redo日志的写入过程"><a href="#四，redo日志的写入过程" class="headerlink" title="四，redo日志的写入过程"></a>四，redo日志的写入过程</h1><h2 id="1-redo-log-block"><a href="#1-redo-log-block" class="headerlink" title="1.redo log block"></a>1.redo log block</h2><p><code>InnoDB</code>为了更好的进行系统崩溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>。一个<code>redo log block</code>的示意图如下：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/0VAC8Y.png" alt="img"></p>
<p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZSpuiJ.png" alt="img"></p>
<p>其中<code>log block header</code>的几个属性的意思分别如下：</p>
<ul>
<li><p><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</p>
</li>
<li><p><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</p>
</li>
<li><p><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</p>
</li>
<li><p><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</p>
</li>
</ul>
<p><code>log block trailer</code>中属性的意思如下：</p>
<ul>
<li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li>
</ul>
<h2 id="2-redo-日志缓冲区"><a href="#2-redo-日志缓冲区" class="headerlink" title="2.redo 日志缓冲区"></a>2.redo 日志缓冲区</h2><p><code>InnoDB</code>为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/902AmQ.png" alt="img"></p>
<p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p>
<h2 id="3-redo-log-日志写入log-buffer"><a href="#3-redo-log-日志写入log-buffer" class="headerlink" title="3.redo log 日志写入log buffer"></a>3.redo log 日志写入log buffer</h2><p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/PRG2NZ.png" alt="img"></p>
<p>一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p>
<ul>
<li><p>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</p>
</li>
<li><p>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</p>
</li>
</ul>
<p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/tKw7Ja.png" alt="img"></p>
<p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p>
<h1 id="五，redo-日志文件"><a href="#五，redo-日志文件" class="headerlink" title="五，redo 日志文件"></a>五，redo 日志文件</h1><h2 id="1-redo日志刷盘时机"><a href="#1-redo日志刷盘时机" class="headerlink" title="1.redo日志刷盘时机"></a>1.redo日志刷盘时机</h2><p>mtr<code>运行过程中产生的一组</code>redo<code>日志在</code>mtr<code>结束时会被复制到</code>log buffer`中，在一些情况下它们会被刷新到磁盘里，比如：</p>
<ul>
<li><p><code>log buffer</code>空间不足时<br><code>log buffer</code>的大小是有限的（通过系统变量<code>innodb_log_buffer_size</code>指定），如果不停的往这个有限大小的<code>log buffer</code>里塞入日志，很快它就会被填满。<code>InnoDB</code>认为如果当前写入<code>log buffer</code>的<code>redo</code>日志量已经占满了<code>log buffer</code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。 </p>
</li>
<li><p>事务提交时<br>之所以使用<code>redo</code>日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的<code>Buffer Pool</code>页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的<code>redo</code>日志刷新到磁盘。 </p>
</li>
<li><p> 将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次 强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。 </p>
</li>
<li><p>后台线程不停的刷<br>后台有一个线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo</code>日志到磁盘。 </p>
</li>
<li><p> 正常关闭服务器时 </p>
</li>
<li><p> 做所谓的<code>checkpoint</code>时 </p>
</li>
<li><p> 其他的一些情况… </p>
</li>
</ul>
<h2 id="2-redo日志文件组"><a href="#2-redo日志文件组" class="headerlink" title="2.redo日志文件组"></a>2.redo日志文件组</h2><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<code>log buffer</code>中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的<code>redo</code>日志文件不满意，可以通过下边几个启动参数来调节：</p>
<ul>
<li><p><code>innodb_log_group_home_dir</code><br>该参数指定了<code>redo</code>日志文件所在的目录，默认值就是当前的数据目录。 </p>
</li>
<li><p><code>innodb_log_file_size</code><br>该参数指定了每个<code>redo</code>日志文件的大小，在<code>MySQL 5.7.21</code>这个版本中的默认值为<code>48MB</code>， </p>
</li>
<li><p><code>innodb_log_files_in_group</code><br>该参数指定<code>redo</code>日志文件的个数，默认值为2，最大值为100。 </p>
</li>
</ul>
<p>磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2</code>…）的形式进行命名。在将<code>redo</code>日志写入<code>日志文件组</code>时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/7AHjCL.png" alt="img"></p>
<p>总共的<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p>
<p>如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志？当然可能了！所以InnoDB提出了checkpoint的概念。</p>
<h2 id="3-redo日志文件格式"><a href="#3-redo日志文件格式" class="headerlink" title="3.redo日志文件格式"></a>3.redo日志文件格式</h2><p><code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个<code>512</code>字节大小的<code>block</code>。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的block组成。</p>
<p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p>
<ul>
<li><p>前2048个字节，也就是前4个block是用来存储一些管理信息的。</p>
</li>
<li><p>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</p>
</li>
</ul>
<p>所以我们前边所说的<code>循环</code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/EIZbn0.png" alt="img"></p>
<p>普通block的格式我们在了解<code>log buffer</code>的时候都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分。这里需要介绍一下每个<code>redo</code>日志文件前2048个字节，也就是前4个特殊block的格式都是什么作用。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZlTsiQ.png" alt="img"><br>从图中可以看出来，这4个block分别是：</p>
<ul>
<li><code>log file header</code>：描述该<code>redo</code>日志文件的一些整体属性<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/EfCLpt.jpeg" alt="img"><br>各个属性的具体释义如下：  </li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>长度（单位：字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LOG_HEADER_FORMAT</code></td>
<td><code>4</code></td>
<td><code>redo</code>日志的版本，在<code>MySQL 5.7.21</code>中该值永远为1</td>
</tr>
<tr>
<td><code>LOG_HEADER_PAD1</code></td>
<td><code>4</code></td>
<td>做字节填充用的，没什么实际意义，忽略～</td>
</tr>
<tr>
<td><code>LOG_HEADER_START_LSN</code></td>
<td><code>8</code></td>
<td>标记本<code>redo</code>日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值。</td>
</tr>
<tr>
<td><code>LOG_HEADER_CREATOR</code></td>
<td><code>32</code></td>
<td>一个字符串，标记本<code>redo</code>日志文件的创建者是谁。正常运行时该值为<code>MySQL</code>的版本号，比如：<code>&quot;MySQL 5.7.21&quot;</code>，使用<code>mysqlbackup</code>命令创建的<code>redo</code>日志文件的该值为<code>&quot;ibbackup&quot;</code>和创建时间。</td>
</tr>
<tr>
<td><code>LOG_BLOCK_CHECKSUM</code></td>
<td><code>4</code></td>
<td>本block的校验值，所有block都有，我们不关心</td>
</tr>
</tbody></table>
<ul>
<li><code>checkpoint1</code>：记录关于<code>checkpoint</code>的一些属性，看一下它的结构：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/quxD7L.jpeg" alt="img"><br>各个属性的具体释义如下：  </li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>长度（单位：字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>LOG_CHECKPOINT_NO</code></td>
<td><code>8</code></td>
<td>服务器做<code>checkpoint</code>的编号，每做一次<code>checkpoint</code>，该值就加1。</td>
</tr>
<tr>
<td><code>LOG_CHECKPOINT_LSN</code></td>
<td><code>8</code></td>
<td>服务器做<code>checkpoint</code>结束时对应的<code>LSN</code>值，系统崩溃恢复时将从该值开始。</td>
</tr>
<tr>
<td><code>LOG_CHECKPOINT_OFFSET</code></td>
<td><code>8</code></td>
<td>上个属性中的<code>LSN</code>值在<code>redo</code>日志文件组中的偏移量</td>
</tr>
<tr>
<td><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code></td>
<td><code>8</code></td>
<td>服务器在做<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</td>
</tr>
<tr>
<td><code>LOG_BLOCK_CHECKSUM</code></td>
<td><code>4</code></td>
<td>本block的校验值，所有block都有，我们不关心</td>
</tr>
</tbody></table>
<ul>
<li><p> 第三个block未使用，忽略 </p>
</li>
<li><p> <code>checkpoint2</code>：结构和<code>checkpoint1</code>一样。 </p>
</li>
</ul>
<h1 id="六，Log-Sequence-Number"><a href="#六，Log-Sequence-Number" class="headerlink" title="六，Log Sequence Number"></a>六，Log Sequence Number</h1><p>自系统开始运行，就不断的在修改页面，也就意味着会不断的生成<code>redo</code>日志。<code>redo</code>日志的量在不断的递增。<code>InnoDB</code>为记录已经写入的<code>redo</code>日志量，设计了一个称之为<code>Log Sequence Number</code>的全局变量，翻译过来就是：<code>日志序列号</code>，简称<code>lsn</code>。<code>InnoDB</code>规定初始的<code>lsn</code>值为<code>8704</code>（也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值为<code>8704</code>）。</p>
<p>在向<code>log buffer</code>中写入<code>redo</code>日志时不是一条一条写入的，而是以一个<code>mtr</code>生成的一组<code>redo</code>日志为单位进行写入的。而且实际上是把日志内容写在了<code>log block body</code>处。但是在统计<code>lsn</code>的增长量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子：</p>
<ul>
<li><p>系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>（就是标记下一条<code>redo</code>日志应该写入到<code>log buffer</code>的位置的变量）就会指向第一个<code>block</code>的偏移量为12字节（<code>log block header</code>的大小）的地方，那么<code>lsn</code>值也会跟着增加12：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/DugAF2.png" alt="img"> </p>
</li>
<li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/SQQJDG.png" alt="img"><br>我们假设上图中<code>mtr_1</code>产生的<code>redo</code>日志量为200字节，那么<code>lsn</code>就要在<code>8716</code>的基础上增加<code>200</code>，变为<code>8916</code>。 </p>
</li>
<li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/uIAzpF.png" alt="img"><br>我们假设上图中<code>mtr_2</code>产生的<code>redo</code>日志量为1000字节，为了将<code>mtr_2</code>产生的<code>redo</code>日志写入<code>log buffer</code>，我们不得不额外多分配两个block，所以<code>lsn</code>的值需要在<code>8916</code>的基础上增加<code>1000 + 12×2 + 4 × 2 = 1032</code>。 </p>
</li>
</ul>
<p>从上边的描述中可以看出来，每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p>
<h2 id="1-flushed-to-disk-lsn"><a href="#1-flushed-to-disk-lsn" class="headerlink" title="1.flushed_to_disk_lsn"></a>1.flushed_to_disk_lsn</h2><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。所以<code>InnoDB</code>提出了一个称之为<code>buf_next_to_write</code>的全局变量，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/YRg7uh.png" alt="img"></p>
<p><code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，<code>InnoDB</code>提出了一个表示刷新到磁盘中的<code>redo</code>日志量的全局变量，称之为<code>flushed_to_disk_lsn</code>。系统第一次启动时，该变量的值和初始的<code>lsn</code>值是相同的，都是<code>8704</code>。随着系统的运行，<code>redo</code>日志被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值就和<code>flushed_to_disk_lsn</code>的值拉开了差距。我们推理一下：</p>
<ul>
<li><p> 系统第一次启动后，向<code>log buffer</code>中写入了<code>mtr_1</code>、<code>mtr_2</code>、<code>mtr_3</code>这三个<code>mtr</code>产生的<code>redo</code>日志，假设这三个<code>mtr</code>开始和结束时对应的lsn值分别是： </p>
</li>
<li><ul>
<li><code>mtr_1</code>：8716 ～ 8916</li>
</ul>
</li>
<li><ul>
<li><code>mtr_2</code>：8916 ～ 9948</li>
</ul>
</li>
<li><ul>
<li><code>mtr_3</code>：9948 ～ 10000</li>
</ul>
</li>
</ul>
<p>此时的<code>lsn</code>已经增长到了10000，但是由于没有刷新操作，所以此时<code>flushed_to_disk_lsn</code>的值仍为<code>8704</code>，如图：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/C04p7l.png" alt="img"></p>
<ul>
<li>随后进行将<code>log buffer</code>中的block刷新到<code>redo</code>日志文件的操作，假设将<code>mtr_1</code>和<code>mtr_2</code>的日志刷新到磁盘，那么<code>flushed_to_disk_lsn</code>就应该增长<code>mtr_1</code>和<code>mtr_2</code>写入的日志量，所以<code>flushed_to_disk_lsn</code>的值增长到了<code>9948</code>，如图：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZonfyU.png" alt="img"> </li>
</ul>
<p>综上所述，当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p>
<p>应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的<code>fsync</code>函数。其实只有当系统执行了<code>fsync</code>函数后，<code>flushed_to_disk_lsn</code>的值才会跟着增长，当仅仅把<code>log buffer</code>中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为<code>write_lsn</code>的值跟着增长。</p>
<h2 id="2-lsn值和redo日志文件偏移量的对应关系"><a href="#2-lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="2.lsn值和redo日志文件偏移量的对应关系"></a>2.lsn值和redo日志文件偏移量的对应关系</h2><p>因为<code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（当然有时候要加上<code>log block header</code>和<code>log block trailer</code>的大小），这样<code>mtr</code>产生的日志写到磁盘中时，很容易计算某一个<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量，如图：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/AeVfio.png" alt="img"></p>
<p>初始时的<code>LSN</code>值是<code>8704</code>，对应文件偏移量<code>2048</code>，之后每个<code>mtr</code>向磁盘中写入多少字节日志，<code>lsn</code>的值就增长多少。</p>
<h2 id="3-flush链表中的LSN"><a href="#3-flush链表中的LSN" class="headerlink" title="3.flush链表中的LSN"></a>3.flush链表中的LSN</h2><p>一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p>
<p>当第一次修改某个缓存在<code>Buffer Pool</code>中的页面时，就会把这个页面对应的控制块插入到<code>flush链表</code>的头部，之后再修改该页面时由于它已经在<code>flush</code>链表中了，就不再次插入了。也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p>
<ul>
<li><p><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</p>
</li>
<li><p><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</p>
</li>
</ul>
<p>接着上边<code>flushed_to_disk_lsn</code>的例子看一下：</p>
<ul>
<li><p>假设<code>mtr_1</code>执行过程中修改了<code>页a</code>，那么在<code>mtr_1</code>执行结束时，就会将<code>页a</code>对应的控制块加入到<code>flush链表</code>的头部。并且将<code>mtr_1</code>开始时对应的<code>lsn</code>，也就是<code>8716</code>写入<code>页a</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_1</code>结束时对应的<code>lsn</code>，也就是8916写入<code>页a</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下（<code>oldest_modification</code>缩写成了<code>o_m</code>，<code>newest_modification</code>缩写成了<code>n_m</code>）：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/PVhnzR.png" alt="img"> </p>
</li>
<li><p>接着假设<code>mtr_2</code>执行过程中又修改了<code>页b</code>和<code>页c</code>两个页面，那么在<code>mtr_2</code>执行结束时，就会将<code>页b</code>和<code>页c</code>对应的控制块都加入到<code>flush链表</code>的头部。并且将<code>mtr_2</code>开始时对应的<code>lsn</code>，也就是8916写入<code>页b</code>和<code>页c</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_2</code>结束时对应的<code>lsn</code>，也就是9948写入<code>页b</code>和<code>页c</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/tm7l11.png" alt="img"><br>从图中可以看出来，每次新插入到<code>flush链表</code>中的节点都是被放在了头部，也就是说<code>flush链表</code>中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早。 </p>
</li>
<li><p>接着假设<code>mtr_3</code>执行过程中修改了<code>页b</code>和<code>页d</code>，不过<code>页b</code>之前已经被修改过了，所以它对应的控制块已经被插入到了<code>flush</code>链表，所以在<code>mtr_3</code>执行结束时，只需要将<code>页d</code>对应的控制块都加入到<code>flush链表</code>的头部即可。所以需要将<code>mtr_3</code>开始时对应的<code>lsn</code>，也就是9948写入<code>页d</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_3</code>结束时对应的<code>lsn</code>，也就是10000写入<code>页d</code>对应的控制块的<code>newest_modification</code>属性中。另外，由于<code>页b</code>在<code>mtr_3</code>执行过程中又发生了一次修改，所以需要更新<code>页b</code>对应的控制块中<code>newest_modification</code>的值为10000。画个图表示一下：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/ZPeEx4.png" alt="img"> </p>
</li>
</ul>
<p>总结一下上边说的，就是：<strong>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</strong></p>
<h1 id="七，checkpoint"><a href="#七，checkpoint" class="headerlink" title="七，checkpoint"></a>七，checkpoint</h1><p><code>redo</code>日志文件组容量是有限的，我们不得不选择循环使用<code>redo</code>日志文件组中的文件，但是这会造成最后写的<code>redo</code>日志与最开始写的<code>redo</code>日志<code>追尾</code>，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。我们看一下前边的那个例子：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/q7pck5.png" alt="img"></p>
<p>如图，虽然<code>mtr_1</code>和<code>mtr_2</code>生成的<code>redo</code>日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在<code>Buffer Pool</code>中，所以它们生成的<code>redo</code>日志在磁盘上的空间是不可以被覆盖的。之后随着系统的运行，如果<code>页a</code>被刷新到了磁盘，那么它对应的控制块就会从<code>flush链表</code>中移除，就像这样子：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/H77nNy.png" alt="img"></p>
<p>这样<code>mtr_1</code>生成的<code>redo</code>日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。<code>InnoDB</code>提出了一个全局变量<code>checkpoint_lsn</code>来代表当前系统中可以被覆盖的<code>redo</code>日志总量是多少，这个变量初始值也是<code>8704</code>。</p>
<p>比方说现在<code>页a</code>被刷新到了磁盘，<code>mtr_1</code>生成的<code>redo</code>日志就可以被覆盖了，所以我们可以进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称之为做一次<code>checkpoint</code>。做一次<code>checkpoint</code>其实可以分为两个步骤：</p>
<ul>
<li><p>步骤一：计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。<br><code>redo</code>日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的<code>oldest_modification</code>值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的<code>oldest_modification</code>赋值给<code>checkpoint_lsn</code>。<br>比方说当前系统中<code>页a</code>已经被刷新到磁盘，那么<code>flush链表</code>的尾节点就是<code>页c</code>，该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code>值为8916，我们就把8916赋值给<code>checkpoint_lsn</code>（也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉）。 </p>
</li>
<li><p>步骤二：将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。<br><code>InnoDB</code>维护了一个目前系统做了多少次<code>checkpoint</code>的变量<code>checkpoint_no</code>，每做一次<code>checkpoint</code>，该变量的值就加1。我们前边说过计算一个<code>lsn</code>值对应的<code>redo</code>日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code>在<code>redo</code>日志文件组中对应的偏移量<code>checkpoint_offset</code>，然后把这三个值都写到<code>redo</code>日志文件组的管理信息中。<br>我们说过，每一个<code>redo</code>日志文件都有<code>2048</code>个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。不过我们是存储到<code>checkpoint1</code>中还是<code>checkpoint2</code>中呢？<code>InnoDB</code>规定，当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中。 </p>
</li>
</ul>
<p>记录完<code>checkpoint</code>的信息之后，<code>redo</code>日志文件组中各个<code>lsn</code>值的关系就像这样：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/IvyqOs.png" alt="img"></p>
<h2 id="1-批量从flush链表中刷出脏页"><a href="#1-批量从flush链表中刷出脏页" class="headerlink" title="1.批量从flush链表中刷出脏页"></a>1.批量从flush链表中刷出脏页</h2><p>一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统<code>lsn</code>值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘，这样这些脏页对应的<code>redo</code>日志就没用了，然后就可以去做<code>checkpoint</code>了。</p>
<h2 id="2-查看系统中的各种LSN值"><a href="#2-查看系统中的各种LSN值" class="headerlink" title="2.查看系统中的各种LSN值"></a>2.查看系统中的各种LSN值</h2><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前<code>InnoDB</code>存储引擎中的各种<code>LSN</code>值的情况，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to   124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at  124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">24 log i/o&#x27;s done, 2.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><code>Log sequence number</code>：代表系统中的<code>lsn</code>值，也就是当前系统已经写入的<code>redo</code>日志量，包括写入<code>log buffer</code>中的日志。</p>
</li>
<li><p><code>Log flushed up to</code>：代表<code>flushed_to_disk_lsn</code>的值，也就是当前系统已经写入磁盘的<code>redo</code>日志量。</p>
</li>
<li><p><code>Pages flushed up to</code>：代表<code>flush链表</code>中被最早修改的那个页面对应的<code>oldest_modification</code>属性值。</p>
</li>
<li><p><code>Last checkpoint at</code>：当前系统的<code>checkpoint_lsn</code>值。</p>
</li>
</ul>
<h2 id="3-innodb-flush-log-at-trx-commit的用法"><a href="#3-innodb-flush-log-at-trx-commit的用法" class="headerlink" title="3.innodb_flush_log_at_trx_commit的用法"></a>3.innodb_flush_log_at_trx_commit的用法</h2><p>为了保证事务的<code>持久性</code>，用户线程在事务提交时需要将该事务执行过程中产生的所有<code>redo</code>日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。如果对事务的<code>持久性</code>要求不是那么强烈的话，可以选择修改一个称为<code>innodb_flush_log_at_trx_commit</code>的系统变量的值，该变量有3个可选的值：</p>
<ul>
<li><p><code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志，这个任务是交给后台线程做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将<code>redo</code>日志刷新到磁盘，那么该事务对页面的修改会丢失。 </p>
</li>
<li><p> <code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘，可以保证事务的<code>持久性</code>。<code>1</code>也是<code>innodb_flush_log_at_trx_commit</code>的默认值。 </p>
</li>
<li><p><code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了。 </p>
</li>
</ul>
<h1 id="八，崩溃恢复"><a href="#八，崩溃恢复" class="headerlink" title="八，崩溃恢复"></a>八，崩溃恢复</h1><p>在服务器不挂的情况下，<code>redo</code>日志不仅没用，反而让性能变得更差。但是万一数据库挂了，我们就可以在重启时根据<code>redo</code>日志中的记录就可以将页面恢复到系统崩溃前的状态。我们接下来大致看一下恢复过程。</p>
<h2 id="1-确定恢复的起点"><a href="#1-确定恢复的起点" class="headerlink" title="1.确定恢复的起点"></a>1.确定恢复的起点</h2><p><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖，也就是说这些<code>redo</code>日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于<code>checkpoint_lsn</code>之后的<code>redo</code>日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从<code>checkpoint_lsn</code>开始读取<code>redo</code>日志来恢复页面。</p>
<p>当然，<code>redo</code>日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code>的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量<code>checkpoint</code>发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，只要把<code>checkpoint1</code>和<code>checkpoint2</code>这两个block中的<code>checkpoint_no</code>值读出来比一下大小，哪个的<code>checkpoint_no</code>值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code>信息。这样我们就能拿到最近发生的<code>checkpoint</code>对应的<code>checkpoint_lsn</code>值以及它在<code>redo</code>日志文件组中的偏移量<code>checkpoint_offset</code>。</p>
<h2 id="2-确定恢复的终点"><a href="#2-确定恢复的终点" class="headerlink" title="2.确定恢复的终点"></a>2.确定恢复的终点</h2><p><code>redo</code>日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。在写<code>redo</code>日志的时候都是顺序写的，写满了一个block之后会再往下一个block中写。</p>
<p>普通block的<code>log block header</code>部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为<code>512</code>。如果该属性的值不为<code>512</code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p>
<h2 id="3-怎么恢复"><a href="#3-怎么恢复" class="headerlink" title="3.怎么恢复"></a>3.怎么恢复</h2><p>确定了需要扫描哪些<code>redo</code>日志进行崩溃恢复之后，接下来就是怎么进行恢复了。假设现在的<code>redo</code>日志文件中有5条<code>redo</code>日志，如图：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/zlN5rd.png" alt="img"></p>
<p>由于<code>redo 0</code>在<code>checkpoint_lsn</code>后前边，恢复时可以不管它。现在可以按照<code>redo</code>日志的顺序依次扫描<code>checkpoint_lsn</code>之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过<code>InnoDB</code>还是想了一些办法加快这个恢复的过程：</p>
<ul>
<li><p>使用哈希表<br>根据<code>redo</code>日志的<code>space ID</code>和<code>page number</code>属性计算出散列值，把<code>space ID</code>和<code>page number</code>相同的<code>redo</code>日志放到哈希表的同一个槽里，如果有多个<code>space ID</code>和<code>page number</code>都相同的<code>redo</code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：<br><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/LG7sGs.png" alt="img"><br>之后就可以遍历哈希表，因为对同一个页面进行修改的<code>redo</code>日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO)，这样可以加快恢复速度。另外需要注意一点的是，同一个页面的<code>redo</code>日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复，如果不按照生成时间顺序进行排序的话，那么可能出现错误。比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。 </p>
</li>
<li><p>跳过已经刷新到磁盘的页面<br><code>checkpoint_lsn</code>之前的<code>redo</code>日志对应的脏页确定都已经刷到磁盘了，但是<code>checkpoint_lsn</code>之后的<code>redo</code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次<code>checkpoint</code>后，可能后台线程又不断的从<code>LRU链表</code>和<code>flush链表</code>中将一些脏页刷出<code>Buffer Pool</code>。这些在<code>checkpoint_lsn</code>之后的<code>redo</code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据<code>redo</code>日志的内容修改该页面了。<br>那在恢复时怎么知道某个<code>redo</code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，每个页面都有一个称之为<code>File Header</code>的部分，在<code>File Header</code>里有一个称之为<code>FIL_PAGE_LSN</code>的属性，该属性记载了最近一次修改页面时对应的<code>lsn</code>值（其实就是页面控制块中的<code>newest_modification</code>值）。如果在做了某次<code>checkpoint</code>之后有脏页被刷新到磁盘中，那么该页对应的<code>FIL_PAGE_LSN</code>代表的<code>lsn</code>值肯定大于<code>checkpoint_lsn</code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于<code>FIL_PAGE_LSN</code>的redo日志了，所以更进一步提升了崩溃恢复的速度。 </p>
</li>
</ul>
<h1 id="九，LOG-BLOCK-HDR-NO是如何计算的"><a href="#九，LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="九，LOG_BLOCK_HDR_NO是如何计算的"></a>九，LOG_BLOCK_HDR_NO是如何计算的</h1><p>对于实际存储<code>redo</code>日志的普通的<code>log block</code>来说，在<code>log block header</code>处有一个称之为<code>LOG_BLOCK_HDR_NO</code>的属性，我们说这个属性代表一个唯一的标号。这个属性是初次使用该block时分配的，跟当时的系统<code>lsn</code>值有关。使用下边的公式计算该block的<code>LOG_BLOCK_HDR_NO</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/hYGejv.png" alt="img"></p>
<p>从图中可以看出，<code>0x3FFFFFFFUL</code>对应的二进制数的前2位为0，后30位的值都为<code>1</code>。一个二进制位与0做与运算（<code>&amp;</code>）的结果肯定是0，一个二进制位与1做与运算（<code>&amp;</code>）的结果就是原值。让一个数和<code>0x3FFFFFFFUL</code>做与运算的意思就是要将该值的前2个比特位的值置为0，这样该值就肯定小于或等于<code>0x3FFFFFFFUL</code>了。这也就说明了，不论lsn多大，<code>((lsn / 512) &amp; 0x3FFFFFFFUL)</code>的值肯定在<code>0``0x3FFFFFFFUL</code>之间，再加1的话肯定在<code>1``0x40000000UL</code>之间。而<code>0x40000000UL</code>这个值就代表着<code>1GB</code>。也就是说系统最多能产生不重复的<code>LOG_BLOCK_HDR_NO</code>值只有<code>1GB</code>个。InnoDB规定<code>redo</code>日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。</p>
<p>另外，<code>LOG_BLOCK_HDR_NO</code>值的第一个比特位比较特殊，称之为<code>flush bit</code>，如果该值为1，代表着本block是在某次将<code>log buffer</code>中的block刷新到磁盘的操作中的第一个被刷入的block。</p>
<h1 id="十，double-write"><a href="#十，double-write" class="headerlink" title="十，double write"></a>十，double write</h1><h2 id="1-脏页刷盘风险"><a href="#1-脏页刷盘风险" class="headerlink" title="1.脏页刷盘风险"></a>1.脏页刷盘风险</h2><p>关于IO的最小单位：</p>
<ol>
<li><p>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</p>
</li>
<li><p>文件系统IO的最小单位是4K（也有1K的）</p>
</li>
<li><p>磁盘IO的最小单位是512字节</p>
</li>
</ol>
<p>因此，存在IO写入导致page损坏的风险：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/8BiaPu.png" alt="img"> </p>
<h2 id="2-doublewrite：两次写"><a href="#2-doublewrite：两次写" class="headerlink" title="2.doublewrite：两次写"></a>2.doublewrite：两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>
<h3 id="2-1-Double-write解决了什么问题"><a href="#2-1-Double-write解决了什么问题" class="headerlink" title="2.1 Double write解决了什么问题"></a>2.1 Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>
<h3 id="2-2使用情景"><a href="#2-2使用情景" class="headerlink" title="2.2使用情景"></a>2.2使用情景</h3><p>当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p>
<h3 id="2-3-double-write工作流程"><a href="#2-3-double-write工作流程" class="headerlink" title="2.3 double write工作流程"></a>2.3 double write工作流程</h3><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202201/13/13kGkt.png" alt="img"></p>
<p>doublewrite由两部分组成，一部分为内存中的<code>doublewrite buffer</code>，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>
<ol>
<li><ol>
<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的<code>doublewrite buffer</code>中；</li>
<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>
</ol>
</li>
<li><ol>
<li>待第二步完成后，再将<code>doublewrite buffer</code>中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li>
</ol>
</li>
</ol>
<h3 id="2-4-doublewrite的崩溃恢复"><a href="#2-4-doublewrite的崩溃恢复" class="headerlink" title="2.4 doublewrite的崩溃恢复"></a>2.4 doublewrite的崩溃恢复</h3><p>如果操作系统在将页写入磁盘的过程中发生崩溃，在恢复过程中，<code>innodb</code>存储引擎可以从共享表空间的<code>doublewrite</code>中找到该页的一个最近的副本，将其复制到表空间文件，再应用<code>redo log</code>，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p>
<p><em>Q：为什么</em><code>*log write*</code><em>不需要</em><code>*doublewrite*</code><em>的支持？</em></p>
<p><em>A：因为</em><code>*redolog*</code><em>写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。</em></p>
<h2 id="3-doublewrite的副作用"><a href="#3-doublewrite的副作用" class="headerlink" title="3.doublewrite的副作用"></a>3.doublewrite的副作用</h2><h3 id="3-1-double-write带来的写负载"><a href="#3-1-double-write带来的写负载" class="headerlink" title="3.1 double write带来的写负载"></a>3.1 double write带来的写负载</h3><ol>
<li>double write是一个buffer, 但其实它是开在物理文件上的一个buffer, 其实也就是file, 所以它会导致系统有更多的fsync操作, 而硬盘的fsync性能是很慢的, 所以它会降低mysql的整体性能。</li>
<li>但是，doublewrite buffer写入磁盘共享表空间这个过程是连续存储，是顺序写，性能非常高，(约占写的10%)，牺牲一点写性能来保证数据页的完整还是很有必要的。</li>
</ol>
<h3 id="3-2-监控double-write工作负载"><a href="#3-2-监控double-write工作负载" class="headerlink" title="3.2 监控double write工作负载"></a>3.2 监控double write工作负载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">&#x27;%dblwr%&#x27;</span>;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Innodb_dblwr_pages_written | <span class="number">7</span>     |</span><br><span class="line">| Innodb_dblwr_writes        | <span class="number">3</span>     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>关注点：Innodb_dblwr_pages_written / Innodb_dblwr_writes</p>
<p>开启doublewrite后，每次脏页刷新必须要先写doublewrite，而doublewrite存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。</p>
<p>而根据以上系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，大概在3左右，远远还没到64(如果约等于64，那么说明系统的写压力非常大，有大量的脏页要往磁盘上写)，所以从这个角度也可以看出，系统写入压力并不高。</p>
<h3 id="3-3-关闭double-write适合的场景"><a href="#3-3-关闭double-write适合的场景" class="headerlink" title="3.3 关闭double write适合的场景"></a>3.3 关闭double write适合的场景</h3><ol>
<li><p>海量DML</p>
</li>
<li><p>不惧怕数据损坏和丢失</p>
</li>
<li><p>系统写负载成为主要负载</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;%double%&#x27;</span>;</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| innodb_doublewrite | ON    |</span><br><span class="line">+--------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br></pre></td></tr></table></figure>

<p>作为InnoDB的一个关键特性，doublewrite功能默认是开启的，但是在上述特殊的一些场景也可以视情况关闭，来提高数据库写性能。静态参数，配置文件修改，重启数据库。</p>
<h3 id="3-4-为什么没有把double-write里面的数据写到data-page里面呢？"><a href="#3-4-为什么没有把double-write里面的数据写到data-page里面呢？" class="headerlink" title="3.4 为什么没有把double write里面的数据写到data page里面呢？"></a>3.4 为什么没有把double write里面的数据写到data page里面呢？</h3><ol>
<li>double write里面的数据是连续的，如果直接写到data page里面，而data page的页又是离散的，写入会很慢。</li>
<li>double write里面的数据没有办法被及时的覆盖掉，导致double write的压力很大；短时间内可能会出现double write溢出的情况。</li>
</ol>
<h1 id="十一，总结"><a href="#十一，总结" class="headerlink" title="十一，总结"></a>十一，总结</h1><p>redo日志记录了事务执行过程中都修改了哪些内容。</p>
<p>事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘。这样做有两个好处：</p>
<ol>
<li>redo日志占用的空间非常小</li>
<li>redo日志是顺序写入磁盘的</li>
</ol>
<p>一条redo日志由下面几部分组成。</p>
<ol>
<li>type：这条redo日志的类型</li>
<li>space ID:表空间ID</li>
<li>page number :页号</li>
<li>data：这条redo日志的具体内容</li>
</ol>
<p>redo日志的类型有简单和复杂之分。简单类型的redo日志是纯粹的物理日志，复杂类型的redo日志兼有物理日志和逻辑日志的特性。</p>
<p>一个MTR可以包含一组redo日志。在进行崩溃恢复时，这一组redo日志作为一个不可分割的整体来处理。</p>
<p>redo日志存放在大小为512字节的block中。每一个block被分为3部分：</p>
<ol>
<li>log block header</li>
<li>log block body</li>
<li>log block trailer</li>
</ol>
<p>redo日志缓冲区是一片连续的内存空间，由若干个block组成；可以通过启动选项innodb_log_buffer_size 来调整他的大小。</p>
<p>redo日志文件组由若干个日志文件组成，这些redo日志文件是被循环使用的。redo日志文件组中每个文件的大小都一样，格式也一样，都是由两部分组成的：</p>
<ol>
<li>前2048字节用来存储一些管理信息</li>
<li>从第2048字节往后的字节用来存储log buffer中的block镜像</li>
</ol>
<p>lsn指已经写入的redo日志量，flushed_to_disk_lsn指刷新到磁盘中的redo日志量，flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的lsn值进行排序。被多次更新的页面不会重复插入到flush链表，但是会更新newest_modification属性的值。checkpoint_lsn表示当前系统中可以被覆盖的redo日志总量是多少。</p>
<p>redo日志占用的磁盘空间在他对应的脏页已经被刷新到磁盘后即可被覆盖。执行一次checkpoint的意思就是增加checkpoint_lsn的值，然后把相关信息放到日志文件的管理信息中。</p>
<p>innodb_flush_log_at_trx_commit系统变量控制着在事务提交时是否将该事务运行过程中产生的redo刷新到磁盘。</p>
<p>在崩溃恢复过程中，从redo日志文件组第一个文件的管理信息中取出最近发生的那次checkpoint信息，然后从checkpoint_lsn在日志文件组中对应的偏移量开始，一直扫描日志文件中的block，直到某个block的LOG_BLOCK_HDR_DATA_LEN值不等于512为止。再恢复过程中，使用hash表可加快恢复过程，并且会跳过已经刷新到磁盘的页面。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2021/12/27/7.mysql/redo%E6%97%A5%E5%BF%97/">https://zhangxin66666.github.io/2021/12/27/7.mysql/redo日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/"><img class="prev-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">undolog</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/27/7.mysql/mysql%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/" title="mysql三大日志"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">mysql三大日志</div></div></a></div><div><a href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-02</div><div class="title">mysql执行流程</div></div></a></div><div><a href="/2021/12/27/7.mysql/undo%E6%97%A5%E5%BF%97/" title="undolog"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">undolog</div></div></a></div><div><a href="/2022/01/05/7.mysql/%E8%A1%8C%E9%A1%B5%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/" title="行页索引底层结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">行页索引底层结构</div></div></a></div><div><a href="/2022/03/31/7.mysql/%E9%9D%A2%E8%AF%95-mysql/" title="mysql面试"><img class="cover" src="/images/cover/%E9%9D%A2%E8%AF%95.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-31</div><div class="title">mysql面试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFredo%E6%97%A5%E5%BF%97"><span class="toc-text">一，什么是redo日志</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8Credo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">二，redo日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 简单的redo日志类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.复杂的redo日志类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CMini-Transcation"><span class="toc-text">三，Mini-Transcation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A5%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%86%99%E5%85%A5redo%E6%97%A5%E5%BF%97"><span class="toc-text">1.以组的形式写入redo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Mini-Transaction"><span class="toc-text">2.Mini-Transaction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8Credo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">四，redo日志的写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redo-log-block"><span class="toc-text">1.redo log block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-redo-%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">2.redo 日志缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redo-log-%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5log-buffer"><span class="toc-text">3.redo log 日志写入log buffer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%8Credo-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-text">五，redo 日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redo%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-text">1.redo日志刷盘时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-text">2.redo日志文件组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.redo日志文件格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%EF%BC%8CLog-Sequence-Number"><span class="toc-text">六，Log Sequence Number</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-flushed-to-disk-lsn"><span class="toc-text">1.flushed_to_disk_lsn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-lsn%E5%80%BC%E5%92%8Credo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">2.lsn值和redo日志文件偏移量的对应关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-flush%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84LSN"><span class="toc-text">3.flush链表中的LSN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%EF%BC%8Ccheckpoint"><span class="toc-text">七，checkpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E4%BB%8Eflush%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%B7%E5%87%BA%E8%84%8F%E9%A1%B5"><span class="toc-text">1.批量从flush链表中刷出脏页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DLSN%E5%80%BC"><span class="toc-text">2.查看系统中的各种LSN值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-innodb-flush-log-at-trx-commit%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">3.innodb_flush_log_at_trx_commit的用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%EF%BC%8C%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">八，崩溃恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-text">1.确定恢复的起点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E7%BB%88%E7%82%B9"><span class="toc-text">2.确定恢复的终点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%80%8E%E4%B9%88%E6%81%A2%E5%A4%8D"><span class="toc-text">3.怎么恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%EF%BC%8CLOG-BLOCK-HDR-NO%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84"><span class="toc-text">九，LOG_BLOCK_HDR_NO是如何计算的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%EF%BC%8Cdouble-write"><span class="toc-text">十，double write</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%84%8F%E9%A1%B5%E5%88%B7%E7%9B%98%E9%A3%8E%E9%99%A9"><span class="toc-text">1.脏页刷盘风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-doublewrite%EF%BC%9A%E4%B8%A4%E6%AC%A1%E5%86%99"><span class="toc-text">2.doublewrite：两次写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Double-write%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">2.1 Double write解决了什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E4%BD%BF%E7%94%A8%E6%83%85%E6%99%AF"><span class="toc-text">2.2使用情景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-double-write%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">2.3 double write工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-doublewrite%E7%9A%84%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">2.4 doublewrite的崩溃恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-doublewrite%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">3.doublewrite的副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-double-write%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%86%99%E8%B4%9F%E8%BD%BD"><span class="toc-text">3.1 double write带来的写负载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%9B%91%E6%8E%A7double-write%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD"><span class="toc-text">3.2 监控double write工作负载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%85%B3%E9%97%ADdouble-write%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">3.3 关闭double write适合的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%8A%8Adouble-write%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%88%B0data-page%E9%87%8C%E9%9D%A2%E5%91%A2%EF%BC%9F"><span class="toc-text">3.4 为什么没有把double write里面的数据写到data page里面呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%EF%BC%8C%E6%80%BB%E7%BB%93"><span class="toc-text">十一，总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/" title="三种类型设计模式的特点"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三种类型设计模式的特点"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9%20/" title="三种类型设计模式的特点">三种类型设计模式的特点</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式之单例模式"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建型模式之单例模式"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="创建型模式之单例模式">创建型模式之单例模式</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件架构的基本原则"/></a><div class="content"><a class="title" href="/2025/01/11/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则">软件架构的基本原则</a><time datetime="2025-01-10T16:00:00.000Z" title="发表于 2025-01-11 00:00:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" title="设计模式概述"><img src="/images/cover/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式概述"/></a><div class="content"><a class="title" href="/2025/01/10/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/" title="设计模式概述">设计模式概述</a><time datetime="2025-01-09T16:00:00.000Z" title="发表于 2025-01-10 00:00:00">2025-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/" title="Redis-避免缓存穿透的利器之BloomFilter"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis-避免缓存穿透的利器之BloomFilter"/></a><div class="content"><a class="title" href="/2025/01/03/5.%E7%BC%93%E5%AD%98/Redis-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8BBloomFilter/" title="Redis-避免缓存穿透的利器之BloomFilter">Redis-避免缓存穿透的利器之BloomFilter</a><time datetime="2025-01-02T16:00:00.000Z" title="发表于 2025-01-03 00:00:00">2025-01-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>