<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM面试 | 金子爸爸の家</title><meta name="keywords" content="JVM"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM面试">
<meta property="og:url" content="https://zhangxin66666.github.io/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="JVM常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png">
<meta property="article:published_time" content="2024-12-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-12-24T08:20:42.398Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-24 16:20:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-22T16:00:00.000Z" title="发表于 2024-12-23 00:00:00">2024-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T08:20:42.398Z" title="更新于 2024-12-24 16:20:42">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>122分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-jvm内存模型"><a href="#1-jvm内存模型" class="headerlink" title="1.jvm内存模型"></a>1.jvm内存模型</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/0Wv4TH.png" style="zoom:67%;" />

<p><strong>堆</strong>：堆Java虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为Yound区年轻代和Old区老年代，其中年轻代又分为Eden、S0、S1 3个部分，他们默认的比例是8:1:1的大小。</p>
<p><strong>栈</strong>：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。</p>
<p>局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，他的参数会被传递至从0开始的连续的局部变量表中。</p>
<p>操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。</p>
<p>动态连接用于将符号引用表示的方法转换为实际方法的直接引用。</p>
<p><strong>元数据</strong>：在Java1.7之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。</p>
<p>Class文件就是类和接口的定义信息。</p>
<p>运行时常量池就是类和接口的常量池运行时的表现形式。</p>
<p><strong>本地方法栈</strong>：主要用于执行本地native方法的区域</p>
<p><strong>程序计数器</strong>：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址</p>
<p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<h2 id="2-PC寄存器为什么会被设定为线程私有的？"><a href="#2-PC寄存器为什么会被设定为线程私有的？" class="headerlink" title="2.PC寄存器为什么会被设定为线程私有的？"></a>2.PC寄存器为什么会被设定为线程私有的？</h2><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响</p>
<h2 id="3-什么是虚拟机栈（线程私有）？"><a href="#3-什么是虚拟机栈（线程私有）？" class="headerlink" title="3.什么是虚拟机栈（线程私有）？"></a>3.什么是虚拟机栈（线程私有）？</h2><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p>
<ul>
<li><strong>特点？</strong></li>
</ul>
<ol>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li>
<li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li>
<li>栈不存在垃圾回收问题</li>
<li>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li>
</ol>
<ul>
<li><strong>该区域有哪些异常</strong>？</li>
</ul>
<ol>
<li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li>
<li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li>
</ol>
<ul>
<li><strong>栈帧的内部结构？</strong></li>
</ul>
<ol>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）(或称为表达式栈)</li>
<li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li>
<li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li>
<li>一些附加信息</li>
</ol>
<h2 id="4-什么是本地方法栈（线程私有）？"><a href="#4-什么是本地方法栈（线程私有）？" class="headerlink" title="4.什么是本地方法栈（线程私有）？"></a>4.什么是本地方法栈（线程私有）？</h2><ul>
<li><strong>本地方法接口</strong></li>
</ul>
<p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p>
<ul>
<li><strong>本地方法栈(Native Method Stack)</strong></li>
</ul>
<p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p>
<h2 id="5-什么是方法区（线程共享）？"><a href="#5-什么是方法区（线程共享）？" class="headerlink" title="5.什么是方法区（线程共享）？"></a>5.什么是方法区（线程共享）？</h2><p>方法区（method area）只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）**是 **Hotspot** 虚拟机特有的概念， Java8 的时候又被**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</p>
<p>JDK1.8之前调节方法区大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区（永久代）初始大小</span><br><span class="line">-XX:MaxPermSize=N //方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError </span><br></pre></td></tr></table></figure>

<p>JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小</span><br></pre></td></tr></table></figure>

<h2 id="6-栈、堆、方法区的交互关系"><a href="#6-栈、堆、方法区的交互关系" class="headerlink" title="6.栈、堆、方法区的交互关系"></a>6.栈、堆、方法区的交互关系</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/P08Jqc.png" alt="img"></p>
<h2 id="7-堆区内存是怎么细分的？"><a href="#7-堆区内存是怎么细分的？" class="headerlink" title="7.堆区内存是怎么细分的？"></a>7.堆区内存是怎么细分的？</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/9neMNd.jpeg" alt="img"></p>
<p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p>
<ol>
<li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
</ol>
<p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p>
<ul>
<li><strong>年轻代 (Young Generation)</strong></li>
</ul>
<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p>
<ol>
<li>大多数新创建的对象都位于 Eden 内存空间中</li>
<li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li>
<li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li>
<li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li>
</ol>
<ul>
<li><strong>老年代(Old Generation)</strong></li>
</ul>
<p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p>
<p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p>
<h2 id="8-JVM中对象在堆中的生命周期"><a href="#8-JVM中对象在堆中的生命周期" class="headerlink" title="8.JVM中对象在堆中的生命周期?"></a>8.JVM中对象在堆中的生命周期?</h2><ol>
<li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代 <ul>
<li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li>
</ul>
</li>
<li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区 <ul>
<li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li>
</ul>
</li>
<li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） <ul>
<li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li>
<li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li>
</ul>
</li>
<li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li>
</ol>
<h2 id="9-JVM中对象的分配过程"><a href="#9-JVM中对象的分配过程" class="headerlink" title="9.JVM中对象的分配过程?"></a>9.JVM中对象的分配过程?</h2><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li><p>new 的对象先放在伊甸园区，此区有大小限制</p>
</li>
<li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
</li>
<li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区</p>
</li>
<li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</p>
</li>
<li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</p>
</li>
<li><p>什么时候才会去养老区呢？ 默认是 15 次回收标记</p>
</li>
<li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</p>
</li>
<li><p>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</p>
</li>
</ol>
<h2 id="10-静态变量与局部变量的对比"><a href="#10-静态变量与局部变量的对比" class="headerlink" title="10.静态变量与局部变量的对比"></a>10.静态变量与局部变量的对比</h2><p>变量按照数据类型：基本数据类型和引用数据类型</p>
<p>变量按照类中声明位置：成员变量（类变量　ｓｔａｔｉｃ　，局部变量）　局部变量</p>
<p>成员变量　在使用前都经过默认赋值，ｉｎｔ显式赋值。</p>
<p>实例变量　随着对象创建会在堆空间中分配实例变量空间，并进行默认赋值。</p>
<p>局部变量显式赋值，否则没法使用。</p>
<p>在栈帧中，与性能调优最为密切的就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p>在局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接引用或间接引用的对象都不会被回收。</p>
<h2 id="11-方法重写的本质"><a href="#11-方法重写的本质" class="headerlink" title="11.方法重写的本质"></a>11.方法重写的本质</h2><p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做Ｃ。</p>
<p>如果在类型Ｃ中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过则返回java.lang.IllegalAccessError。</p>
<p>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</p>
<p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p><em>java.lang.IllegalAccessError</em></p>
<p>程序试图访问或者修改一个属性或调用一个方法，这个属性或者方法，你没有权限访问，一般的，这个会引起编译期异常，这个错误 如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<p><strong>补充：多态的本质就是指向同一个虚方法表的引用。</strong></p>
<h2 id="12-对象创建过程"><a href="#12-对象创建过程" class="headerlink" title="12.对象创建过程"></a>12.对象创建过程</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/4jwdVI.png" alt="image-20220331111041423" style="zoom:67%;" />

<ol>
<li><strong>类加载检查：</strong>虚拟机遇到一条new指令时，首先将去检查这个类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程：类加载过程中会通过jvm自带的三个类加载器按照双亲委派机制进行类加载过程，我们常见的ClassNotFoundException就是在这里发生的，我们代码中的静态代码块里面的内容也是在这个过程中执行的。</li>
<li><strong>分配内存：</strong>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</li>
<li><strong>初始化零值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>设置对象头</strong>：初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息(即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例)、对象的哈希码（HashCode）、对象的GC分代年龄、锁状态标志等信息。这些信息存放在对象的对象头Object Header之中。</li>
<li><strong>执行<init>方法</strong>：执行方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是<strong>为属性赋值</strong>（注意，这与上面的赋零值不同，这是由程序员赋的值），和<strong>执行构造方法</strong>。</li>
</ol>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/CsPWv6.jpeg" alt="img"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/KBdhXF.jpeg" alt="img"></p>
<h2 id="13-对象分配过程"><a href="#13-对象分配过程" class="headerlink" title="13.对象分配过程"></a>13.对象分配过程</h2><p>1.new的对象先放在伊甸园区，此区有大小限制。</p>
<p>2.当伊甸园的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收，将伊甸园区的不在被其他对象所引用的对象销毁，在加载新的对象放在伊甸园区。</p>
<p>3.然后将伊甸园区剩余的对象移动到幸存者0.</p>
<p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，接着再去幸存者1区。</p>
<p>5.啥时候去养老区呢？可以设置次数，默认是15次。-XX:MaxTenuringThreshold=</p>
<p>(伊甸园区满了会触发ygc，将幸存者区域和伊甸园区都回收一下，但是幸存者区满了不会触发垃圾回收)</p>
<p>总结：针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区或者元空间收集。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/ZaOcEV.jpeg" alt="img"></p>
<h2 id="14-类的加载过程"><a href="#14-类的加载过程" class="headerlink" title="14.类的加载过程"></a>14.类的加载过程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/BmICQh.png" alt="image-20241224100812571"></p>
<p>加载-&gt;链接（验证，准备，解析）-&gt;初始化</p>
<p>1）<strong>加载</strong></p>
<p>通过全限定类名加载一个类的二进制字节流，将静态结构转化为方法区的运行时数据结构，在内存中生成一个代表这个类的Class对象</p>
<p>加载.class文件的方式：</p>
<p>从本地系统中直接加载</p>
<p>通过网络获取，典型场景：Web Applet</p>
<p>从zip压缩包中读取，成为日后jar ，war格式的基础</p>
<p>运行时计算生成，使用最多的是：动态代理技术</p>
<p>其他文件生成：典型场景JSP</p>
<p>从专有数据库提取.class文件，比较少见</p>
<p>从加密文件中获取，典型的防Class文件被反编译的保护措施</p>
<p>2）<strong>链接</strong></p>
<p>1.验证：确保class文件内容不会危害到当前虚拟机</p>
<p>2.准备：为类变量分配内存并设置初始值，不会为实例变量分配空间初始化，类变量分配在方法区，实例变量分配在堆空间。</p>
<p>3.解析：将常量池的符号引用转换为直接引用</p>
<p>3）<strong>初始化</strong></p>
<p>执行类构造器方法（完成静态属性和静态代码块变量的赋值操作）的过程，此方法不需要定义，是javac完成的。</p>
<p>clinit()不同于类的构造器,他只会加载一次。若该类具有父类，JVM会保证子类的clinit()执行前，父类的clinit()已经执行完毕。</p>
<p>虚拟机必须保证一个类的clinit()方法在多线程下被同步加锁。 任何一个类声明以后，内部至少存在一个类的构造器</p>
<h2 id="15-类加载器"><a href="#15-类加载器" class="headerlink" title="15.类加载器"></a>15.类加载器</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/n30NxU.jpeg" alt="图片" style="zoom:67%;" />

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/F2CdXl.jpeg" alt="img"></p>
<p><strong>JDK自带有三个类加载器</strong>：bootstrapClassLoader(引导类加载器)、ExtClassLoader(扩展类加载器)、AppClassLoader(系统类加载器)，bootstrapClassLoader是ExtClassLoader的父类加载器(并不是集成关系，是属性关系)默认加载%JAVA_HOME%/lib下的jar包和class文件ExtClassLoader是AppClassLoader的父类加载器，默认加载%JAVA_HOME%/lib/ext文件夹下的jar包和class文件AppClassLoader是自定义类加载器，负责加载classpath下的类文件</p>
<p>1）<strong>启动类加载器</strong></p>
<p>启动类加载器 BootStrap ClassLoader</p>
<p>加载java核心类库，只加载java javax sun开头的类</p>
<p>2）<strong>系统类加载器</strong></p>
<p>extends ClassLoader java ClassLoader.getSystemClassLoader();</p>
<p>加载用户自定义类，父类加载器为扩展类加载器</p>
<p>3）<strong>拓展类加载器</strong></p>
<p>extends ClassLoader java SystemClassLoader.getParent();</p>
<p>4）<strong>用户自定义类加载器</strong></p>
<p>extends ClassLoader</p>
<p>1.为什么要用户自定义类加载器？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">隔离加载类` `修改类加载的方式` `扩展加载源` `防止源码泄露</span><br></pre></td></tr></table></figure>

<p>2.用户自定义类加载器步骤？</p>
<p>jdk1.2之前，继承ClassLoader重写loadClass().jdk1.2之后建议重写findClass()</p>
<p>也可以继承URLClassLoader,避免了自己编写findClass()以及获取自己码流的方式。</p>
<p>3.ClassLoader</p>
<p>它是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动类加载器)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">getParent()</span> <span class="string">返回父类加载器</span></span><br><span class="line"><span class="meta">loadClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">findClass(String</span> <span class="string">name) 返回Class实例</span></span><br><span class="line"><span class="meta">defineClass(String</span> <span class="string">name,byte[] b ,int off,int len) 把字节数组b中的内容转换为一个java类，返回结果为java.lang.Class类的实例</span></span><br></pre></td></tr></table></figure>



<h2 id="16-JVM类加载机制有哪些？"><a href="#16-JVM类加载机制有哪些？" class="headerlink" title="16.JVM类加载机制有哪些？"></a>16.JVM类加载机制有哪些？</h2><ol>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
<li><strong>双亲委派机制</strong>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
</ol>
<h2 id="17-双亲委派机制"><a href="#17-双亲委派机制" class="headerlink" title="17.双亲委派机制"></a>17.双亲委派机制</h2><p>分为向上委派和向下查找，每一个类加载器都有各自的缓存，都会记录自己加载过的类，当一个类需要加载，AppClassLoader先查找自己的缓存有没有加载过这个类，没有加载过就会调用ExtClassLoader去查找，ExtClassLoader没有加载过，就会调用bootstrapClassLoader类去加载，如果bootstrapClassLoader没有加载过，就会去他的类加载路径查找，如果没有找到ExtClassLoader就会查找他的类加载路径，向上委派就是查找缓存，查找到bootstrapClassLoader位置，向下查找就是查找类加载路径，查找到发起的类加载器为止。</p>
<p>java虚拟机对class文件采用的是按需加载，而且加载某个类的class文件时，java虚拟机采用的是双亲委派机制，就是把请求交由父类加载器处理，它是一种任务委派模式</p>
<p>1）<strong>工作原理</strong></p>
<p>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</p>
<p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器。</p>
<p>如果父加载器可以完成类加载任务，就成功返回，倘若父加载器无法完成此类加载任务，子加载器才会尝试自己去加载。</p>
<p>2）<strong>举例</strong></p>
<p>1.调用JDBC接口，接口是引导类加载器加载的，但是实现类是系统类加载器加载的。</p>
<p>2.假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载<code>java.lang.Object</code>时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String)，最终通过引导类加载器进行加载。</p>
<p>3）<strong>优点</strong></p>
<p>1、安全性，避免自己写的类替换掉java核心类；保护程序安全，防止核心API被随意篡改</p>
<p>2、避免类重复加载，相同class文件不同的类加载器加载的也是两个类。</p>
<p>4）<strong>双亲委托模式的弊端</strong></p>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p>5）思考</p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadClass(String, boolean)方法,抹去其中的双亲委派机制,仅保留上面这4步中的第1步与第4步，那么是不是就能够加载核心类库了呢?</p>
<p>这也不行!因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器还是扩展类加载器，最终都必须调用java.lang.classLoader.defineClass(String,byte[], int, int, ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p>
<p>6）特殊情况:</p>
<p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p>
<p>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>
<h2 id="18-破坏双亲委派机制"><a href="#18-破坏双亲委派机制" class="headerlink" title="18.破坏双亲委派机制"></a>18.破坏双亲委派机制</h2><p>①破坏双亲委派机制1</p>
<p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<p><strong>第一次破坏双亲委派机制:</strong></p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p>不仅<strong>要继承ClassLoader</strong>类，还要<strong>重写loadClass和findClass</strong>方法</p>
<p>②破坏双亲委派机制2</p>
<p>第二次破坏双亲委派机制:线程上下文类加载器</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题〈越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码,那该怎么办呢?</p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的)，肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的NDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办?(SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI)</p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计:线程上下文类加载器（Thread ContextClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如NDI、JDBC、JCE、JAXB和BT等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/DWQ5xc.jpeg" alt="img"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<p>③破坏双亲委派机制3</p>
<p>第三次破坏双亲委派机制:</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如:代码热替换（Hot Swap)、模块热部署（Hot Deployment）等</p>
<p>IBM公司主导的JSR-291(即OSGi R4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:（不细讲）</p>
<p>1）将以java.*开头的类，委派给父类加载器加载。</p>
<p>2）否则，将委派列表名单内的类，委派给父类加载器加载。</p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明:只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结:</p>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如:OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</p>
<h2 id="19-热替换的实现"><a href="#19-热替换的实现" class="headerlink" title="19.热替换的实现"></a>19.热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如: PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重新定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意:由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示:</p>
<p><img src="https://img-blog.csdnimg.cn/2021032601270166.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="20-Class-forName-和ClassLoader-loadClass-区别"><a href="#20-Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="20.Class.forName()和ClassLoader.loadClass()区别?"></a>20.Class.forName()和ClassLoader.loadClass()区别?</h2><ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h2 id="21-什么是-TLAB-（Thread-Local-Allocation-Buffer）"><a href="#21-什么是-TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="21.什么是 TLAB （Thread Local Allocation Buffer）?"></a>21.什么是 TLAB （Thread Local Allocation Buffer）?</h2><ul>
<li><p>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/FYl0lQ.jpeg" alt="img"></p>
</li>
<li><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></p>
</li>
<li><p>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</p>
</li>
</ul>
<h2 id="22-为什么要有-TLAB"><a href="#22-为什么要有-TLAB" class="headerlink" title="22.为什么要有 TLAB ?"></a>22.为什么要有 TLAB ?</h2><ul>
<li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p>
<p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p>
<p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p>
<p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/4HQcAo.jpeg" alt="img"></p>
<h2 id="23-ClassLoader源码解析"><a href="#23-ClassLoader源码解析" class="headerlink" title="23.ClassLoader源码解析"></a>23.ClassLoader源码解析</h2><p><code>ClassLoader</code> 与现有类加载的关系：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/MibqQF.jpeg" alt="img"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java 提供了抽象类 <code>java.lang.ClassLoader</code>，所有用户自定义的类加载器都应该继承 <code>ClassLoader</code> 类。</p>
<h3 id="1）ClassLoader的主要方法"><a href="#1）ClassLoader的主要方法" class="headerlink" title="1）ClassLoader的主要方法"></a>1）ClassLoader的主要方法</h3><p><code>public final ClassLoader getParent()</code>返回该类加载器的超类加载器</p>
<p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回<code>ClassNotFoundException</code>异常。</p>
<p>该方法中的逻辑就是双亲委派模式的实现。</p>
<p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p>
<p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写<code>loadClass</code>方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中，从前面的分析可知， <code>findClass()</code>方法是在l<code>oadClass()</code>方法中被调用的，当<code>loadClass()</code>方法中父加载器加载失败后，则会调用自己的<code>findClass()</code>方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是<code>ClassLoader</code>类中并没有实现<code>findClass()</code>方法的具体代码逻辑，取而代之的是抛出<code>ClassNotFoundException</code>异常，同时应该知道的是<code>findClass</code>方法通常是和<code>defineClass</code>方法一起使用的。一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p>
<p><code>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)</code>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义<code>ClassLoader</code>子类中可以使用。</p>
<p><code>defineClass()</code>方法是用来将byte字节流解析成<code>JVM</code>能够识别的Class对象(<code>ClassLoader</code>中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p>
<p><code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖<code>ClassLoader的findClass()</code>方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用<code>defineClass()</code>方法生成类的Class对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 编写findClass方法的逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的class文件字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>protected final void resolveClass(Class&lt;?&gt; c)</code>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析(即加载的同时也进行解析)。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>查找名称为name的已经被加载过的类，返回结果为<code>java.lang.Class</code>类的实例。这个方法是final方法，无法被修改。</p>
<p><code>private final ClassLoader parent</code>它也是一个<code>ClassLoader</code>的实例，这个字段所表示的<code>ClassLoader</code>也称为这个<code>ClassLoader</code>的双亲。在类加载的过程中,<code>ClassLoader</code>可能会将某些请求交予自己的双亲处理。</p>
<h4 id="①loadClass-的剖析"><a href="#①loadClass-的剖析" class="headerlink" title="①loadClass()的剖析"></a>①loadClass()的剖析</h4><p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguig.java.User&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>涉及到对如下方法的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">//resolve:true-加载class的同时进行解析操作。</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;  <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">       <span class="comment">//首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器。</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载（递归）</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//parent为null:父类加载器是引导类加教器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//当前类的加载器的父类加载器未加载此类or此类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//调用当前ClassLoader的findClass()</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2）SecureClassLoader与URLClassLoader"><a href="#2）SecureClassLoader与URLClassLoader" class="headerlink" title="2）SecureClassLoader与URLClassLoader"></a>2）SecureClassLoader与URLClassLoader</h3><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p>
<p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/jkfwPx.jpeg" alt="img"></p>
<h3 id="3）ExtClassLoader与AppClassLoader"><a href="#3）ExtClassLoader与AppClassLoader" class="headerlink" title="3）ExtClassLoader与AppClassLoader"></a>3）ExtClassLoader与AppClassLoader</h3><p>了解完<code>URLClassLoader</code>后接着看看剩余的两个类加载器，即拓展类加载器<code>ExtClassLoader</code>和系统类加载<code>AppClassLoader</code>，这两个类都继承自<code>URLClassLoader</code>，是<code>sun.misc.Launcher</code>的静态内部类。</p>
<p><code>sun.misc.Launcher</code>主要被系统用于启动主应用程序，<code>ExtClassLoader</code>和<code>AppClassLoader</code>都是由<code>sun.misc.Launcher</code>创建的，其类主要类结构如下:</p>
<p><img src="https://img-blog.csdnimg.cn/20210326012558316.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>我们发现<code>ExtClassLoader</code>并没有重写<code>loadClass()</code>方法，这足矣说明其遵循双亲委派模式，而<code>AppClassLoader</code>重载了<code>loadclass()</code>方法，但最终调用的还是父类<code>loadClass()</code>方法，因此依然遵守双亲委派模式。</p>
<h3 id="4）Class-forName与ClassLoader-loadClass"><a href="#4）Class-forName与ClassLoader-loadClass" class="headerlink" title="4）Class.forName与ClassLoader.loadClass()"></a>4）Class.forName与ClassLoader.loadClass()</h3><p><code>Class.forName()</code>:是一个静态方法,最常用的是<code>Class.forName(String className);</code>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时,会执行类的初始化。</p>
<p>如:<code>Class.forName( &quot;com.atguigu.java.Helloworld&quot;) ;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.loadClass()`:这是一个实例方法,需要一个`ClassLoader`对象来调用该方法。该方法将class文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化。该方法因为需要得到个`ClassLoader`对象,所以可以根据需要指定使用哪个类加载器.如: `ClassLoader cl=......;</span><br><span class="line">cl.loadClass (&quot;com.atguigu.java.Helloworld&quot; );</span><br></pre></td></tr></table></figure>



<h2 id="24-类加载器Java9新特性"><a href="#24-类加载器Java9新特性" class="headerlink" title="24.类加载器Java9新特性"></a>24.类加载器Java9新特性</h2><p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<p>1.扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform classloader)。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</p>
<p>JDK 9时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HONE>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p>
<p>2.平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/3EVRSl.jpeg" alt="img"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在 JDK9及更高版本的JDK中崩溃。</p>
<p>3.在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p>
<p>4.启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器〈以前是C++实现)，但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</p>
<p>5.类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/WDjLwL.png" alt="image-20241224110158151"></p>
<p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块。</p>
<h2 id="25-两种类装载方式"><a href="#25-两种类装载方式" class="headerlink" title="25.两种类装载方式"></a>25.两种类装载方式</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p>
<p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<h2 id="26-深拷贝和浅拷贝"><a href="#26-深拷贝和浅拷贝" class="headerlink" title="26.深拷贝和浅拷贝"></a>26.深拷贝和浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p>
<p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p>
<p>深复制：在计算机中开辟一块<strong>新的内存地址</strong>用于存放复制的对象。</p>
<h2 id="27-对象创建的几种方式"><a href="#27-对象创建的几种方式" class="headerlink" title="27.对象创建的几种方式"></a>27.对象创建的几种方式</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/PllR3d.png" alt="image-20241224112935380"></p>
<h2 id="28-为对象分配内存两种方式"><a href="#28-为对象分配内存两种方式" class="headerlink" title="28.为对象分配内存两种方式"></a>28.为对象分配内存两种方式</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/WGOpjX.png" alt="内存分配的两种方式"></p>
<h2 id="29-对象的创建过程中处理并发安全问题"><a href="#29-对象的创建过程中处理并发安全问题" class="headerlink" title="29.对象的创建过程中处理并发安全问题"></a>29.对象的创建过程中处理并发安全问题</h2><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。</li>
</ul>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/jfM1F2.png" alt="内存分配时保证线程安全的两种方式"></p>
<h2 id="30-介绍一下强引用、软引用、弱引用、虚引用的区别？"><a href="#30-介绍一下强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="30.介绍一下强引用、软引用、弱引用、虚引用的区别？"></a>30.介绍一下强引用、软引用、弱引用、虚引用的区别？</h2><p>1）强引用</p>
<p>我们平时new了一个对象就是强引用，例如 Object obj = new Object();</p>
<p>即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p>
<p>2）软引用</p>
<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softRef=<span class="keyword">new</span> SoftReference&lt;String&gt;(str);     <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure>

<p><strong>用处：</strong> 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = <span class="keyword">new</span> Browser();               <span class="comment">// 获取页面进行浏览</span></span><br><span class="line">SoftReference sr = <span class="keyword">new</span> SoftReference(prev); <span class="comment">// 浏览完毕后置为软引用        </span></span><br><span class="line"><span class="keyword">if</span>(sr.get()!=<span class="keyword">null</span>)&#123; </span><br><span class="line">    rev = (Browser) sr.get();           <span class="comment">// 还没有被回收器回收，直接获取</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    prev = <span class="keyword">new</span> Browser();               <span class="comment">// 由于内存吃紧，所以对软引用的对象回收了</span></span><br><span class="line">    sr = <span class="keyword">new</span> SoftReference(prev);       <span class="comment">// 重新构建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）弱引用</p>
<p>具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">str=<span class="keyword">null</span>;</span><br><span class="line">等价于</span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>

<p>4）虚引用</p>
<p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<h2 id="31-怎么判断对象是否可以被回收？"><a href="#31-怎么判断对象是否可以被回收？" class="headerlink" title="31.怎么判断对象是否可以被回收？"></a>31.怎么判断对象是否可以被回收？</h2><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h2 id="32-在Java中，对象什么时候可以被垃圾回收"><a href="#32-在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="32.在Java中，对象什么时候可以被垃圾回收"></a>32.在Java中，对象什么时候可以被垃圾回收</h2><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p>
<h2 id="33-JVM-运行时堆内存如何分代"><a href="#33-JVM-运行时堆内存如何分代" class="headerlink" title="33.JVM 运行时堆内存如何分代?"></a>33.JVM 运行时堆内存如何分代?</h2><p>Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/r0bGp6.png" alt="image-20241224141523427"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/2fLuAO.png" alt="image-20241224141540105"></p>
<p>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。</p>
<p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 <strong>1:2</strong> ( 该值可以通过参数 –XX:NewRatio 来指定 )，</p>
<p>即：<strong>新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小</strong>。</p>
<p>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分</p>
<p>默认的，<strong>Eden: from : to = 8 :1 : 1</strong> ( 可以通过参数<strong>–XX:SurvivorRatio</strong> 来设定 )，即： <strong>Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小</strong>。</p>
<p>JVM <strong>每次只会使用 Eden 和其中的一块 Survivor 区域</strong>来为对象服务，所以<strong>无论什么时候，总是有一块Survivor区域是空闲着的</strong>。</p>
<p>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p>
<p><strong>新生代</strong></p>
<p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。<br><strong>Eden 区</strong><br>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。<br><strong>Servivor from 区</strong><br>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。<br><strong>Servivor to 区</strong><br>保留了一次 MinorGC 过程中的幸存者。<br><strong>MinorGC 的过程（复制-&gt;清空-&gt;互换）</strong><br>MinorGC 采用复制算法。</p>
<ol>
<li>eden、 servicorFrom 复制到 ServicorTo，年龄+1<br>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</li>
<li>清空 eden、 servicorFrom<br>然后，清空 Eden 和 ServicorFrom 中的对象；</li>
<li>ServicorTo 和 ServicorFrom 互换<br>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</li>
</ol>
<p><strong>老年代</strong></p>
<p>主要存放应用程序中生命周期长的内存对象。<br>老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。<br>FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p>
<p><strong>永久代</strong></p>
<p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p>
<h2 id="34-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor"><a href="#34-JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor" class="headerlink" title="34.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor"></a>34.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor</h2><p>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p>1）共享内存区划分</p>
<ul>
<li>共享内存区 = 持久带 + 堆</li>
<li>持久带 = 方法区 + 其他</li>
<li>Java堆 = 老年代 + 新生代</li>
<li>新生代 = Eden + S0 + S1</li>
</ul>
<p>2）一些参数的配置</p>
<ul>
<li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。</li>
<li>默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)</li>
<li>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</li>
</ul>
<h2 id="35-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#35-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="35.为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>35.为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h2><ul>
<li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</li>
<li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li>
<li>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</li>
</ul>
<h2 id="36-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#36-JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="36.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>36.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h2><p>先描述一下Java堆内存划分，再解释Minor GC，Major GC，full GC，描述它们之间转化流程。</p>
<ul>
<li>Java堆 = 老年代 + 新生代</li>
<li>新生代 = Eden + S0 + S1</li>
<li>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</li>
<li><strong>大对象</strong>（需要大量连续内存空间的Java对象，如那种很长的字符串）<strong>直接进入老年态</strong>；</li>
<li>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，<strong>若年龄超过一定限制（15），则被晋升到老年态</strong>。即<strong>长期存活的对象进入老年态</strong>。</li>
<li>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和年老代</strong>。</li>
<li>Major GC <strong>发生在老年代的GC</strong>，<strong>清理老年区</strong>，经常会伴随至少一次Minor GC，<strong>比Minor GC慢10倍以上</strong>。</li>
</ul>
<h2 id="37-JVM中的永久代中会发生垃圾回收吗"><a href="#37-JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="37.JVM中的永久代中会发生垃圾回收吗"></a>37.JVM中的永久代中会发生垃圾回收吗</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h2 id="38-JAVA8-与元数据"><a href="#38-JAVA8-与元数据" class="headerlink" title="38.JAVA8 与元数据"></a>38.JAVA8 与元数据</h2><p>在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入native memory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制</p>
<h2 id="39-如何判断对象可以被回收？"><a href="#39-如何判断对象可以被回收？" class="headerlink" title="39.如何判断对象可以被回收？"></a>39.如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：</p>
<ul>
<li>引用计数：</li>
</ul>
<p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
<ul>
<li>可达性分析（Reachability Analysis）：</li>
</ul>
<p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>
<h2 id="40-引用计数法"><a href="#40-引用计数法" class="headerlink" title="40.引用计数法"></a>40.引用计数法</h2><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p>
<h2 id="41-可达性分析"><a href="#41-可达性分析" class="headerlink" title="41.可达性分析"></a>41.可达性分析</h2><p>为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p>
<h2 id="42-Minor-GC与Full-GC分别在什么时候发生？"><a href="#42-Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="42.Minor GC与Full GC分别在什么时候发生？"></a>42.Minor GC与Full GC分别在什么时候发生？</h2><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p>
<h2 id="43-标记清除算法"><a href="#43-标记清除算法" class="headerlink" title="43.标记清除算法"></a>43.标记清除算法</h2><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法，复制算法，标记-压缩算法。</p>
<p>当堆中的有效内存空间被耗尽时，就会停止整个程序，然后进行两项工作，第一项是标记，第二项则是清除。</p>
<p>标记：从引用跟节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<p>清除：对堆内存从头到尾进行线性遍历，如果发现某个对象在其header中没有标记为可达对象，则将其回收。</p>
<p>优点：不需要进行对象的移动，并且仅对不存活的对象进行处理，存活对象比较多的情况下极为高效。</p>
<p>缺点：标记和清除过程的效率都不高，这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小，对空闲列表的管理会增加分配对象时的工作量；标记清除后会产生大量不连续的内存碎片，虽然空闲区域的大小是足够的，但却可能没有一个单一的区域能满足这次分配所需大小，分配还会失败，不得不触发再一次的垃圾回收。</p>
<p>何为清除：<strong>所谓清除，并不是并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新的对象需要加载时，判断垃圾的位置空间是够够，够就存放</strong>。</p>
<h2 id="44-标记整理算法"><a href="#44-标记整理算法" class="headerlink" title="44.标记整理算法"></a>44.标记整理算法</h2><p>算法标记的过程与标记清除算法中的标记过程一样，但是对标记后出的垃圾对象的处理情况有所不同，他不是直接对可回收对象进行清理，而是让所有的对象都像一端移动，然后直接清理掉端边界以外的内存。在基于标记整理算法的收集齐实现中，一般增加句柄和句柄表。</p>
<p>优点：经过整理之后，新对象的分配只需要通过指针碰撞便能完成，比较简单；使用这种方法，空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p>
<p>缺点：ＧＣ暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新他们的引用地址。</p>
<h2 id="45-复制算法"><a href="#45-复制算法" class="headerlink" title="45.复制算法"></a>45.复制算法</h2><p>复制算法主要是为了克服句柄的开销和解决堆碎片的垃圾回收。它将内存按照容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还活着的对象复制到另一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。</p>
<p>复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低。所以老年代一般会选用其他算法，如标记整理算法。一种典型的基于复制算法的垃圾回收是<code>stop-and-copy</code>算法，他将堆分为对象区和空闲区，在对象区与空闲区的切换过程中，程序暂停执行。</p>
<p>优点：标记阶段和复制阶段可以同时进行，每次只对一块内存进行回收，运行高效，只需要移动栈顶指针，按顺序分配内存即可，实现简单，内存回收时，不用考虑内存碎片的出现。</p>
<p>缺点：需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。</p>
<h2 id="46-分代收集算法"><a href="#46-分代收集算法" class="headerlink" title="46.分代收集算法"></a>46.分代收集算法</h2><p>将堆内存划分为新生代，老年代和永久代。新生代又被进一步划分为伊甸园区和幸存者0，幸存者1区。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xms和-Xmx来控制。分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收，以便提高回收效率。</p>
<p>新生代：几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照 8:1:1 的比例分为一个 Eden 区和两个 Survivor（Survivor0，Survivor1）区。大部分对象在 Eden 区中生成。当新对象生成，Eden 空间申请失败（因为空间不足等），则会发起一次 GC（Scavenge GC）。回收时先将 Eden 区存活对象复制到一个 Survivor0 区，然后清空 Eden 区，当这个 Survivor0 区也存放满了时，则将 Eden 区和 Survivor0 区存活对象复制到另一个 Survivor1 区，然后清空 Eden 和这个 Survivor0 区，此时 Survivor0 区是空的，然后将 Survivor0 区和 Survivor1 区交换，即保持 Survivor1 区为空， 如此往复。当 Survivor1 区不足以存放 Eden 和 Survivor0 的存活对象时，就将存活对象直接存放到老年代。当对象在 Survivor 区躲过一次 GC 的话，其对象年龄便会加 1，默认情况下，如果对象年龄达到 15 岁，就会移动到老年代中。若是老年代也满了就会触发一次 Full GC，也就是新生代、老年代都进行回收。新生代大小可以由<code>-Xmn</code>来控制，也可以用<code>-XX:SurvivorRatio</code>来控制 Eden 和 Survivor 的比例。</p>
<p>老年代：在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多（大概比例是 1:2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和 JVM 的相关参数。</p>
<p>永久代：用于存放静态文件（<code>class</code>类、方法）和常量等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些<code>class</code>，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。对永久代的回收主要回收两部分内容：废弃常量和无用的类。永久代在 Java SE8 特性中已经被移除了，取而代之的是元空间（<code>MetaSpace</code>），因此也不会再出现<code>java.lang.OutOfMemoryError: PermGen error</code>的错误了。</p>
<p>特别的，在分代收集算法中，对象的存储具有以下特点：</p>
<p>1.对象优先在伊甸园区分配</p>
<p>2.大对象直接进入老年代</p>
<p>3.长期存活的对象将进入老年代，默认为15岁</p>
<p>对于晋升老年代的年龄阈值，为什么是15岁？</p>
<p>实际上，HotSpot虚拟机的对象头其中一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称为<code>mark word</code>。在 32 位的 HotSpot 虚拟机中，如果对象处于未被锁定的状态下，那么<code>Mark Word</code>的 32bit 空间中 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，其中对象的分代年龄占 4 位，也就是从<code>0000</code>到<code>1111</code>，而其值最大为 15，所以分代年龄也就不可能超过 15 这个数值了。</p>
<p><strong>GC的分类</strong></p>
<p>新生代GC Minor GC ：发生在新生代的垃圾收集动作，因为java对象大多具有朝生夕灭的特性，因此MinorGC非常频繁，一般回收速度也比较快。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可以选用复制算法。</p>
<p>老年代GC Major GC：发生在老年代的垃圾回收动作。Major GC 经常会伴随至少一次Minor GC。由于老年代中的对象的生命周期比较长，因此Major GC并不频繁，一般都是等待老年代满了之后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行 Full GC 时，会顺便清理掉 Direct Memory 中的废弃对象。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”算法或“标记-整理”算法来进行回收。新生代采用空闲指针的方式来控制 GC 触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发 GC。当连续分配对象时，对象会逐渐从 Eden 到 Survivor，最后到老年代。</p>
<h2 id="47-增量收集算法"><a href="#47-增量收集算法" class="headerlink" title="47.增量收集算法"></a>47.增量收集算法</h2><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种STW的状态，在该状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统稳定性。为了解决这个问题，即对实时垃圾收集算法的亚久直接导致增量收集算法的产生。</p>
<p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程 和应用程序线程交替执行。每次，垃圾收集线程值收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，一直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记，清理或复制工作。</p>
<p>缺点：线程切换和上下文的转换消耗性能，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</p>
<h2 id="48-分区算法"><a href="#48-分区算法" class="headerlink" title="48.分区算法"></a>48.分区算法</h2><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小空间。每一个小空间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<h2 id="55-垃圾判断算法"><a href="#55-垃圾判断算法" class="headerlink" title="55.垃圾判断算法"></a>55.垃圾判断算法</h2><p>１）引用计数法</p>
<p>在这种算法中，假设堆中每个对象都有一个引用计数器。当一个对象被创建并且初始化赋值以后，对象的计数器就会设置为１，每当有一个地方引用他，计数器的值就会＋１，例如将对象Ｂ赋值给对象Ａ，那么Ｂ被引用，Ｂ的引用计数器就会＋１.</p>
<p>反之，当引用失效的时候，比如一个对象的某个引用被设置了新的值，则之前被引用的对象的计数器就会－１.而那些引用计数为０的对象，就可以称之为垃圾，可以被收集。</p>
<p>特别的，当一个对象被当做垃圾收集时，他引用的任何对象的计数器的值都－１.</p>
<p>优点：实现简单，对程序不被长时间打断的实时环境比较有利</p>
<p>缺点：需要额外的空间来存储计数器，难以检测对象之间的循环依赖</p>
<p>java并没有选择引用计数，是因为其存在一个基本难题，也就是很难处理循环引用关系。</p>
<p>Python如何解决循环引用？手动解决（在合适的时机，接触引用关系）使用弱引用weakref（weakref是Python提供的标准库，为了解决循环依赖）</p>
<p>２）可达性分析算法</p>
<p>可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。</p>
<p>对象成为可达对象的两个条件：</p>
<p>对象属于跟集中的对象　　　　　对象被一个可达的对象引用</p>
<h2 id="56-在java语言中，GC-ROOTS-包括以下几类元素："><a href="#56-在java语言中，GC-ROOTS-包括以下几类元素：" class="headerlink" title="56.在java语言中，GC ROOTS 包括以下几类元素："></a>56.在java语言中，GC ROOTS 包括以下几类元素：</h2><p>虚拟机栈中引用的对象（各个线程被调用的方法中使用到的参数，局部变量等）</p>
<p>本地方法栈内JNI（通常说的本地方法）引用的对象</p>
<p>方法区中类静态属性引用的对象（java类的引用类型静态变量）</p>
<p>方法区中常量引用的对象（字符串常量池（String Table）里的引用）</p>
<p>所有被同步锁synchronized持有的对象</p>
<p>java虚拟机内部的引用（基本数据类型对应的class对象，一些常驻的异常对象，系统类加载器）</p>
<p>本地代码缓存</p>
<p>临时的（分代收集，局部回收）</p>
<p><strong>如何判断一个root</strong></p>
<p>由于root采用栈方式存放变量和指针，所以如果一个指针，他保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那他就是一个root。</p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须<code>Stop the World</code>的一个重要原因。</p>
<p>优点：可以解决循环引用的问题，不需要占用额外的空间</p>
<p>缺点：多线程场景下，其他线程可能会更新已经访问过的对象的引用。</p>
<h2 id="57-Minor-GC-Major-GC-fULL-GC"><a href="#57-Minor-GC-Major-GC-fULL-GC" class="headerlink" title="57.Minor GC,Major GC,fULL GC"></a>57.Minor GC,Major GC,fULL GC</h2><p>jvm在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分回收都是指新生代。</p>
<p>针对hotSpotVM的实现，它里面的GC按照回收区域分为两大类型：一种是部分收集，一种是FullGC</p>
<p>1.部分收集：不是完整收集整个Java堆的垃圾回收，又分为：</p>
<p>1）新生代收集Minor GC：只是新生代的垃圾收集</p>
<p>2）老年代收集Major GC：只是老年代的垃圾收集</p>
<p>目前只有CMSGC拥有单独收集老年代的行为，很多时候Minor GC会和FullGC混淆使用，需要具体分辨老年代回收还是整堆回收。</p>
<p>3）混合收集：收集整个新生代以及部分老年代的垃圾</p>
<p>2.整堆收集：收集整个java堆和方法区的垃圾</p>
<h2 id="58-分代式GC策略触发条件"><a href="#58-分代式GC策略触发条件" class="headerlink" title="58.分代式GC策略触发条件"></a>58.分代式GC策略触发条件</h2><p>1）<strong>年轻代触发机制</strong></p>
<p>1.当年轻代空间不足时，就会出发minorGC，这里的年轻代指的是Eden满，Survivor满不会触发GC</p>
<p>2.因为java对象大多数存活时间比较短暂，所以MinorGC非常频繁，一般回收速度也比较快。</p>
<p>3.MinorGC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/goXjGG.png" alt="image-20241224143345938"></p>
<p>2）<strong>老年代GC触发机制</strong></p>
<p>1.指的是发生在老年代的GC，对象从老年代消失时，我们说的MajorGC和FullGC发生了。</p>
<p>2.出现了MajorGC，经常会伴随至少一次的MinorGC，也就是在老年代空间不足的时候，会先尝试触发minorGC，如果之后空间还是不足，则会触发MajorGC。</p>
<p>3.MajorGC的速度一般会比MinorGC慢10倍以上，STW时间更长。</p>
<p>4.如果MajorGC后，内存还是不足，就会OOM。</p>
<p>3）<strong>FullGC触发条件</strong></p>
<p>1.System.gc() 不是一定执行的。</p>
<p>2.老年代空间不足</p>
<p>3.方法区空间不足</p>
<p>4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</p>
<p>5.Eden区，survivor0 区向survivor1区复制时，对象大小大于To Space可用区域，则把该对象转存到老年代，且老年代的可用内存小于该对象的内存就会触发GC。</p>
<p>Full GC是开发或者调优中尽量要避免的，这样暂停时间会短一些。</p>
<h2 id="59-从逃逸分析角度分析对象内存分配"><a href="#59-从逃逸分析角度分析对象内存分配" class="headerlink" title="59.从逃逸分析角度分析对象内存分配"></a>59.从逃逸分析角度分析对象内存分配</h2><p>1）堆是分配对象存储的唯一选择嘛？</p>
<p>在java虚拟机中，对象在java堆中分配内存的，这是一个普遍的常识。但是有一个特殊的情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能优化成栈上分配。这样就无需再堆上分配内存，也无须进行垃圾回收了。这是最常见的堆外存储技术。</p>
<p>2）逃逸分析</p>
<p>1.如果将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>2.这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p>3.通过逃逸分析，hotspot编译器能够分析出一个新的对象的引用的适用范围从而决定是否要将这个对象分配到堆上。</p>
<p>4.逃逸分析的基本行为就是分析对象动态作用域：</p>
<p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
<p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
<p>5.没有发生逃逸的对象，则可以分配到栈上，随着方法的执行结束，栈空间就被移除，栈空间指向堆空间对象的引用就没了，等到年轻代GC，对象就会被回收。</p>
<p>3）补充</p>
<p>其实主要就是解决了循环引用，没有逃逸分析，这个对象可能一直不被回收，但是有了逃逸分析，栈帧销毁，这个对象就是垃圾了。</p>
<h2 id="60-使用逃逸分析堆代码进行优化"><a href="#60-使用逃逸分析堆代码进行优化" class="headerlink" title="60.使用逃逸分析堆代码进行优化"></a>60.使用逃逸分析堆代码进行优化</h2><p>1）栈上分配</p>
<p>将堆分配转换为栈分配，如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束后，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见的栈上分配场景：在逃逸分析中，已经说明了。分别是给成员变量赋值，方法返回值，实例引用传递。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis //默认开启</span><br></pre></td></tr></table></figure>

<p>2）同步省略</p>
<p>如果一个对象被发现只能从一个线程被访问到，那么这个对象的操作可以不考虑同步。线程同步的代价是相当高的，同步的后果是降低并发和性能。在动态编译同步代码块的时候，jit编译器可以借助逃逸分析来判断同步块所使用的锁的对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性能，这个取消的性能就叫做同步省略，也叫锁消除。</p>
<p>3）分离对象或标量替换</p>
<p>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不存储在内存，而是存储在CPU寄存器中</p>
<p>1.标量是指一个无法在分解成更小的数据的数据，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量，java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
<p>2.标量替换的参数设置</p>
<p>参数-XX：+EliminateAllocations开启了标量替换，允许将对象打散分配在栈上。</p>
<p>3.逃逸分析技术并不成熟，其根本原因就是无法保证逃逸分析的性能消耗一定高于他的消耗。虽然经过逃逸分析可以做标量替换，栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程，虽然并不成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<p><strong>通过逃逸分析，jvm会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于jvm设计者的选择。HotSpot虚拟机中并未这么做，所以可以明确所有的对象实力都是创建在堆上。</strong></p>
<p>intern字符串的缓存和静态变量曾经都被分配到永久带上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配 ，所以这一点同样符合前面的一点结论：对象实例都是分配在堆上。</p>
<h2 id="61-垃圾回收分类"><a href="#61-垃圾回收分类" class="headerlink" title="61.垃圾回收分类"></a>61.垃圾回收分类</h2><p>按照垃圾回收线程分：串行垃圾回收器和并行垃圾回收器</p>
<p>串行回收是指在同一时间段内只允许有一个cpu执行垃圾回收操作，此时工作线程被暂停，直至垃圾回收结束。</p>
<p>并行则是允许运用多个cpu同时执行垃圾回收操作。</p>
<p>按照工作模式分：并发式垃圾回收器和独占式垃圾回收器</p>
<p>并发式垃圾回收器与应用程序线程交替，尽可能减少应用程序暂停时间。</p>
<p>独占式垃圾回收器一旦运行，就禁止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</p>
<p>按照碎片处理方式分类，压缩垃圾回收器和非压缩垃圾回收器</p>
<p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p>
<p>非压缩式的垃圾回收器不进行这步操作。</p>
<p>按照工作的内存区间分：又可分为年轻代的垃圾回收器和老年代的垃圾回收器。</p>
<h2 id="62-评估GC的性能指标"><a href="#62-评估GC的性能指标" class="headerlink" title="62.评估GC的性能指标"></a>62.评估GC的性能指标</h2><p>吞吐量：运行用户代码的时间占总运行时间的比例。（总运行时间=程序运行时间+垃圾回收时间）</p>
<p>暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间。</p>
<p>收集频率：相对于应用程序的执行，收集发生的频率。</p>
<p>内存占用：java堆区所占内存大小。</p>
<p>三者总体表现会随着技术进步越来越好，主要抓住两点：吞吐量和暂停时间。</p>
<p>如果以吞吐量优先，那么必然需要降低内存回收的执行效率，但是这样会导致GC需要更长的时间来执行内存回收。如果选择低延迟优先，为了降低每次内存回收时的暂停时间，也只能频繁的执行内存回收，但又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>
<p>标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
<h2 id="63-不同的垃圾回收器概述"><a href="#63-不同的垃圾回收器概述" class="headerlink" title="63.不同的垃圾回收器概述"></a>63.不同的垃圾回收器概述</h2><p>1）垃圾收集器发展历史</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.3发布Serial GC 他是第一款GC。ParNew是Serial 的多线程版本。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.4发布Parallel GC 和 Concurrent Mark Sweep GC。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK6之后Parallel GC称为HotSpot默认垃圾回收器。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK1.7引入G1。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK9把G1变为默认垃圾收集器，替代CMS。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK10中G1垃圾收集器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK11引入Epsilon GC。同时引入ZGC。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK12增强G1，自动返回未使用堆内存给操作系统，同时引入Shenandoah GC。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK13增强ZGC。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK14删除CMS，并拓展ZGC的平台兼容性。</span><br></pre></td></tr></table></figure>

<p>2）垃圾收集器分类</p>
<p>串行回收器：<code>Serial，Serial Old</code></p>
<p>并行回收器：<code>ParNew，Parallel Scavenge，Parallel Old</code></p>
<p>并发回收器：<code>CMS,Gl</code></p>
<p>新生代收集器：<code>Serial，ParNew，Parallel Scavenge</code></p>
<p>老年代收集器：<code>Serial Old，Parallel Old，CMS</code></p>
<p>整堆收集器：<code>G1</code></p>
<p><strong>为什么要有很多收集器？</strong></p>
<p>因为java使用场景很多，移动端，服务端等。所以就需要针对不同的场景，提供不同的垃圾回收器，提高垃圾收集的性能。</p>
<p>对垃圾收集器进行比较只是对具体应用场景选择最合适的收集器。</p>
<p><strong>如何查看默认的垃圾收集器？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags  查看命令行相关参数（包含垃圾收集器）</span><br><span class="line"></span><br><span class="line">使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</span><br><span class="line"></span><br><span class="line">Parallel Scavenge 和 Parallel Old</span><br></pre></td></tr></table></figure>



<h2 id="64-Serial-回收器（串行回收器）"><a href="#64-Serial-回收器（串行回收器）" class="headerlink" title="64.Serial 回收器（串行回收器）"></a>64.Serial 回收器（串行回收器）</h2><p>jdk1.3之前回收新生代的唯一选择（HotSpot在Client模式下的默认新生代垃圾收集器）</p>
<p>Serial 收集器采用复制算法，串行回收和STW机制的方式执行内存回收。</p>
<p>除了年轻代，Serial收集器还提供用于执行老年代垃圾回收的Serial Old收集器。Serial Old 收集器同样也采用了串行回收和STW机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。</p>
<p>Serial Old在Server模式下主要有两个用途：1.与新生代的Parallel Scavenge配合使用 2.作为老年代CMS收集器的后备垃圾收集方案。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/lwcN7o.jpeg" alt="img"></p>
<p>这个收集器是一个单线程的收集器，但他的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到他收集结束。</p>
<p>优势：简单而高效，对于限定单个CPU的环境来讲，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。（运行在Client模式下的虚拟机是个不错的选择）</p>
<p>在HotSpot虚拟机中，使用<code>-XX:UseSerialGC</code> 参数可以指定年轻代和老年代都是用串行收集器。（等价于新生代使用Serial GC，老年代使用Serial Old GC），一般在java web程序中是不会使用这种垃圾回收器的。</p>
<h2 id="65-ParNew回收器（并行回收）"><a href="#65-ParNew回收器（并行回收）" class="headerlink" title="65.ParNew回收器（并行回收）"></a>65.ParNew回收器（并行回收）</h2><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。（Par是Parallel的缩写 New只能处理新生代）</p>
<p>ParNew收集器除了采用并行回收方式执行内存回收外，两款垃圾收集器之间几乎没有差别，也是STW，也是复制算法。</p>
<p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/21K01T.jpeg" alt="img"></p>
<p>对于新生代，回收次数频繁，使用并行高效。对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</p>
<p>由于ParNew收集器是并行回收，那么是否可以断定在任何场景下他的回收效率都比Serial收集器更高效？</p>
<p>1.多核系统下，充分利用系统资源，可以快速完成垃圾收集，提升程序吞吐量。</p>
<p>2.但是单个CPU下，他不一定有Serial收集器更高效。避免了线程切换。</p>
<p><strong>除了Serial 外，目前只有ParNew 能与CMS收集器配合工作。</strong></p>
<p>在程序中，开发人员可以通过选项<code>-XX:UseParNewGC</code>手动指定使用ParNew收集器执行内存回收任务 。他表示年轻代使用并行收集器并不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和CPU数相同的线程数。</p>
<h2 id="66-Parallel-Scavenge-回收器（吞吐量优先）"><a href="#66-Parallel-Scavenge-回收器（吞吐量优先）" class="headerlink" title="66.Parallel Scavenge 回收器（吞吐量优先）"></a>66.Parallel Scavenge 回收器（吞吐量优先）</h2><p>1）概述</p>
<p>HotSpot的年轻代除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法，并行回收和STW机制。</p>
<p>那么他的出现是否多此一举呢？</p>
<p>1.和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，他也被称为吞吐量优先的垃圾收集器。</p>
<p>2.自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。</p>
<p>高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：那些执行批量处理，订单处理，工资支付，科学计算的应用程序。</p>
<p>Parallel 收集器在jdk1.6的时候提供了用于执行老年代垃圾搜集的Parallel Old收集器，用来替代老年代的Serial Old收集器。Parallel Old收集器采用了标记-压缩算法，但是同样也是基于并行回收和STW机制。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/CwEK5R.png" alt="image-20241224145425458"></p>
<p>在程序吞吐量优先的场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾回收器。</p>
<p>2）参数配置</p>
<p><code>-XX:UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
<p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收器。（分别适用于新生代和老年代。默认是JDK8开启的）</p>
<p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般的最好与CPU数量相等，避免线程数影响收集器性能。（默认情况下，CPU数小于8，ParallelGCThreads的值等于CPU数量，当cpu数大于8个的时候，ParallelGCThreads值=3+[5*cpu数]/8 ）</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（STW的时间，单位是ms）</p>
<p>为了尽可能把停顿时间控制在<code>MaxGCPauseMills</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。对于用户来讲，停顿时间越短，体验越好。但是在服务器端，我们注重高并发，整体的吞吐量，所以服务端适合Parallel，进行控制。（该参数谨慎使用）</p>
<p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间比例（=1/(N+1)）用于衡量吞吐量大小。</p>
<p><code>-XX:UseAdaptiveSizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略</p>
<p>在这种模式下，年轻代的大小，Eden和幸存者的比例，晋升老年代的对象年龄等参数会被自动调整，已经达到在堆大小，吞吐量和停顿时间之间的平衡点。</p>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅仅指定虚拟机的最大堆，目标吞吐量和停顿时间，让虚拟机自己完成调优工作。</p>
<h2 id="67-CMS回收器（低延迟）"><a href="#67-CMS回收器（低延迟）" class="headerlink" title="67.CMS回收器（低延迟）"></a>67.CMS回收器（低延迟）</h2><p>1）概述</p>
<p>JDK1.5，这款收集器是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短就越适合于用户交互的程序，良好的响应速度能提升用户体验。</p>
<p>目前很大一部分的java应用集中在互联网或者B/S架构系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停段时间最短，以给用户较好的体验感。</p>
<p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会STW。</strong></p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Parial收集器中的一个。</p>
<p>在G1出现之前，CMS还是非常广泛的，一直到今天，仍然有许多系统使用CMS GC。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/XZSksi.jpeg" alt="img"></p>
<p>2）CMS工作流程</p>
<p><strong>初始标记</strong>：标记出GCROOTS能直接关联到的对象（速度快）</p>
<p><strong>并发标记</strong>：从GCROOTS的直接关联对象开始遍历整个对象图的过程（耗时长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行）</p>
<p><strong>重新标记</strong>：修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（时间比初始标记稍微长）</p>
<p><strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。（由于不需要移动存活的对象，所以这个阶段也是可以与用户线程并发执行的）</p>
<p>初始化标记和再次标记仍然要STW机制，目前所有的来收集器都做不到完全不需要STW，只是尽可能的缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>在CMS回收过程中，还应该确保应用程序线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序在运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动预备方案，临时启动Serial Old收集器来重新收集老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS的垃圾收集算法使用的是标记清除算法，不可避免的会产生内存碎片，无法使用指针碰撞，只能选择空闲列表。</p>
<p>标记清除算法会造成内存碎片，为什么不把算法换成标记整理算法呢？</p>
<p>因为当并发清除时，用标记整理算法整理内存的话，原来的用户线程使用的内存无法继续使用，要保证用户线程还能继续执行，前提是他运行的资源不受影响。</p>
<p>优点：并发收集，低延迟</p>
<p>缺点：会产生内存碎片，对CPU资源敏感（并发阶段，占用了一部分线程导致应用程序变慢，总吞吐量降低），无法处理浮动垃圾（在并发阶段如果产生新的垃圾对象，CMS无法对这些垃圾对象进行标记，最终会导致这些新产生 的垃圾对象没有及时回收，只能在下一次GC的时候释放这些之前未被回收的内存空间）</p>
<p>3）参数设置</p>
<p><code>-XX:+UseConcMarkSweepGC</code>  手动指定使用CMS收集器执行内存回收任务</p>
<p><code>-XX:CMSlnitiatingOccupanyFraction</code> 设置堆使用率的阈值，一旦达到阈值，便开始垃圾回收</p>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>  用于指定在执行完<code>Full GC</code>后堆内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的的问题就是停顿时间变得更长了。</p>
<p><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置在执行了多少次Full GC后对内存进行压缩整理。</p>
<p><code>-XX:ParallelCMSThreads</code>  设置CMS线程数。CMS默认启动线程数是 <code>（ParallelGCThreads+3）/4</code>，<code>ParallelGCThreads</code> 是年轻代并行收集器的线程数。当CPU资源紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收节点可能会非常糟糕。</p>
<p>4）小技巧</p>
<p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC，Parallel GC，Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<p>最小化的使用内存和并行开销 Serial GC</p>
<p>最大化应用程序的吞吐量 Parallel GC</p>
<p>最小化GC的中断或停顿时间 CMS GC</p>
<p>5）后续版本变化</p>
<p>JDK9 声明CMS为过时，JDK14直接删掉了，如果使用不会报错，只是会给出警告，并使用默认的垃圾收集器。</p>
<h2 id="68-G1回收器（区域分代化）"><a href="#68-G1回收器（区域分代化）" class="headerlink" title="68.G1回收器（区域分代化）"></a>68.G1回收器（区域分代化）</h2><p>1）概述</p>
<p>G1是在java7引入的垃圾回收器，为了适应不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量。</p>
<p>为什么叫G1回收器？</p>
<p>因为G1是一个并行回收器，他把堆内存分割成很多不相关的区域。G1有计划的避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个区域里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间，所以我们给G1一个名字，垃圾优先。</p>
<p>G1主要针对配备多核CPU以及大容量内存的机器，是JDK9以后的默认垃圾回收器，在JDK8还不是默认的垃圾回收器，需要使用<code>-XX:UseGmentGC</code>来启用。</p>
<p>与其他垃圾回收器相比，G1使用了全新的分区算法：</p>
<p>2）特点</p>
<p>①并行与并发</p>
<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</p>
<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会再整个回收阶段发生完全阻塞应用程序的情况。</p>
<p>②分代收集</p>
<p>从分代上看，G1依然属于分代型垃圾回收器，他会区分年轻代和老年代，年轻代依然有Eden区和幸存者区。但从堆的结构上看，他不要求整个Eden区，年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
<p>将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代。</p>
<p>和之前的各类回收器不同，他同时兼顾年轻代和老年代。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/xxnV8p.jpeg" alt="img"></p>
<p>③空间整合</p>
<p>CMS：标记清除算法，内存碎片，若干次GC后进行一次碎片整理。</p>
<p>G1将内存划分为一个个小区域，内存的回收是以一个个小区域为单位的。区域之间是复制算法，但是整体上可以看成标记压缩算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当java堆非常大的时候，G1的优势更加明显。</p>
<p>④可预测的停顿时间</p>
<p>每次根据允许的收集时间，优先回收价值最大的区域，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>3）缺点</p>
<p>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高。</p>
<p>经验上来讲：在小内存应用上CMS的表现大概率会优先于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8G之间。</p>
<p>4）参数设置</p>
<p><code>-XX:+UseG1GC</code> 手动指定使用G1垃圾收集器执行内存回收任务</p>
<p><code>-XX:G1HeapRegionSize</code> 设置每个区域的大小。值是2的幂，范围是1M-32M之间。</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标</p>
<p><code>-XX:ParallelGCThread</code> 设置STW工作线程数，最多设置为8</p>
<p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数</p>
<p><code>-XX:InitiatingHeapOccupancyPercent</code>  设置触发并发GC周期的java堆占用率阈值。超过此值，就会出发GC。</p>
<p>5）G1调优的步骤</p>
<p>开启垃圾收集器</p>
<p>设置堆的最大内存</p>
<p>设置最大停顿时间</p>
<p>G1提供了三种垃圾收集模式：YoungGC，Mixed GC和Full GC，在不同的条件下被触发。</p>
<p>6）适用场景</p>
<p>面向服务端应用，针对具有大内存，多处理器的机器</p>
<p>需要低GC延迟，并具有大堆的应用程序提供解决方案</p>
<p>用来替换掉jdk5的cms</p>
<p>HotSpot垃圾收集器，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾收集过程。</p>
<p>所有的区域都大小相同，并且在JVM生命周期内不会被改变，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离了，他们都是一部分区域的集合。通过区域的动态分配的方式实现逻辑上的连续。</p>
<p>7）Humongous</p>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous，主要存储大对象，如果超过1.5个区域，就放到H。</p>
<p>设置H的原因：对于堆中的大对象，默认直接会被分配到老年代，但是如果他是一个短期的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个H区，他专门用来存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p>8）回收过程</p>
<p>G1 GC的垃圾回收过程主要包括如下三个环节</p>
<p>年轻代GC</p>
<p>老年代并发标记过程</p>
<p>混合回收</p>
<p>如果需要，单线程，独占式，高强度的Full GC还是继续存在的。他针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/Fym41H.png" alt="image-20241224145938114"></p>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年代区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值的时候，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的区域就可以了。同时，这个老年代的区域是和新生代一起被回收的。</p>
<p>①记忆集与写屏障</p>
<p>一个对象被不同区域引用的问题</p>
<p>一个区域不可能是孤立的，一个区域中的对象可能被其他任意区域中的对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题</p>
<p>回收新生代也不得不同时扫描老年代？</p>
<p>这样的话会降低Minor GC的效率</p>
<p><strong>解决方法</strong></p>
<p>无论G1还是其他垃圾收集器，Jvm都是使用Remembered Set 来避免全局扫描。</p>
<p>每个区域都有一个对应的Remembered Set ；</p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的区域</p>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在区域对应的Remembered Set 中；</p>
<p>当进行垃圾收集时，在GC跟节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p>②年轻代GC</p>
<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收Eden区和幸存者区。</p>
<p>首先G1停止应用程序的执行，G1创建回收集，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和幸存者区所有的内存字分段。然后开始进行如下回收：扫描根  更新RSet  处理RSet  复制对象  处理引用</p>
<p>第一阶段，扫描根。</p>
<p>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，更新RSet。</p>
<p>处理dirty card queue( 见备注)中的card，更新RSet。 此阶段完成后，RSet可 以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>第三阶段，处理RSet.</p>
<p>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。第四阶段，复制对象。</p>
<p>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 01d区中空的内存分段。如果Survivor空间不够，Eden空 间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段，处理引用。</p>
<p>处理Soft，Weak，Phantom, Final, JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<p>②并发标记过程</p>
<p>初始标记阶段  根区域扫描  并发标记  再次标记  独占标记  独占清理  并发清理阶段</p>
<p>1.初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发- - 次年轻代GC。</p>
<p>2.根区域扫描(Root Region Scanning) : G1 GC扫描Survivor区直接可达的老年代， 区域对象，并标记被引用的对象。这一-过程必须在young GC之前完成。</p>
<p>3.并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)， 此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p>4.再次标记(Remark):由 于应用程序持续进行，需要修正上一- 次的标记结果。是STW 的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5.独占清理(cleanup,STW):计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。</p>
<p>➢这个阶段并不会实际上去做垃圾的收集。</p>
<p>6.并发清理阶段:识别并清理完全空闲的区域。</p>
<p>③混合回收</p>
<p>当越来越多的对象晋升到老年代，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集。从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次(可以通过<code>-XX: G1MixedGCCountTarget</code>设置)被回收。</p>
<p>混合回收的回收集(Collection Set)包括八分之- -的老年代内存分段，Eden区 内存 分段，Survivor区 内存分段。混合回收的算法和年轻代回收的算法完全一样， 只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p>
<p>④Full GC</p>
<p>G1的初衷就是要避免Full GC的出现，但是如果上述方式不能正常工作，G1会停止应用程序的执行，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况下可以通过增大内存解决。</p>
<p>导致G1Full GC的原因可能有两个</p>
<p>Evacuation的时候没有足够的to-space来存放晋升的对象    并发处理过程完成之前空间耗尽</p>
<p>⑤G1回收器优化建议</p>
<p><strong>年轻代大小</strong></p>
<p>避免使用-Xmn或者-XX:NewRatio等相关选项显式设置年轻代的大小</p>
<p>固定年轻代的大小会覆盖暂停时间目标</p>
<p><strong>暂停时间目标不要太过严苛</strong></p>
<p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p>
<p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
<h2 id="69-垃圾回收器总结"><a href="#69-垃圾回收器总结" class="headerlink" title="69.垃圾回收器总结"></a>69.垃圾回收器总结</h2><p>1）对比</p>
<table>
<thead>
<tr>
<th>垃圾收集器</th>
<th>分类</th>
<th>作用位置</th>
<th>使用算法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU的server模式与CMS配合使用</td>
</tr>
<tr>
<td>Parallel</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记压缩</td>
<td>响应速度优先</td>
<td>单CPU的client模式</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记压缩</td>
<td>吞吐量优先</td>
<td>后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记清除</td>
<td>响应速度优先</td>
<td>互联网/BS业务</td>
</tr>
<tr>
<td>G1</td>
<td>并发，并行</td>
<td>新生代，老年代</td>
<td>标记压缩，复制</td>
<td>响应速度优先</td>
<td>服务端应用</td>
</tr>
</tbody></table>
<p>GC发展阶段 Serial =&gt; Parallel(并行) =&gt;CMS(并发)=&gt;G1=&gt;ZGC</p>
<p>2）垃圾回收器的组合</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/qgBfVu.png" alt="image-20241224145644315"></p>
<p>3）怎么选择垃圾回收器？</p>
<p>1.优先调整堆的大小让JVM自适应完成</p>
<p>2.如果内存小于100M，使用串行收集器</p>
<p>3.如果是单核，单机程序，并且没有停顿时间的要求，串行收集器</p>
<p>4.如果是多CPU，需要高吞吐量，允许停顿时间超过1s，选择并行或者JVM自己选择</p>
<p>5.如果是多CPU，追求低停顿时间，需快速响应，使用并发收集器</p>
<p><strong>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1.</strong></p>
<p>没有最好的收集器，调优是针对特定场景，特定需求。</p>
<h2 id="70-CMS运行过程，缺点？"><a href="#70-CMS运行过程，缺点？" class="headerlink" title="70.CMS运行过程，缺点？"></a>70.CMS运行过程，缺点？</h2><p>整个过程分为四个步骤</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/wCHQlR.jpg" alt="image"></p>
<ol>
<li><strong>初始标记(STW)：</strong> 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程，因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记(STW)：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>对CPU资源敏感（会和服务抢资源）</li>
<li>无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>并发模式失败(最大问题)，执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”concurrent mode failure”，此时会进入stop the world，用serial old垃圾收集器来回收</li>
</ol>
<h2 id="71-G1运行过程"><a href="#71-G1运行过程" class="headerlink" title="71.G1运行过程"></a>71.G1运行过程</h2><p>G1收集器一次GC的运作过程大致分为以下几个步骤：</p>
<ol>
<li>初始标记（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ；</li>
<li>并发标记（Concurrent Marking）：同CMS的并发标记</li>
<li>最终标记（Remark，STW）：同CMS的重新标记</li>
<li>筛选回收（Cleanup，STW）：G1采用复制算法回收几乎不会有太多内存碎片</li>
</ol>
<h2 id="72-G1适合什么场景"><a href="#72-G1适合什么场景" class="headerlink" title="72.G1适合什么场景"></a>72.G1适合什么场景</h2><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h2 id="73-什么情况下会触发Full-GC？"><a href="#73-什么情况下会触发Full-GC？" class="headerlink" title="73.什么情况下会触发Full GC？"></a>73.什么情况下会触发Full GC？</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p>
<ul>
<li><strong>调用 System.gc()</strong></li>
</ul>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<ul>
<li><strong>老年代空间不足</strong></li>
</ul>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<ul>
<li><strong>空间分配担保失败</strong></li>
</ul>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>
<ul>
<li><strong>JDK 1.7 及以前的永久代空间不足</strong></li>
</ul>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<ul>
<li><strong>Concurrent Mode Failure</strong></li>
</ul>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h2 id="74-内存溢出与内存泄漏"><a href="#74-内存溢出与内存泄漏" class="headerlink" title="74.内存溢出与内存泄漏"></a>74.内存溢出与内存泄漏</h2><p>1）内存溢出</p>
<p>内存溢出是相对于内存泄漏来说的，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。大多数情况下，GC会进行各种年龄段的垃圾回收实在不行了就放大招，来一次Full GC操作，这时候会回收大量内存，供应用程序继续使用。javadoc对OOM的解释是：没有空闲内存，并且垃圾收集器也无法提供更多内存。</p>
<p>堆内存不够的原因有两个：java虚拟机的堆内存设置不够。代码中创建了大量的大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
<p>OOM之前，通常垃圾收集器会先进行GC，当然也不是任何情况下垃圾收集器都会被触发：比如我们创建一个超过堆空间大小的对象。</p>
<p>2）内存泄漏</p>
<p>只有对象不在被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。实际上一些导致对象生命周期变得很长甚至OOM的操作，也称为内存泄漏。</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OOM，导致程序崩溃。</p>
<p>这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存取决于磁盘交换区设定的大小。</p>
<p>Example：</p>
<p>1.单例模式，单例的生命周期默认和应用程序一样长，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，否则会导致内存泄漏的产生。</p>
<p>2.一些提供close的资源未关闭导致内存泄漏（数据库连接，网络连接，io连接）</p>
<h2 id="75-Stop-The-World"><a href="#75-Stop-The-World" class="headerlink" title="75.Stop The World"></a>75.Stop The World</h2><p>指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被停掉，没有任何响应。</p>
<p>STW事件和采用哪款垃圾收集器无关，所有GC都有这个事件。它是由JVM在后台自动发起和自动完成的。</p>
<h2 id="76-安全点与安全区域"><a href="#76-安全点与安全区域" class="headerlink" title="76.安全点与安全区域"></a>76.安全点与安全区域</h2><p>1）安全点</p>
<p>程序执行过程中并不是在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为安全点。</p>
<p>安全点太少可能导致GC等待时间太长，太多可能导致程序运行时的性能问题。</p>
<p>方法调用，循环跳转，异常跳转。</p>
<p>如何在GC发生时，检查所有线程都跑到最近的安全点停下来呢？</p>
<p><strong>抢先式中断</strong>（目前没有虚拟机采用了）中断所有线程，哪个没到安全点就恢复线程，让线程跑到安全点。</p>
<p><strong>主动式中断</strong>设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
<p>2）安全区域</p>
<p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入的GC安全点，但是假如程序处于sleep状态，这时候线程无法响应jvm的中断请求，走到安全点去中断挂起，jvm也不太可能的等待线程被唤醒。对于这种情况，就需要安全区域来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</p>
<p>实际执行时</p>
<p>当线程运行到安全区域的代码时，首先标识已经进入了安全区域，如果这段时间内发生GC，JVM会忽略标识为安全区域状态的线程。</p>
<p>当线程即将离开安全区域时，会检查jvm是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开安全区域的信号为止。</p>
<h2 id="77-再谈内存泄漏"><a href="#77-再谈内存泄漏" class="headerlink" title="77.再谈内存泄漏"></a>77.再谈内存泄漏</h2><p>1）内存泄露的理解与分析</p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题(让JVM误以为此对象还在引用中，无法回收，造成内存泄漏)。</p>
<p>是否还被使用? 是</p>
<p>是否还被需要? 否</p>
<p>内存泄漏(memory leak) 的理解</p>
<p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p>
<p>但实际情况很多时候一些不太好的实践(或疏忽)会导致对象的生命周期变得很长甚至导致0OM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/tkMTjm.png" alt="image-20241224155604073"></p>
<p>对象X引用对象Y,X的生命周期比Y的生命周期长;</p>
<p>那么当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的;</p>
<p>如果对象X还引用着生命周期比较短的A、B、C,对象A又引用着对象a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p>内存泄漏与内存溢出的关系:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.内存泄漏(memory leak )</span><br></pre></td></tr></table></figure>

<p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M 的内存一-直不回收，那么可以 用的内存只有512M 了，仿佛泄露掉了一部分;</p>
<p>通俗一点讲的话，内存泄漏就是[占着茅坑不拉shi]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.内存溢出(out of memory )</span><br></pre></td></tr></table></figure>

<p>申请内存时，没有足够的内存可以使用;</p>
<p>通俗一点儿讲，-一个厕所就三个坑，有两个站着茅坑不走的(内存泄漏)，剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位(内存)就不够了，内存泄漏变成内存溢出了。</p>
<p>可见，内存泄漏和内存溢出的关系:内存泄漏的增多，最终会导致内存溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泄漏的分类</span><br></pre></td></tr></table></figure>

<p>经常发生:发生内存泄露的代码会被多次执行，每次执行，泄露一块内存;</p>
<p>偶然发生:在某些特定情况下才会发生</p>
<p>一次性:发生内存泄露的方法只会执行一次;</p>
<p>隐式泄漏:一 直占着内存不释放，直到执行结束;严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p>
<p>2）Java中内存泄露的8种情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-静态集合类</span><br></pre></td></tr></table></figure>

<p>静态集合类，如HashMap、 LinkedList等等。 如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2-单例模式</span><br></pre></td></tr></table></figure>

<p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和JVM的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3-内部类持有外部类</span><br></pre></td></tr></table></figure>

<p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。</p>
<p>这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4-各种连接，如数据库连接、网络连接和IO连接等</span><br></pre></td></tr></table></figure>

<p>各种连接，如数据库连接、网络连接和IO连接等。</p>
<p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。</p>
<p>否则，如果在访问数据库的过程中，对Connection、 Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5-变量不合理的作用域</span><br></pre></td></tr></table></figure>

<p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null,很有可能导致内存泄漏的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6-改变哈希值</span><br></pre></td></tr></table></figure>

<p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是String为什么被设置成了不可变类型，我们可以放心地把String 存入HashSet,或者把 String当做HashMap 的key值;</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的hashCode不可变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">例<span class="number">2</span>：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示内存泄漏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeHashCode1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> HashSet&lt;Point&gt;();</span><br><span class="line">        Point cc = <span class="keyword">new</span> Point();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Point other = (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7-缓存泄露</span><br></pre></td></tr></table></figure>

<p>内存泄漏的另一个常见来源是缓存，- -旦你把对象引用放入到缓存中，他就很容易遗忘。比如:之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载-个表中的数据到缓存(内存)中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map wMap = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">    <span class="keyword">static</span> Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ref1 = <span class="keyword">new</span> String(<span class="string">&quot;obejct1&quot;</span>);</span><br><span class="line">        String ref2 = <span class="keyword">new</span> String(<span class="string">&quot;obejct2&quot;</span>);</span><br><span class="line">        String ref3 = <span class="keyword">new</span> String(<span class="string">&quot;obejct3&quot;</span>);</span><br><span class="line">        String ref4 = <span class="keyword">new</span> String(<span class="string">&quot;obejct4&quot;</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);</span><br><span class="line">        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);</span><br><span class="line">        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/oWfe4u.jpeg" alt="img"></p>
<p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函 数执行完成后，局部变量字 符串引用weakd1 ,weakd2,d1,d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以 看到，调用gc之后，HashMap的没有被回收，而WeakHashMap 里面的缓存被回收了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8-监听器和回调</span><br></pre></td></tr></table></figure>

<p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p>
<p>3）内存泄露案例分析</p>
<p>①代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123; <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②分析</p>
<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在pop函数，下面通过这张图示展现</p>
<p>假设这个栈- -直增长，增长后如下图所示</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/pnEJRU.png" alt="image-20241224155438585"></p>
<p>当进行大量的POP操作时，由于引用未进行置空，gc是不会释放的，如下图所示：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/U3liR7.png" alt="image-20241224155410221"></p>
<p>从上图可以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些对象，他们也不会回收，因为栈中仍然保存这对象的引用，这个内存泄漏很隐蔽。</p>
<p>③解决办法</p>
<p>将代码中的pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elements[--size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/Ch5vZD.png" alt="image-20241224155345034"></p>
<h2 id="78-判断元空间是无用的类"><a href="#78-判断元空间是无用的类" class="headerlink" title="78.判断元空间是无用的类"></a>78.判断元空间是无用的类</h2><p>法区（元空间）主要回收的是无用的类，那么如何判断一个类是无用的类呢？类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。（条件苛刻，自定义类加载器会被回收掉）</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="79-创建对象的几种方式"><a href="#79-创建对象的几种方式" class="headerlink" title="79.创建对象的几种方式"></a>79.创建对象的几种方式</h2><p>1）new</p>
<p>new（直接new ，工厂模式，构建者模式）</p>
<p>2）Class.forName().newInstance()</p>
<p>反射的方式，只能调用空参构造器，权限是public</p>
<p>3）Constructor.newInstance(xxx)</p>
<p>反射的方式，可以调用空参，带参的构造器，权限没要求</p>
<p>4）使用clone（）</p>
<p>不调用任何构造器，当前需要实现Cloneable接口，实现clone（）；分为深克隆和浅克隆  对象嵌套</p>
<p>5）使用反序列化</p>
<p>从文件，网络中获取一个对象的二进制流</p>
<p>6）第三方库Objenesis</p>
<h2 id="80-对象访问定位"><a href="#80-对象访问定位" class="headerlink" title="80.对象访问定位"></a>80.对象访问定位</h2><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p>定位，通过栈上reference访问。创建对象的目的是为了使用它。对象访问方式主要有两种：</p>
<p>1）句柄访问</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/B5G9am.png" alt="image-20241224155807589"></p>
<p>优点：引用中存储稳定句柄地址，对象被移动时只会改变句柄中实例数据指针即可，引用本身不需要被修改。</p>
<p>缺点：需要额外维护一个句柄，效率低。</p>
<p>2）直接指针(HotSpot采用)</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/iyABm8.jpeg" alt="img"></p>
<p>优点：效率高</p>
<h2 id="81-永久代为什么要被元空间替换？"><a href="#81-永久代为什么要被元空间替换？" class="headerlink" title="81.永久代为什么要被元空间替换？"></a>81.永久代为什么要被元空间替换？</h2><p>以前使用虚拟机内存，现在使用本地内存</p>
<p>①为永久代设置空间大小很难确定</p>
<p>②对永久代调优困难</p>
<p>方法区的垃圾收集主要分两部分</p>
<p>常量池中废弃的常量和不再使用的类型</p>
<h2 id="82-方法区的内部结构"><a href="#82-方法区的内部结构" class="headerlink" title="82.方法区的内部结构"></a>82.方法区的内部结构</h2><p>尽管所有方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾回收或者压缩，对于hotspot而言，方法区还有一个别名叫非堆，目的就是要和堆分开。所以方法区可以看做是一块独立于java堆的内存空间。方法区与堆空间一样，是多线程共享的，方法区在jvm启动的时候被创建，并且他的实际物理内存空间中和java堆区一样都可以是物理上不连续的。方法区的大小和堆一样可以选择固定大小和扩展。方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会OOM。关闭jvm就会释放这个区域的内存。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/W3xizJ.png" alt="image-20241224160725192"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/PMkm5Q.png" alt="image-20241224160746817"></p>
<p>他用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等。</p>
<p>1）类型信息</p>
<p>对每个加载的类型，jv必须在方法区存储一下类型信息。</p>
<p>全限定类名，直接父类的全限定类名，这个类型的修饰符，这个类型直接接口的一个有序列表</p>
<p>2）域信息</p>
<p>jvm必须在方法区中保存类型的所有域的信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称，域类型，域修饰符。</p>
<p>3）方法信息</p>
<p>jvm必须保存所有方法的以下信息，同域信息一样包括声明顺序</p>
<p>方法名称，返回类型，参数的数量和类型，顺序，方法的修饰符，方法的字节码，操作数栈，局部变量表以及大小，异常表</p>
<p>每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-12:09</span></span><br><span class="line"><span class="comment"> * 1.静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分。</span></span><br><span class="line"><span class="comment"> * 2.类变量被类的所有实例共享，即使没有实例时你也可以放问他。</span></span><br><span class="line"><span class="comment"> * 3.全局常量 static final</span></span><br><span class="line"><span class="comment"> * 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</span></span><br><span class="line"><span class="comment"> *图：final-static</span></span><br><span class="line"><span class="comment"> * javap -v Order.class</span></span><br><span class="line"><span class="comment"> * javap -v  -p DemoE.class &gt; DemoE.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order=<span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a+<span class="string">&quot;----&quot;</span>+<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/l2fAui.jpeg" alt="img"></p>
<p>4）class文件中常量池的理解</p>
<p>方法区内部包含了运行时常量池，字节码文件内部包含了常量池。</p>
<p>为什么需要常量池？</p>
<p>java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用，在动态链接的时候就会用到运行时常量池。</p>
<p>一个有效的字节码文件中除了包含类的版本信息，字段，方法以及接口等描述信息外，还包含一项信息那就是常量池表，包含各种字面量和对应类型，域和方法的符号引用。</p>
<p>总结：常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。</p>
<p>5）运行时常量池</p>
<p>方法区的一部分，class文件的常量池被类加载器加载到运行时数据区就会在方法区生成对应的运行时常量池，JVM为每一个已经加载的类或接口都维护了一个常量池。池子中的数据就像数组一样，都是通过索引访问的，运行时常量池包括多种不同的变量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换位真实地址。</p>
<p>运行时常量池动态性，当创建类或者接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则会OOM。</p>
<h2 id="83-图解常量池操作"><a href="#83-图解常量池操作" class="headerlink" title="83.图解常量池操作"></a>83.图解常量池操作</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/FDbea1.png" alt="image-20241224160825218"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoE</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a=x/y;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时常量池</p>
<p>运行时常量池是方法区的一部分。</p>
<p>常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<h2 id="84-方法区的垃圾回收"><a href="#84-方法区的垃圾回收" class="headerlink" title="84.方法区的垃圾回收"></a>84.方法区的垃圾回收</h2><p>1.一般来说，方法区的回收效果不好，特别是类型的卸载，但是有时候回收又是必要的</p>
<p>2.方法区的垃圾回收主要是两部分：废弃的常量和不再使用的类型</p>
<p>3.方法区常量池主要存放：字面量和符号引用</p>
<p><strong>符号引用包括：1.类和接口的全限定类名2.字段的名称和描述符3.方法的名称和描述符</strong></p>
<p>4.只要常量池中的常量没有被任何地方引用，就可以被回收</p>
<p>5.判断一个类是否可以被回收</p>
<p>1.该类所属的实例都已经被回收</p>
<p>2.加载该类的类加载器已经被回收</p>
<p>3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的对象</p>
<h2 id="85-直接内存"><a href="#85-直接内存" class="headerlink" title="85.直接内存"></a>85.直接内存</h2><p>不是虚拟机运行时数据区的一部分，也不是jvm规范中定义的内存区域。</p>
<p>直接内存是在java堆外，直接向系统申请的内存空间。</p>
<p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存，通常，访问直接内存的速度会优于java堆，即读写性能高，因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存，java的NIO库允许java程序使用直接内存，用于数据缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoH</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer BUFFER=<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ByteBuffer byteBuffer=ByteBuffer.allocate(BUFFER);</span><br><span class="line">        sc.next();</span><br><span class="line">        byteBuffer=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可能导致OOM异常，由于直接内存在java堆外，因此它的大小不会受限于-Xmx指定的最大堆的大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<p>缺点：分配回收成本高，不受JVM内存回收管理，直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致，简单理解java进程内存=java堆+本地内存。</p>
<h2 id="86-静态变量放在哪里"><a href="#86-静态变量放在哪里" class="headerlink" title="86.静态变量放在哪里"></a>86.静态变量放在哪里</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-08-20-15:38</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 1.new出来的结构，也就是对象实例都在堆空间</span></span><br><span class="line"><span class="comment"> * 2.1.6：obj1随着DemoG的类型信息放在方法区；1.7：放在堆空间</span></span><br><span class="line"><span class="comment"> * 3.obj2是实例变量，在堆空间</span></span><br><span class="line"><span class="comment"> * 4.obj3在foo方法对应的栈帧的局部变量表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Order obj1=<span class="keyword">new</span> Order(); <span class="comment">//jdk7以前放在永久代，7开始放在堆空间</span></span><br><span class="line">        Order obj2=<span class="keyword">new</span> Order(); <span class="comment">//实例变量  堆空间</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123; </span><br><span class="line">            Order obj3=<span class="keyword">new</span> Order();  <span class="comment">//方法内部局部变量   栈帧里面的局部变量表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="87-执行引擎"><a href="#87-执行引擎" class="headerlink" title="87.执行引擎"></a>87.执行引擎</h2><p>1.虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面的，而虚拟机的执行引擎是由软件自行实现的，因此可以不受物理条件制约的定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/wEYnMw.jpeg" alt="img"></p>
<p>2.jvm的主要作用负责装在字节码到其内部，但是字节码不能直接运行在操作系统之上，执行引擎就是将字节码指令编译为对应平台上的本地机器指令。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/h585Do.png" alt="image-20241224161931765"></p>
<p>3.外观上看：jvm的执行引擎输入输出都是一致的，输入的是字节码二进制流，处理过程是字节码解析执行的过程，输出的是执行结果。</p>
<h2 id="88-java代码的编译和执行过程"><a href="#88-java代码的编译和执行过程" class="headerlink" title="88.java代码的编译和执行过程"></a>88.java代码的编译和执行过程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/xi9Pyw.png" alt="image-20241224161725266"></p>
<p>大部分的程序代码转换为物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图的步骤。</p>
<p>为什么java称为半解释型半编译型语言？</p>
<p>因为jvm的执行引擎是解释器和jit即时编译器交互工作的。</p>
<p>什么是解释器？什么是JIT编译器？</p>
<p>解释器：将字节码指令逐行翻译成机器指令并执行</p>
<p>编译器：将源代码直接编译成对应的机器指令。</p>
<h2 id="89-JIT即时编译器"><a href="#89-JIT即时编译器" class="headerlink" title="89.JIT即时编译器"></a>89.JIT即时编译器</h2><p><strong>HotSpot采用解释器与即时编译器共存的架构。由JVM决定何时使用哪种方式执行。</strong></p>
<p>解释器可以边解释边执行，这样程序启动时间就会变快，及时编译器是都编译好了在执行，程序启动时间慢。但是一旦jit编译器把越来越多的代码编译成本地代码，执行效率立马起飞。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202412/24/wVpbli.png" alt="image-20241224161838775"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202204/08/rlYdQt.jpeg" alt="img"></p>
<p>1）热点代码以及探测方式</p>
<p>判断是否启动jit编译器将字节码直接编译为对应平台的本地机器指令，需要根据执行的频率而定。热点代码就是需要被编译为本地代码的字节码，jit在运行时会针对频繁调用的热点代码直接编译为对应平台的本地机器指令，提升性能。</p>
<p>2）OSR编译</p>
<p>一个方法被多次调用，或者一个方法体内部循环次数较多的循环体都可以被称为热点代码，因此都可以通过jit编译器编译为本地机器指令，也就是栈上替换.hotspot采用的热点探测方式是基于计数器的热点探测。</p>
<p>为每个方法建立2个不同类型的计数器，分别为方法调用计数器和回边计数器</p>
<p>1.方法调用计数器：统计方法调用次数，默认client模式下1500，server模式下100002.回边计数器：统计循环执行次数</p>
<p>当一个方法被调用时，先判断有没有jit编译过，有的话直接使用jit编译后的机器指令，没有的话计数器+1，然后判断两个计数器之和是否超过方法调用计数器的阈值。如果超过，就会向jit发出即时编译申请。</p>
<p>热度衰减是在虚拟机进行垃圾回收的时候顺便进行的，也就是在一段时间方法一直没有执行，计数器的计数就会减半。</p>
<p>可以自己手动设置虚拟机采用哪种编译模式</p>
<p>3）JDK9引入了AOT编译器</p>
<p>aot编译器在程序执行之前，就将字节码转换为机器码过程。</p>
<p>好处：可以直接运行，不必预热。</p>
<p>坏处：由于提前编译成了机器指令，无法实现java一次编译到处运行。</p>
<p>4）JDK10的Graal编译器</p>
<p>全新的即时编译器，实验阶段，需要手动开启，前景大好</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/">https://zhangxin66666.github.io/2024/12/23/3.jvm/面试-JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/%E9%9D%A2%E8%AF%95.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/"><img class="prev-cover" src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis面试</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/22/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"><img class="next-cover" src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ConcurrentHashMap源码解读</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.jvm内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-PC%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A2%AB%E8%AE%BE%E5%AE%9A%E4%B8%BA%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-text">2.PC寄存器为什么会被设定为线程私有的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89%EF%BC%9F"><span class="toc-text">3.什么是虚拟机栈（线程私有）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89%EF%BC%9F"><span class="toc-text">4.什么是本地方法栈（线程私有）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89%EF%BC%9F"><span class="toc-text">5.什么是方法区（线程共享）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-text">6.栈、堆、方法区的交互关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A0%86%E5%8C%BA%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%86%E5%88%86%E7%9A%84%EF%BC%9F"><span class="toc-text">7.堆区内存是怎么细分的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-JVM%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">8.JVM中对象在堆中的生命周期?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JVM%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">9.JVM中对象的分配过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">10.静态变量与局部变量的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">11.方法重写的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">12.对象创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-text">13.对象分配过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">14.类的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">15.类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">16.JVM类加载机制有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">17.双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">18.破坏双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">19.热替换的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Class-forName-%E5%92%8CClassLoader-loadClass-%E5%8C%BA%E5%88%AB"><span class="toc-text">20.Class.forName()和ClassLoader.loadClass()区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%BB%80%E4%B9%88%E6%98%AF-TLAB-%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89"><span class="toc-text">21.什么是 TLAB （Thread Local Allocation Buffer）?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-TLAB"><span class="toc-text">22.为什么要有 TLAB ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-ClassLoader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">23.ClassLoader源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89ClassLoader%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">1）ClassLoader的主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0loadClass-%E7%9A%84%E5%89%96%E6%9E%90"><span class="toc-text">①loadClass()的剖析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89SecureClassLoader%E4%B8%8EURLClassLoader"><span class="toc-text">2）SecureClassLoader与URLClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89ExtClassLoader%E4%B8%8EAppClassLoader"><span class="toc-text">3）ExtClassLoader与AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89Class-forName%E4%B8%8EClassLoader-loadClass"><span class="toc-text">4）Class.forName与ClassLoader.loadClass()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">24.类加载器Java9新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E4%B8%A4%E7%A7%8D%E7%B1%BB%E8%A3%85%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-text">25.两种类装载方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">26.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">27.对象创建的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">28.为对象分配内存两种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">29.对象的创建过程中处理并发安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">30.介绍一下强引用、软引用、弱引用、虚引用的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-text">31.怎么判断对象是否可以被回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%9C%A8Java%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">32.在Java中，对象什么时候可以被垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A0%86%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%88%86%E4%BB%A3"><span class="toc-text">33.JVM 运行时堆内存如何分代?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-JVM%E5%86%85%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E6%88%90%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E6%8C%81%E4%B9%85%E4%BB%A3%E3%80%82%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BAEden%E5%92%8CSurvivor"><span class="toc-text">34.JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%B8%BAEden%E5%92%8CSurvivor-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA%EF%BC%9F"><span class="toc-text">35.为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-JVM%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84GC%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87%E5%88%B0%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">36.JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-JVM%E4%B8%AD%E7%9A%84%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97"><span class="toc-text">37.JVM中的永久代中会发生垃圾回收吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-JAVA8-%E4%B8%8E%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">38.JAVA8 与元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-text">39.如何判断对象可以被回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">40.引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">41.可达性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-Minor-GC%E4%B8%8EFull-GC%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-text">42.Minor GC与Full GC分别在什么时候发生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">43.标记清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">44.标记整理算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">45.复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">46.分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">47.增量收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">48.分区算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-text">55.垃圾判断算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%9C%A8java%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8CGC-ROOTS-%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%B1%BB%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-text">56.在java语言中，GC ROOTS 包括以下几类元素：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-Minor-GC-Major-GC-fULL-GC"><span class="toc-text">57.Minor GC,Major GC,fULL GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%AD%96%E7%95%A5%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">58.分代式GC策略触发条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E4%BB%8E%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">59.从逃逸分析角度分析对象内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-%E4%BD%BF%E7%94%A8%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%A0%86%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">60.使用逃逸分析堆代码进行优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%88%86%E7%B1%BB"><span class="toc-text">61.垃圾回收分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-text">62.评估GC的性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">63.不同的垃圾回收器概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-Serial-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%89"><span class="toc-text">64.Serial 回收器（串行回收器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-text">65.ParNew回收器（并行回收）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-Parallel-Scavenge-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-text">66.Parallel Scavenge 回收器（吞吐量优先）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%89"><span class="toc-text">67.CMS回收器（低延迟）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%8C%BA%E5%9F%9F%E5%88%86%E4%BB%A3%E5%8C%96%EF%BC%89"><span class="toc-text">68.G1回收器（区域分代化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-text">69.垃圾回收器总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-CMS%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">70.CMS运行过程，缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-G1%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">71.G1运行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-G1%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-text">72.G1适合什么场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC%EF%BC%9F"><span class="toc-text">73.什么情况下会触发Full GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">74.内存溢出与内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-Stop-The-World"><span class="toc-text">75.Stop The World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-text">76.安全点与安全区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-%E5%86%8D%E8%B0%88%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">77.再谈内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%88%A4%E6%96%AD%E5%85%83%E7%A9%BA%E9%97%B4%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="toc-text">78.判断元空间是无用的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">79.创建对象的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">80.对象访问定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%A2%AB%E5%85%83%E7%A9%BA%E9%97%B4%E6%9B%BF%E6%8D%A2%EF%BC%9F"><span class="toc-text">81.永久代为什么要被元空间替换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">82.方法区的内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E5%9B%BE%E8%A7%A3%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">83.图解常量池操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">84.方法区的垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">85.直接内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-text">86.静态变量放在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">87.执行引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#88-java%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">88.java代码的编译和执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#89-JIT%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">89.JIT即时编译器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/" title="redis面试"><img src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis面试"/></a><div class="content"><a class="title" href="/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/" title="redis面试">redis面试</a><time datetime="2024-12-24T16:00:00.000Z" title="发表于 2024-12-25 00:00:00">2024-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/" title="JVM面试"><img src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM面试"/></a><div class="content"><a class="title" href="/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/" title="JVM面试">JVM面试</a><time datetime="2024-12-22T16:00:00.000Z" title="发表于 2024-12-23 00:00:00">2024-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/22/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读"><img src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap源码解读"/></a><div class="content"><a class="title" href="/2024/08/22/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/" title="ConcurrentHashMap源码解读">ConcurrentHashMap源码解读</a><time datetime="2024-08-22T03:23:14.702Z" title="发表于 2024-08-22 11:23:14">2024-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql执行流程"/></a><div class="content"><a class="title" href="/2022/04/02/7.mysql/mysql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" title="mysql执行流程">mysql执行流程</a><time datetime="2022-04-01T16:00:00.000Z" title="发表于 2022-04-02 00:00:00">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法"><img src="/images/cover/%E7%AE%97%E6%B3%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法"/></a><div class="content"><a class="title" href="/2022/03/31/2.%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法">数据结构和算法</a><time datetime="2022-03-30T16:00:00.000Z" title="发表于 2022-03-31 00:00:00">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>