<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis面试 | 金子爸爸の家</title><meta name="keywords" content="redis"><meta name="author" content="金子爸爸"><meta name="copyright" content="金子爸爸"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="redis常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="redis面试">
<meta property="og:url" content="https://zhangxin66666.github.io/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/index.html">
<meta property="og:site_name" content="金子爸爸の家">
<meta property="og:description" content="redis常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png">
<meta property="article:published_time" content="2024-12-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-03T11:56:20.959Z">
<meta property="article:author" content="金子爸爸">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangxin66666.github.io/images/cover/%E9%9D%A2%E8%AF%95.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://zhangxin66666.github.io/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-03 19:56:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">金子爸爸の家</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-24T16:00:00.000Z" title="发表于 2024-12-25 00:00:00">2024-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-03T11:56:20.959Z" title="更新于 2025-01-03 19:56:20">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h2><p>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(2)——sds" target="_blank">Redis内部数据结构详解(2)——sds</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(3)——robj" target="_blank">Redis内部数据结构详解(3)——robj</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a><br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(5)——quicklist" target="_blank">Redis内部数据结构详解(5)——quicklist</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(6)——skiplist" target="_blank">Redis内部数据结构详解(6)——skiplist</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(7)——intset" target="_blank">Redis内部数据结构详解(7)——intset</a></p>
<h2 id="2-数据结构-对象头RedisObject"><a href="#2-数据结构-对象头RedisObject" class="headerlink" title="2.数据结构-对象头RedisObject"></a>2.数据结构-对象头RedisObject</h2><p>16字节的存储空间</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/bJEfKW.png" alt="image-20250102202655892"></p>
<h2 id="3-数据结构-string"><a href="#3-数据结构-string" class="headerlink" title="3.数据结构-string"></a>3.数据结构-string</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/rjQfDK.png" alt="image-20250102202754751"></p>
<p>相比较于C语言中的字符串，头部信息里面包含了字符串的实际长度len，可以通过O（1）的时间复杂度得到</p>
<p>有点类似于Java中的ArrayList</p>
<p>数组长度和数组容量使用范型来定义是为了追求内存的极致优化，对于不同长度的字符串，底层采用不同类型的数据来保存，字符串比较短的时候，可以使用byte和short来表示。</p>
<h2 id="4-数据结构-string-三种底层编码方式"><a href="#4-数据结构-string-三种底层编码方式" class="headerlink" title="4.数据结构-string 三种底层编码方式"></a>4.数据结构-string 三种底层编码方式</h2><p>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(2)——sds" target="_blank">Redis内部数据结构详解(2)——sds</a></p>
<p>1).当存储的字符串全是数字的时候，此时使用int方式来存储</p>
<p>2).当存储的字符串长度小于等于44字符的时候，使用embstr方式来存储</p>
<p>对象头和SDS对象本身在内存中地址连续</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/Bg8xfb.png" alt="image-20250102202948214"></p>
<p>3).长度大于44字符时，采用raw方式存储</p>
<p>对象头和SDS对象本身在内存中地址不连续</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/02/pFNY9U.png" alt="image-20250102203002638"></p>
<h2 id="5-数据结构-string-为什么上面的阈值是44呢？"><a href="#5-数据结构-string-为什么上面的阈值是44呢？" class="headerlink" title="5.数据结构-string  为什么上面的阈值是44呢？"></a>5.数据结构-string  为什么上面的阈值是44呢？</h2><p>一个字符串包含RedisObject和SDS的数据结构，至少会占用19（16 + 3）个字节的空间大小。</p>
<p>C语言中的内存分配器分配内存大小的单位都是2的n次方，为了容纳一个完整的embstr对象，最少要分配32字节的空间。稍微长一些就是64字节了。所以定义大于64字节就属于大字符串。</p>
<p>64-19 = 45.剩余可防存放字符串的空间45字节，而字符串又是以NULL结尾，占据了1个字节，所以阈值为44</p>
<h2 id="6-数据结构-List"><a href="#6-数据结构-List" class="headerlink" title="6.数据结构-List"></a>6.数据结构-List</h2><p>1).Redis3.2版本之前，使用两种数据结构作为底层实现。</p>
<p>1.压缩列表 zipList<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p>
<p>设计初衷是为了节约内存。使用一块连续的内存空间存储。每个元素长度不同，采用变长编码</p>
<p>如果采用双向链表，那么就需要额外的内存空间来维护头尾两个指针，在zipList在结构上可以得到上一个结点的长度和当前结点的长度。通过上一个结点的长度可以定位到上一个元素起始的位置，而通过当前结点的长度，可以将指针定位到下一个元素的起始位置。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/uWGGCP.png" alt="image-20250103170948845"></p>
<p>变长编码体现在prevrawlensize属性，它记录的是prerawlen的大小，分为两种。</p>
<p>a.若前一个结点的长度小于254字节，那么则使用1字节来存储prerawlen</p>
<p>b.若前一个结点的长度大于等于254字节，那么将第一个字节设置为254，然后接下来的4个字节保存实际的长度。也就是用5个字节来表示prerawlen的长度。</p>
<p>存在连锁更新问题</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/19QcEp.png" alt="image-20250103171040501"></p>
<p>2.双向链表 LinkedList</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/nlVJG4.png" alt="image-20250103170908319"></p>
<p>2).3.2之后，将压缩列表和双向链表结合，称之为quickList<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(5)——quicklist" target="_blank">Redis内部数据结构详解(5)——quicklist</a></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/C2q46W.png" alt="image-20250103170838283"></p>
<h2 id="7-数据结构-hash"><a href="#7-数据结构-hash" class="headerlink" title="7.数据结构-hash"></a>7.数据结构-hash</h2><p>1).当数据量较小的时候，采用zipList作为hash的底层实现<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p>
<p>2).另一种方式是字典dict<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/IYVx7k.png" alt="image-20250103171223481"></p>
<p>rehashidx用于标记rehash的进度，为0 表示rehash开始</p>
<p>hash表dictht结构</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/21EHHO.png" alt="image-20250103171255778"></p>
<p>table 2维数组，第一维度数组表示hash表的槽位，第二个维度是每一个槽对应的链表</p>
<p>真正的存储数据的结构dictEnrty</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/WQwrSU.png" alt="image-20250103171324284"></p>
<p>完整结构图</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/JL9imI.png" alt="image-20250103171429515"></p>
<h2 id="8-dict的扩容和缩容"><a href="#8-dict的扩容和缩容" class="headerlink" title="8.dict的扩容和缩容"></a>8.dict的扩容和缩容</h2><p>1).扩容</p>
<p>是为了减少hash冲突的概率</p>
<p>扩容的时机：</p>
<p>a.BGSAVE和BGREWRITEAOF指令的情况下，hash表的负载因子大于等于1的时候进行扩容。</p>
<p>b.正在执行BGSAVE和BGREWRITEAOF指令的情况下，hash表的负载因子大于等于5的时候进行扩容。</p>
<p>扩容的大小:</p>
<p>扩容后的dictEntry数组长度为第一个大于等于 ht[0].used * 2 的 2^n 也就是第一个大于等于已使用数量的两倍的2的幂次方。</p>
<p>渐进式rehash:</p>
<p>rehash进行期间，每次对字典执行添加、删除、查找或者更新操作的时候，除了执行指定的操作之外，还会顺带将dictht[0] hash表当中在rehashidx索引上的所有键值对进行rehash到dictht[1]当中，当一次rehash工作完成之后，会将rehashidx的值+1。</p>
<p>同时在循环时间事件serverCron当中，会调用rehash相关函数，在1ms的时间内，进行rehash处理，每次仅处理少量的转移任务（100个元素）</p>
<p>随着字典操作的不断执行，最终在某个时间点上，dictht[0]当中所有的键值对都会被rehash到dictht[1]当中，此时将rehashidx属性值设置为-1，表示rehash操作已经完成，将dictht[0]重新赋值dictht[1],接着清空dictht[1]。</p>
<p>2).缩容</p>
<p>减少空间的消耗。</p>
<p>缩容的时机：</p>
<p>负载因子小于0.1的时候，Redis自动开始对Hash表进行缩容操作。</p>
<p>缩容的大小：</p>
<p>缩容后的dictEntry数组长度为第一个大于等于 ht[0].used 的 2^n 也就是第一个大于等于已使用数量的2的幂次方。</p>
<h2 id="9-数据结构-set"><a href="#9-数据结构-set" class="headerlink" title="9.数据结构-set"></a>9.数据结构-set</h2><p>1).当存储的元素都是整数值，且数据量不大时使用inset<br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(7)——intset" target="_blank">Redis内部数据结构详解(7)——intset</a></p>
<p>结构定义</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/iZlIcI.png" alt="image-20250103172348366"></p>
<p>编码格式有3种，为了节省内存，会根据插入数据的大小选择不一样的类型来存储。</p>
<p>length记录保存数据的数组contents中共有多少个元素。</p>
<p>contents数组，真正存储数据的地方，数组时按照从小到大有序排列，且不包含任何重复项</p>
<p>优点：节省内存</p>
<p>缺点：升级过程中消耗资源；不支持降级</p>
<p>2).其他时候使用dict，结构等同于hash中的dict<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a></p>
<h2 id="10-inset整数升级过程"><a href="#10-inset整数升级过程" class="headerlink" title="10.inset整数升级过程"></a>10.inset整数升级过程</h2><p>假设一开始4个元素，1、2、3、4，依次存储在contents当中。每个元素占据了16位</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/L5nEHg.png" alt="image-20250103172542625"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/uH4W1J.png" alt="image-20250103172557637"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/mICCJ6.png" alt="image-20250103172610323"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/P8Eq4z.png" alt="image-20250103172625367"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/SZYlK6.png" alt="image-20250103172640937"></p>
<h2 id="11-数据结构-zset"><a href="#11-数据结构-zset" class="headerlink" title="11.数据结构-zset"></a>11.数据结构-zset</h2><p>1).ziplist，元素数量小于128个 所有元素的长度都小于64字节的时候 使用该数据结构。<br>地址：<a href="/2024/12/30/5.缓存/Redis内部数据结构详解(4)——ziplist" target="_blank">Redis内部数据结构详解(4)——ziplist</a></p>
<p>以上两个条件可以通过Redis配置文件 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改</p>
<p>2).其他时候，由跳表和字典组成的数据结构<br>地址：<a href="/2024/12/26/5.缓存/Redis内部数据结构详解(1)——dict" target="_blank">Redis内部数据结构详解(1)——dict</a><br>地址：<a href="/2025/01/02/5.缓存/Redis内部数据结构详解(6)——skiplist" target="_blank">Redis内部数据结构详解(6)——skiplist</a></p>
<p>字典结构来存储value和score的对应关系，跳表提供按照score排序的功能</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/AYmEZm.png" alt="image-20250103173213499"></p>
<p>zskiplist是skiplist的数据结构</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/oI339f.png" alt="image-20250103173239203"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Xm4xz5.png" alt="image-20250103173253700"></p>
<p>跳表结构的更新：</p>
<p>当插入一个数据的时候，根据score找到插入的位置，然后随机计算出结点的层数，插入，再修改结点间的引用关系。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/H7HYma.png" alt="image-20250103173351076"></p>
<p>随机层数的伪代码：</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/bmyxCe.png" alt="image-20250103173418136"></p>
<p>p为0.25，MaxLevel为32</p>
<h2 id="12-Redis持久化"><a href="#12-Redis持久化" class="headerlink" title="12.Redis持久化"></a>12.Redis持久化</h2><p>1).RDB快照(snapshot)</p>
<p>Redis DataBase缩写快找。Redis中的默认的持久化机制</p>
<p>按照一定的时间将内存的数据以快找的形式保存到磁盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>N 秒内数据集至少有 M 个改动  例如 save 60 1000  表示 60秒至少有1000个键被改动 则自动保存一次</p>
<p>优点:</p>
<p>a.只有一个文件dump.rdb，方便持久化</p>
<p>b.容灾性好，一个文件可以保存到安全的磁盘</p>
<p>c.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能</p>
<p>d.相对于数据集大时，比AOF的启动效率更高。</p>
<p>缺点:</p>
<p>a.数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。</p>
<p>2).AOF(append-only file)</p>
<p>将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p>
<p>优点:</p>
<p>a.数据安全</p>
<p>b.AOF rewrite模式。AOF文件没有被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令。</p>
<p>c.aof文件是明文的，可阅读性较好</p>
<p>缺点:</p>
<p>a.AOF文件比RDB文件大，且恢复速度慢</p>
<p>b.数据集大的时候，比RDB启动效率低</p>
<p>3).当两种方式同时开启的时候，Redis会优先选择AOF恢复</p>
<p>4).混合持久化</p>
<p>Redis4.0新的持久化选项</p>
<p>将rdb文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志</p>
<h2 id="13-Redis的过期策略有哪些"><a href="#13-Redis的过期策略有哪些" class="headerlink" title="13.Redis的过期策略有哪些"></a>13.Redis的过期策略有哪些</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了</p>
<p>1).定时过期</p>
<p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即删除。</p>
<p>该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>
<p>2).惰性过期</p>
<p>只有当访问一个key的时候，才会判断key是否过期，过期则删除。</p>
<p>该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p>3).定期过期</p>
<p>每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。</p>
<p>通过调整定时扫描器的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>redis中同时使用了惰性过期和定期过期两种策略。</p>
<h2 id="14-Redis的内存淘汰策略有哪些"><a href="#14-Redis的内存淘汰策略有哪些" class="headerlink" title="14.Redis的内存淘汰策略有哪些"></a>14.Redis的内存淘汰策略有哪些</h2><p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用）</p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p>
<ol>
<li>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</li>
<li>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</li>
</ol>
<h2 id="15-缓存雪崩、缓存击穿、缓存穿透及解决方案"><a href="#15-缓存雪崩、缓存击穿、缓存穿透及解决方案" class="headerlink" title="15.缓存雪崩、缓存击穿、缓存穿透及解决方案"></a>15.缓存雪崩、缓存击穿、缓存穿透及解决方案</h2><ul>
<li><strong>缓存雪崩</strong>：缓存同一时间大面积失效，后面请求都落到数据库上，造成大量请求直接打到数据库。<ol>
<li>过期时间随机，防止同一时间大量数据过期</li>
<li>缓存预热：项目启动加载缓存到redis</li>
<li>互斥锁：修改的时候只允许一个线程修改数据库，其他读写线程等待</li>
<li>加相应缓存标记，记录缓存是否失效，如果失效，更新缓存(内存消耗大，一般不用)</li>
</ol>
</li>
<li><strong>缓存穿透</strong>：指数据库没有数据，导致请求落到数据库上<ol>
<li>接口层增加校验，对id进行规则拦截</li>
<li>缓存取不到数据，设置null值到缓存，设置短时间超时，防止网络攻击</li>
<li>布隆过滤器，所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据就会被这个bitmap拦截</li>
</ol>
</li>
<li><strong>缓存击穿</strong>：缓存没有，数据库中有数据（一般是缓存时间到期），并发用户特别多，同时大量请求落到数据库，缓存击穿指并发查询同一条数据，缓存雪崩是不同数据都过期<ol>
<li>key不过期</li>
<li>加互斥锁</li>
</ol>
</li>
</ul>
<h2 id="16-大key"><a href="#16-大key" class="headerlink" title="16.大key"></a>16.大key</h2><p>按照一定规则拆分大key，比如一个key中放入了全量类型的配置，可以拆成若干个不同类型的key，大key变小。</p>
<h2 id="17-热key"><a href="#17-热key" class="headerlink" title="17.热key"></a>17.热key</h2><p>集群模式下，把key复制若干份，使得不同的key分配在不同的槽中，用户访问的时候，可以根据用户id进行hash操作，使不同用户访问不同的key，但是这些key里的信息都是完全一致的，同时更新缓存的时候也需要注意更新所有的缓存key</p>
<h2 id="18-缓存与数据库数据一致性"><a href="#18-缓存与数据库数据一致性" class="headerlink" title="18.缓存与数据库数据一致性"></a>18.缓存与数据库数据一致性</h2><img src="https://zhangxin66666.github.io/imageCenter/uPic/202203/31/HwOLrx.png" />

<p>解决方案：</p>
<ol>
<li>对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li>
<li>就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li>
<li>如果不能容忍缓存数据不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</li>
<li>也可以用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</li>
</ol>
<h2 id="19-redis主从模式"><a href="#19-redis主从模式" class="headerlink" title="19.redis主从模式"></a>19.redis主从模式</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/ygdr0K.png" alt="image-20250103194315166"></p>
<p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/MaCJgw.png" alt="image-20250103194336735"></p>
<h2 id="20-redis主从同步完整的复制流程"><a href="#20-redis主从同步完整的复制流程" class="headerlink" title="20.redis主从同步完整的复制流程"></a>20.redis主从同步完整的复制流程</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Hu0vV9.png" alt="image-20250103194420907"></p>
<h2 id="21-master节点-run-id的作用"><a href="#21-master节点-run-id的作用" class="headerlink" title="21.master节点 run id的作用"></a>21.master节点 run id的作用</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/pQgEVY.png" alt="image-20250103194507663"></p>
<h2 id="22-主从模式全量复制"><a href="#22-主从模式全量复制" class="headerlink" title="22.主从模式全量复制"></a>22.主从模式全量复制</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/UYw9C3.png" alt="image-20250103194701314"></p>
<h2 id="23-主从模式增量同步"><a href="#23-主从模式增量同步" class="headerlink" title="23.主从模式增量同步"></a>23.主从模式增量同步</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/L8uamg.png" alt="image-20250103194716908"></p>
<h2 id="24-redis哨兵模式（sentinal）"><a href="#24-redis哨兵模式（sentinal）" class="headerlink" title="24.redis哨兵模式（sentinal）"></a>24.redis哨兵模式（sentinal）</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/UgkOH4.png" alt="image-20250103194800854"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/QCCXWz.png" alt="image-20250103194827176"></p>
<p>为什么redis哨兵集群只有2个节点无法正常工作</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/DdMjxl.png" alt="image-20250103194857786"></p>
<p>经典的3节点哨兵集群</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/Hvikh4.png" alt="image-20250103194923140"></p>
<p>异步复制导致的数据丢失问题</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/KPp10n.png" alt="image-20250103195018023"></p>
<p>集群脑裂导致的数据丢失问题</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/pKPBFB.png" alt="image-20250103195042749"></p>
<p>解决异步复制和脑裂导致的数据丢失</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/vUFWYC.png" alt="image-20250103195222151"></p>
<p>redis哨兵的选举算法</p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/cpGAz7.png" alt="image-20250103195251420"></p>
<h2 id="25-redis集群模式cluster"><a href="#25-redis集群模式cluster" class="headerlink" title="25.redis集群模式cluster"></a>25.redis集群模式cluster</h2><p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/NPhM4O.png" alt="image-20250103195336523"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/XSllGZ.png" alt="image-20250103195400875"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/bqT5gR.png" alt="image-20250103195413493"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/IYFZRT.png" alt="image-20250103195429337"></p>
<p><img src="https://zhangxin66666.github.io/imageCenter/uPic/202501/03/0REkEU.png" alt="image-20250103195446204"></p>
<h2 id="26-一致性hash"><a href="#26-一致性hash" class="headerlink" title="26.一致性hash"></a>26.一致性hash</h2><h2 id="3-redis单线程为什么快"><a href="#3-redis单线程为什么快" class="headerlink" title="3.redis单线程为什么快"></a>3.redis单线程为什么快</h2><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p>
<ol>
<li>完全基于内存操作</li>
<li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li>
<li>使用单线程，无上下文的切换成本</li>
<li>基于非阻塞的IO多路复用机制</li>
</ol>
<h2 id="4-redis单线程模型"><a href="#4-redis单线程模型" class="headerlink" title="4.redis单线程模型"></a>4.redis单线程模型</h2><h2 id="5-那为什么Redis6-0之后又改用多线程呢"><a href="#5-那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="5.那为什么Redis6.0之后又改用多线程呢?"></a>5.那为什么Redis6.0之后又改用多线程呢?</h2><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p>
<p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p>
<h2 id="10-redis淘汰策略？（同问题定期-惰性都没有删除过期的key怎么办？）"><a href="#10-redis淘汰策略？（同问题定期-惰性都没有删除过期的key怎么办？）" class="headerlink" title="10.redis淘汰策略？（同问题定期+惰性都没有删除过期的key怎么办？）"></a>10.redis淘汰策略？（同问题定期+惰性都没有删除过期的key怎么办？）</h2><h2 id="11-redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁"><a href="#11-redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁" class="headerlink" title="11.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁"></a>11.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁</h2><h2 id="13-redis主从复制原理（全量同步-amp-增量同步）"><a href="#13-redis主从复制原理（全量同步-amp-增量同步）" class="headerlink" title="13.redis主从复制原理（全量同步&amp;增量同步）"></a>13.redis主从复制原理（全量同步&amp;增量同步）</h2><h2 id="14-redis哨兵模式"><a href="#14-redis哨兵模式" class="headerlink" title="14.redis哨兵模式"></a>14.redis哨兵模式</h2><h2 id="15-redis集群模式"><a href="#15-redis集群模式" class="headerlink" title="15.redis集群模式"></a>15.redis集群模式</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="17-redis和数据库数据一致性问题"><a href="#17-redis和数据库数据一致性问题" class="headerlink" title="17.redis和数据库数据一致性问题"></a>17.redis和数据库数据一致性问题</h2><h2 id="18-BloomFilter过滤器原理"><a href="#18-BloomFilter过滤器原理" class="headerlink" title="18.BloomFilter过滤器原理"></a>18.BloomFilter过滤器原理</h2><h2 id="19-场景题"><a href="#19-场景题" class="headerlink" title="19.场景题"></a>19.场景题</h2><p>排行榜（多维度）</p>
<p>签到</p>
<p>redis实现消息队列</p>
<p>一般使用list结构作为队列，<strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>
<p>如果对方追问可不可以不用sleep呢？</p>
<p>list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>如果对方接着追问能不能生产一次消费多次呢？</p>
<p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p>
<p>如果对方继续追问 pub/su b有什么缺点？</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<strong>RocketMQ</strong>等。</p>
<p>如果对方究极TM追问Redis如何实现延时队列？</p>
<p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用<strong>zrangebyscore</strong>指令获取N秒之前的数据轮询进行处理。</p>
<h2 id="Redis单线程模型"><a href="#Redis单线程模型" class="headerlink" title="Redis单线程模型"></a>Redis单线程模型</h2><p>Redis基于Reactor模式开发的网络事件处理器，这个文件事件处理器是单线程的，采用IO多路复用机制监听多个Socker，根据Socker上的事件类型选择对应的事件处理器处理这个事件，可以实现高性能的网络通信。文件事件处理器包含4个部分，多个Socker，IO多路复用程序，文件事件分派器和事件处理器(命令请求处理器，命令回复处理器，链接应答处理器)，多个Socket可能并发产生不同操作，每个操作对应不同的文件事件，但是IO多路复用会监听多个Socket，会将Socket放入一个队列，每次从队列中取出一个Socket给时间分派器，时间分派器把Socket给对应的事件处理器。</p>
<p>单线程快的原因：1.纯内存操作；2.核心是基于非阻塞的IO多路复用机制；3.单线程反而避免多线程的频繁上下文切换</p>
<h2 id="分布式锁怎么实现的？"><a href="#分布式锁怎么实现的？" class="headerlink" title="分布式锁怎么实现的？"></a>分布式锁怎么实现的？</h2><ol>
<li>基于数据库实现分布式锁：唯一索引，状态机唯一联合索引</li>
<li>基于缓存（Redis等）实现分布式锁：SET key value NX PX 30000</li>
<li>基于Zookeeper实现分布式锁；</li>
</ol>
<h2 id="setnx用到的参数"><a href="#setnx用到的参数" class="headerlink" title="setnx用到的参数"></a>setnx用到的参数</h2><p><code>SET key value NX PX 30000</code></p>
<p>第三个参数：把key、value set到redis中的策略</p>
<ul>
<li>  nx ： not exists, 只有key 不存在时才把key value set 到redis</li>
<li>  xx ： is exists ，只有 key 存在是，才把key value set 到redis</li>
</ul>
<p>第四个参数：过期时间单位</p>
<ul>
<li>  ex ：seconds 秒</li>
<li>  px : milliseconds 毫秒</li>
</ul>
<p>使用其他值，抛出 异常 ： redis.clients.jedis.exceptions.JedisDataException : ERR syntax error</p>
<p>第五个参数：有两种可选的值，</p>
<p>int 和long 的time，都是过期时间 ，expx 参数是px的时候，使用long类型的参数，可以表示更多时间</p>
<p>-</p>
<h2 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h2><ol start="2">
<li></li>
<li><p>1. </p>
</li>
<li></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">金子爸爸</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zhangxin66666.github.io/2024/12/25/5.%E7%BC%93%E5%AD%98/%E9%9D%A2%E8%AF%95-redis/">https://zhangxin66666.github.io/2024/12/25/5.缓存/面试-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸</a> 许可协议。转载请注明来自 <a href="https://zhangxin66666.github.io" target="_blank">金子爸爸の家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/%E9%9D%A2%E8%AF%95.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/26/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(1)%E2%80%94%E2%80%94dict/"><img class="prev-cover" src="/images/cover/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis内部数据结构详解(1)——dict</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/23/3.jvm/%E9%9D%A2%E8%AF%95-JVM/"><img class="next-cover" src="/images/cover/%E9%9D%A2%E8%AF%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM面试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(3)%E2%80%94%E2%80%94robj/" title="Redis内部数据结构详解(3)——robj"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-30</div><div class="title">Redis内部数据结构详解(3)——robj</div></div></a></div><div><a href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(4)%E2%80%94%E2%80%94ziplist/" title="Redis内部数据结构详解(4)——ziplist"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-30</div><div class="title">Redis内部数据结构详解(4)——ziplist</div></div></a></div><div><a href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(6)%E2%80%94%E2%80%94skiplist/" title="Redis内部数据结构详解(6)——skiplist"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="title">Redis内部数据结构详解(6)——skiplist</div></div></a></div><div><a href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(7)%E2%80%94%E2%80%94intset/" title="Redis内部数据结构详解(7)——intset"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-02</div><div class="title">Redis内部数据结构详解(7)——intset</div></div></a></div><div><a href="/2024/12/26/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(1)%E2%80%94%E2%80%94dict/" title="Redis内部数据结构详解(1)——dict"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="title">Redis内部数据结构详解(1)——dict</div></div></a></div><div><a href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(2)%E2%80%94%E2%80%94sds/" title="Redis内部数据结构详解(2)——sds"><img class="cover" src="/images/cover/redis.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-30</div><div class="title">Redis内部数据结构详解(2)——sds</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">金子爸爸</div><div class="author-info__description">欢迎来到金子爸爸的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangxin66666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangxin66666" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:379104065@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到金子爸爸的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：QQ：379104065</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.底层数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AF%B9%E8%B1%A1%E5%A4%B4RedisObject"><span class="toc-text">2.数据结构-对象头RedisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-string"><span class="toc-text">3.数据结构-string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-string-%E4%B8%89%E7%A7%8D%E5%BA%95%E5%B1%82%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><span class="toc-text">4.数据结构-string 三种底层编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-string-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%98%88%E5%80%BC%E6%98%AF44%E5%91%A2%EF%BC%9F"><span class="toc-text">5.数据结构-string  为什么上面的阈值是44呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-List"><span class="toc-text">6.数据结构-List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hash"><span class="toc-text">7.数据结构-hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-dict%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E7%BC%A9%E5%AE%B9"><span class="toc-text">8.dict的扩容和缩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-set"><span class="toc-text">9.数据结构-set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-inset%E6%95%B4%E6%95%B0%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-text">10.inset整数升级过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-zset"><span class="toc-text">11.数据结构-zset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">12.Redis持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">13.Redis的过期策略有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">14.Redis的内存淘汰策略有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">15.缓存雪崩、缓存击穿、缓存穿透及解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%A4%A7key"><span class="toc-text">16.大key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%83%ADkey"><span class="toc-text">17.热key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">18.缓存与数据库数据一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-redis%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">19.redis主从模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">20.redis主从同步完整的复制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-master%E8%8A%82%E7%82%B9-run-id%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">21.master节点 run id的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-text">22.主从模式全量复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-text">23.主从模式增量同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinal%EF%BC%89"><span class="toc-text">24.redis哨兵模式（sentinal）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8Fcluster"><span class="toc-text">25.redis集群模式cluster</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E4%B8%80%E8%87%B4%E6%80%A7hash"><span class="toc-text">26.一致性hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="toc-text">3.redis单线程为什么快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">4.redis单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88Redis6-0%E4%B9%8B%E5%90%8E%E5%8F%88%E6%94%B9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2"><span class="toc-text">5.那为什么Redis6.0之后又改用多线程呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F%EF%BC%88%E5%90%8C%E9%97%AE%E9%A2%98%E5%AE%9A%E6%9C%9F-%E6%83%B0%E6%80%A7%E9%83%BD%E6%B2%A1%E6%9C%89%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84key%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%EF%BC%89"><span class="toc-text">10.redis淘汰策略？（同问题定期+惰性都没有删除过期的key怎么办？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%88%E6%99%AE%E9%80%9A%E3%80%81%E6%9C%89%E5%BA%8F%E4%B8%A4%E7%A7%8D%EF%BC%89%E3%80%81redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">11.redis分布式锁、zk分布式锁（普通、有序两种）、redission分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5-amp-%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="toc-text">13.redis主从复制原理（全量同步&amp;增量同步）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">14.redis哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">15.redis集群模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">17.redis和数据库数据一致性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-BloomFilter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">18.BloomFilter过滤器原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">19.场景题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">分布式锁怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setnx%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">setnx用到的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-text">Redis过期键删除策略</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(6)%E2%80%94%E2%80%94skiplist/" title="Redis内部数据结构详解(6)——skiplist"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis内部数据结构详解(6)——skiplist"/></a><div class="content"><a class="title" href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(6)%E2%80%94%E2%80%94skiplist/" title="Redis内部数据结构详解(6)——skiplist">Redis内部数据结构详解(6)——skiplist</a><time datetime="2025-01-01T16:00:00.000Z" title="发表于 2025-01-02 00:00:00">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(7)%E2%80%94%E2%80%94intset/" title="Redis内部数据结构详解(7)——intset"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis内部数据结构详解(7)——intset"/></a><div class="content"><a class="title" href="/2025/01/02/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(7)%E2%80%94%E2%80%94intset/" title="Redis内部数据结构详解(7)——intset">Redis内部数据结构详解(7)——intset</a><time datetime="2025-01-01T16:00:00.000Z" title="发表于 2025-01-02 00:00:00">2025-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(3)%E2%80%94%E2%80%94robj/" title="Redis内部数据结构详解(3)——robj"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis内部数据结构详解(3)——robj"/></a><div class="content"><a class="title" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(3)%E2%80%94%E2%80%94robj/" title="Redis内部数据结构详解(3)——robj">Redis内部数据结构详解(3)——robj</a><time datetime="2024-12-29T16:00:00.000Z" title="发表于 2024-12-30 00:00:00">2024-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(4)%E2%80%94%E2%80%94ziplist/" title="Redis内部数据结构详解(4)——ziplist"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis内部数据结构详解(4)——ziplist"/></a><div class="content"><a class="title" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(4)%E2%80%94%E2%80%94ziplist/" title="Redis内部数据结构详解(4)——ziplist">Redis内部数据结构详解(4)——ziplist</a><time datetime="2024-12-29T16:00:00.000Z" title="发表于 2024-12-30 00:00:00">2024-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(2)%E2%80%94%E2%80%94sds/" title="Redis内部数据结构详解(2)——sds"><img src="/images/cover/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis内部数据结构详解(2)——sds"/></a><div class="content"><a class="title" href="/2024/12/30/5.%E7%BC%93%E5%AD%98/Redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3(2)%E2%80%94%E2%80%94sds/" title="Redis内部数据结构详解(2)——sds">Redis内部数据结构详解(2)——sds</a><time datetime="2024-12-29T16:00:00.000Z" title="发表于 2024-12-30 00:00:00">2024-12-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/%E9%9D%A2%E8%AF%95.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By 金子爸爸</div><div class="footer_custom_text">学无止境</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="哆啦A梦,足球小子,四驱兄弟,宠物小精灵,火影忍者,美少女战士,数码宝贝,龙珠,光能使者,奥特曼,铁胆火车侠,变形金刚,海尔兄弟,蜡笔小新" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>